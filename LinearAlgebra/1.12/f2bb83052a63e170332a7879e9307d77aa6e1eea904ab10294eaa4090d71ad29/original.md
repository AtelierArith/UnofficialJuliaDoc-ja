inertia(B::BunchKaufman; atol::Real=0, rtol::Real=atol>0 ? 0 : n*ϵ) ->     np::Union{Nothing,Integer}, nn::Union{Nothing,Integer}, nz::Integer

`inertia` computes the numerical inertia (the number of positive, negative and zero eigenvalues, given by `np`, `nn` and `nz`, respectively) of a real symmetric of Hermitian matrix `B` that has been factored using the Bunch-Kaufman algorithm. For complex symmetric matrices the inertia is not defined. in that case `np` and `nn` are set to `nothing`, but the function still returns the number of zero eigenvalues. The inertia is computed by counting the eigenvalues signs of `B.D`. The number of zero eigenvalues is computed as the number of estimated eigenvalues with complex 1-norm (defined as `|re(.)|+|im(.)|`) less or equal than `max(atol, rtol*s₁)`, where `s₁` is an upper bound of the largest singular value of `B.D`, `σ₁` (more specifically, `0.5*s₁ <= σ₁ <= s₁` for real matrices and `0.35*s₁ <= σ₁ <= s₁` for complex matrices). `atol` and `rtol` are the absolute and relative tolerances, respectively. The default relative tolerance is `n*ϵ`, where `n` is the size of  of `A`, and `ϵ` is the [`eps`](@ref) of the number type of `A`, if this type is a subtype of `AbstractFloat`. In any other case (if the number type of `A` is `Rational`, for example) `ϵ` is set to `0`.

!!! note
    Numerical inertia can be a sensitive and imprecise characterization of ill-conditioned matrices with eigenvalues that are close in magnitude to the threshold tolerance `max(atol, rtol*s₁)`. In such cases, slight perturbations to the Bunch-Kaufman computation or to the matrix can change the result of `rank` by pushing one or more eigenvalues across the threshold. These variations can even occur due to changes in floating-point errors between different Julia versions, architectures, compilers, or operating systems. In particular, the size of the entries of the tringular factor directly influende the scale of the eigenvalues of the diagonal factor, so it is strongly recommended to use rook pivoting is the inertia is going to be computed. On the other hand, if the matrix has rational entries, the inertia computation is guaranteed is to be exact, as long as there is no under/overflow in the underlying integer type (and in such cases Julia itself throws an error), or a positive tolerance (absolute or relative) is specified.

