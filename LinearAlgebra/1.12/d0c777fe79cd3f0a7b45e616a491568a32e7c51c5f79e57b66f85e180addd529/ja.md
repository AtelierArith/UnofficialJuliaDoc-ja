```julia
ldiv!(Y, A, B) -> Y
```

`A \ B`をインプレースで計算し、結果を`Y`に格納して返します。

引数`A`は*行列*であってはなりません。むしろ、行列の代わりに因子分解オブジェクト（例えば、[`factorize`](@ref)や[`cholesky`](@ref)によって生成されたもの）である必要があります。これは、因子分解自体が高コストであり、通常はメモリを割り当てるためです（ただし、[`lu!`](@ref)などを介してインプレースで行うことも可能です）。`ldiv!`を必要とするパフォーマンスクリティカルな状況では、通常、`A`の因子分解に対する細かい制御も必要です。

!!! note
    `Diagonal`や`UpperTriangular`のような特定の構造化行列タイプは許可されています。これらはすでに因子化された形であるためです。


# 例

```jldoctest
julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> B = [1, 2.5, 3];

julia> Y = similar(B); # 読み取る必要がないため、similarを使用

julia> ldiv!(Y, qr(A), B); # さらに割り当てを減らすためにqr!(A)を試すこともできます

julia> Y ≈ A \ B
true
```
