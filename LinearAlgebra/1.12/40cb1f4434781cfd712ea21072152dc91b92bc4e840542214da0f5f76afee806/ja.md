```julia
ldiv!(A, B)
```

`A \ B`をインプレースで計算し、結果を`B`に上書きします。

引数`A`は*行列*であってはなりません。むしろ、行列の代わりに因子分解オブジェクト（例えば、[`factorize`](@ref)や[`cholesky`](@ref)によって生成されたもの）であるべきです。これは、因子分解自体が高コストであり、通常はメモリを割り当てるためです（ただし、例えば[`lu!`](@ref)を介してインプレースで行うことも可能です）。`ldiv!`を必要とするパフォーマンスクリティカルな状況では、通常、`A`の因子分解に対する細かい制御も必要です。

!!! note
    `Diagonal`や`UpperTriangular`のような特定の構造化行列型は許可されています。これらはすでに因子化された形であるためです。


# 例

```jldoctest
julia> A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia> B = [1, 2.5, 3];

julia> B0 = copy(B); # テストを容易にするためのバックアップコピー

julia> ldiv!(lu(A), B); # より少ない割り当てを実現するためにlu!(A)を試すこともできます

julia> B ≈ A \ B0
true
```
