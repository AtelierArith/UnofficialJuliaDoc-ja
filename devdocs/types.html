<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More about types · The Julia Language</title><meta name="title" content="More about types · The Julia Language"/><meta property="og:title" content="More about types · The Julia Language"/><meta property="twitter:title" content="More about types · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox" checked/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="ast.html">Julia ASTs</a></li><li class="is-active"><a class="tocitem" href="types.html">More about types</a><ul class="internal"><li><a class="tocitem" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)"><span>Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</span></a></li><li><a class="tocitem" href="#UnionAll-types"><span>UnionAll types</span></a></li><li><a class="tocitem" href="#Free-variables"><span>Free variables</span></a></li><li><a class="tocitem" href="#TypeNames"><span>TypeNames</span></a></li><li><a class="tocitem" href="#Tuple-types"><span>Tuple types</span></a></li><li><a class="tocitem" href="#Diagonal-types"><span>Diagonal types</span></a></li><li><a class="tocitem" href="#Subtyping-diagonal-variables"><span>Subtyping diagonal variables</span></a></li><li><a class="tocitem" href="#Introduction-to-the-internal-machinery"><span>Introduction to the internal machinery</span></a></li><li><a class="tocitem" href="#Subtyping-and-method-sorting"><span>Subtyping and method sorting</span></a></li></ul></li><li><a class="tocitem" href="object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="functions.html">Julia Functions</a></li><li><a class="tocitem" href="cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="subarrays.html">SubArrays</a></li><li><a class="tocitem" href="isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="sysimg.html">System Image Building</a></li><li><a class="tocitem" href="pkgimg.html">Package Images</a></li><li><a class="tocitem" href="llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="require.html">Module loading</a></li><li><a class="tocitem" href="inference.html">Inference</a></li><li><a class="tocitem" href="ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="build/linux.html">Linux</a></li><li><a class="tocitem" href="build/macos.html">macOS</a></li><li><a class="tocitem" href="build/windows.html">Windows</a></li><li><a class="tocitem" href="build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href="types.html">More about types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="types.html">More about types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/types.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="More-about-types"><a class="docs-heading-anchor" href="#More-about-types">More about types</a><a id="More-about-types-1"></a><a class="docs-heading-anchor-permalink" href="#More-about-types" title="Permalink"></a></h1><p>もしあなたがしばらくの間Juliaを使用しているなら、型が果たす基本的な役割を理解しているでしょう。ここでは、特に<a href="../manual/types.html#Parametric-Types">Parametric Types</a>に焦点を当てて、内部を掘り下げてみます。</p><h2 id="Types-and-sets-(and-Any-and-Union{}/Bottom)"><a class="docs-heading-anchor" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)">Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</a><a id="Types-and-sets-(and-Any-and-Union{}/Bottom)-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)" title="Permalink"></a></h2><p>ジュリアの型システムを考える際、セットの観点から考えるのが最も簡単かもしれません。プログラムは個々の値を操作しますが、型は値のセットを指します。これはコレクションとは異なります。たとえば、<a href="../base/collections.html#Base.Set"><code>Set</code></a> の値は、それ自体が単一の <code>Set</code> 値です。むしろ、型は<em>可能な</em>値のセットを説明し、どの値を持っているかについての不確実性を表現します。</p><p><em>コンクリート</em>型 <code>T</code> は、<a href="../base/base.html#Core.typeof"><code>typeof</code></a> 関数によって返される直接タグが <code>T</code> である値の集合を記述します。<em>抽象</em>型は、いくつかの可能性のあるより大きな値の集合を記述します。</p><p><a href="../base/base.html#Core.Any"><code>Any</code></a> は可能な値の全宇宙を表します。 <a href="../base/numbers.html#Core.Integer"><code>Integer</code></a> は <code>Any</code> のサブセットであり、<code>Int</code>、<a href="../base/numbers.html#Core.Int8"><code>Int8</code></a>、および他の具体的な型を含みます。内部的に、Julia は <code>Bottom</code> として知られる別の型を多用しており、これは <code>Union{}</code> としても書くことができます。これは空集合に対応します。</p><p>ジュリアの型は集合論の標準的な操作をサポートしています：<code>T1</code> が <code>T2</code> の「部分集合」（サブタイプ）であるかどうかを <code>T1 &lt;: T2</code> で確認できます。同様に、<a href="../base/base.html#Base.typeintersect"><code>typeintersect</code></a> を使用して2つの型を交差させ、<a href="../base/base.html#Core.Union"><code>Union</code></a> でその和を取ることができ、<a href="../base/base.html#Base.typejoin"><code>typejoin</code></a> を使用してその和を含む型を計算できます。</p><pre><code class="language-julia-repl hljs">julia&gt; typeintersect(Int, Float64)
Union{}

julia&gt; Union{Int, Float64}
Union{Float64, Int64}

julia&gt; typejoin(Int, Float64)
Real

julia&gt; typeintersect(Signed, Union{UInt8, Int8})
Int8

julia&gt; Union{Signed, Union{UInt8, Int8}}
Union{UInt8, Signed}

julia&gt; typejoin(Signed, Union{UInt8, Int8})
Integer

julia&gt; typeintersect(Tuple{Integer, Float64}, Tuple{Int, Real})
Tuple{Int64, Float64}

julia&gt; Union{Tuple{Integer, Float64}, Tuple{Int, Real}}
Union{Tuple{Int64, Real}, Tuple{Integer, Float64}}

julia&gt; typejoin(Tuple{Integer, Float64}, Tuple{Int, Real})
Tuple{Integer, Real}</code></pre><p>これらの操作は抽象的に見えるかもしれませんが、Juliaの中心にあります。たとえば、メソッドディスパッチは、メソッドリスト内のアイテムを順に確認し、引数タプルの型がメソッドシグネチャのサブタイプであるものに到達するまで進むことによって実装されています。このアルゴリズムが機能するためには、メソッドがその特異性によってソートされていることが重要であり、検索は最も特異的なメソッドから始まります。その結果、Juliaは型に対して部分順序も実装しています。これは、<code>&lt;:</code>に似た機能によって達成されますが、以下で説明する違いがあります。</p><h2 id="UnionAll-types"><a class="docs-heading-anchor" href="#UnionAll-types">UnionAll types</a><a id="UnionAll-types-1"></a><a class="docs-heading-anchor-permalink" href="#UnionAll-types" title="Permalink"></a></h2><p>Juliaの型システムは、<em>反復的な和</em>の型を表現することもできます。これは、ある変数のすべての値に対する型の和です。これは、いくつかのパラメータの値が不明な場合のパラメトリック型を説明するために必要です。</p><p>例えば、<a href="../base/arrays.html#Core.Array"><code>Array</code></a> には <code>Array{Int,2}</code> のように2つのパラメータがあります。要素の型がわからない場合、<code>Array{T,2} where T</code> と書くことができ、これはすべての値の <code>T</code> に対する <code>Array{T,2}</code> の和集合です：<code>Union{Array{Int8,2}, Array{Int16,2}, ...}</code>。</p><p>そのような型は <code>UnionAll</code> オブジェクトによって表され、変数（この例では <code>T</code>、型 <code>TypeVar</code>）とラップされた型（この例では <code>Array{T,2}</code>）を含みます。</p><p>次のメソッドを考慮してください：</p><pre><code class="language-julia hljs">f1(A::Array) = 1
f2(A::Array{Int}) = 2
f3(A::Array{T}) where {T&lt;:Any} = 3
f4(A::Array{Any}) = 4</code></pre><p>署名 - <a href="functions.html#Function-calls">Function calls</a> に記載されているように - <code>f3</code> の型は、タプル型をラップした <code>UnionAll</code> 型です: <code>Tuple{typeof(f3), Array{T}} where T</code>。<code>f4</code> を除くすべては <code>a = [1,2]</code> で呼び出すことができ、<code>f2</code> を除くすべては <code>b = Any[1,2]</code> で呼び出すことができます。</p><p>これらのタイプをもう少し詳しく見てみましょう：</p><pre><code class="language-julia-repl hljs">julia&gt; dump(Array)
UnionAll
  var: TypeVar
    name: Symbol T
    lb: Union{}
    ub: Any
  body: UnionAll
    var: TypeVar
      name: Symbol N
      lb: Union{}
      ub: Any
    body: Array{T, N} &lt;: DenseArray{T, N}
      ref::MemoryRef{T}
      size::NTuple{N, Int64}</code></pre><p>これは、<code>Array</code>が実際には<code>UnionAll</code>型の名前であることを示しています。各パラメータに対して1つの<code>UnionAll</code>型があり、ネストされています。構文<code>Array{Int,2}</code>は<code>Array{Int}{2}</code>と同等です。内部的には、各<code>UnionAll</code>は特定の変数値で一度に1つずつ、外側から内側へとインスタンス化されます。これにより、末尾の型パラメータを省略することに自然な意味が与えられます。<code>Array{Int}</code>は<code>Array{Int,N} where N</code>と同等の型を提供します。</p><p><code>TypeVar</code>はそれ自体が型ではなく、むしろ<code>UnionAll</code>型の構造の一部と考えるべきです。型変数には、その値に対する下限（<code>lb</code>）と上限（<code>ub</code>）があります。シンボル<code>name</code>は純粋に装飾的なものです。内部的には、<code>TypeVar</code>はアドレスによって比較されるため、異なる型変数を区別できるように可変型として定義されています。しかし、慣習としてそれらは変更されるべきではありません。</p><p><code>TypeVar</code>を手動で構築することができます：</p><pre><code class="language-julia-repl hljs">julia&gt; TypeVar(:V, Signed, Real)
Signed&lt;:V&lt;:Real</code></pre><p><code>name</code>シンボルを除くこれらの引数のいずれかを省略できる便利なバージョンがあります。</p><p><code>Array{T} where T&lt;:Integer</code> は次のように低下されます。</p><pre><code class="language-julia hljs">let T = TypeVar(:T,Integer)
    UnionAll(T, Array{T})
end</code></pre><p>したがって、<code>TypeVar</code>を手動で構築する必要はめったにありません（実際、これは避けるべきです）。</p><h2 id="Free-variables"><a class="docs-heading-anchor" href="#Free-variables">Free variables</a><a id="Free-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Free-variables" title="Permalink"></a></h2><p><em>自由</em> 型変数の概念は、型システムにおいて非常に重要です。変数 <code>V</code> が型 <code>T</code> の中で自由であるとは、<code>T</code> が変数 <code>V</code> を導入する <code>UnionAll</code> を含まない場合を指します。例えば、型 <code>Array{Array{V} where V&lt;:Integer}</code> には自由変数はありませんが、その中の <code>Array{V}</code> 部分には自由変数 <code>V</code> があります。</p><p>自由変数を持つ型は、ある意味では本当の型ではありません。型 <code>Array{Array{T}} where T</code> を考えてみましょう。これはすべての同種の配列の配列を指します。内側の型 <code>Array{T}</code> は、単独で見ると、あらゆる種類の配列を指しているように見えるかもしれません。しかし、外側の配列のすべての要素は<em>同じ</em>配列型を持たなければならないため、<code>Array{T}</code> は単なる古い配列を指すことはできません。言い換えれば、<code>Array{T}</code> は実質的に複数回「出現」し、<code>T</code> は各「回」で同じ値を持たなければならないと言えます。</p><p>この理由から、C API の <code>jl_has_free_typevars</code> 関数は非常に重要です。これが true を返す型は、サブタイピングやその他の型関数において意味のある回答を提供しません。</p><h2 id="TypeNames"><a class="docs-heading-anchor" href="#TypeNames">TypeNames</a><a id="TypeNames-1"></a><a class="docs-heading-anchor-permalink" href="#TypeNames" title="Permalink"></a></h2><p>次の2つの <a href="../base/arrays.html#Core.Array"><code>Array</code></a> タイプは機能的に同等ですが、出力が異なります：</p><pre><code class="language-julia-repl hljs">julia&gt; TV, NV = TypeVar(:T), TypeVar(:N)
(T, N)

julia&gt; Array
Array

julia&gt; Array{TV, NV}
Array{T, N}</code></pre><p>これらは、<code>TypeName</code>型のオブジェクトであるタイプの<code>name</code>フィールドを調べることで区別できます：</p><pre><code class="language-julia-repl hljs">julia&gt; dump(Array{Int,1}.name)
TypeName
  name: Symbol Array
  module: Module Core
  names: empty SimpleVector
  wrapper: UnionAll
    var: TypeVar
      name: Symbol T
      lb: Union{}
      ub: Any
    body: UnionAll
      var: TypeVar
        name: Symbol N
        lb: Union{}
        ub: Any
      body: Array{T, N} &lt;: DenseArray{T, N}
  cache: SimpleVector
    ...

  linearcache: SimpleVector
    ...

  hash: Int64 -7900426068641098781
  mt: MethodTable
    name: Symbol Array
    defs: Nothing nothing
    cache: Nothing nothing
    max_args: Int64 0
    module: Module Core
    : Int64 0
    : Int64 0</code></pre><p>この場合、関連するフィールドは <code>wrapper</code> であり、新しい <code>Array</code> タイプを作成するために使用されるトップレベルのタイプへの参照を保持しています。</p><pre><code class="language-julia-repl hljs">julia&gt; pointer_from_objref(Array)
Ptr{Cvoid} @0x00007fcc7de64850

julia&gt; pointer_from_objref(Array.body.body.name.wrapper)
Ptr{Cvoid} @0x00007fcc7de64850

julia&gt; pointer_from_objref(Array{TV,NV})
Ptr{Cvoid} @0x00007fcc80c4d930

julia&gt; pointer_from_objref(Array{TV,NV}.name.wrapper)
Ptr{Cvoid} @0x00007fcc7de64850</code></pre><p><a href="../base/arrays.html#Core.Array"><code>Array</code></a>の<code>wrapper</code>フィールドは自分自身を指していますが、<code>Array{TV,NV}</code>の場合は型の元の定義に戻ります。</p><p>他のフィールドについてはどうでしょうか？ <code>hash</code> は各タイプに整数を割り当てます。 <code>cache</code> フィールドを調べるには、Array よりもあまり使用されていないタイプを選ぶと便利です。まずは自分のタイプを作成してみましょう：</p><pre><code class="language-julia-repl hljs">julia&gt; struct MyType{T,N} end

julia&gt; MyType{Int,2}
MyType{Int64, 2}

julia&gt; MyType{Float32, 5}
MyType{Float32, 5}</code></pre><p>パラメトリック型をインスタンス化すると、各具体的な型が型キャッシュ（<code>MyType.body.body.name.cache</code>）に保存されます。ただし、自由型変数を含むインスタンスはキャッシュされません。</p><h2 id="Tuple-types"><a class="docs-heading-anchor" href="#Tuple-types">Tuple types</a><a id="Tuple-types-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple-types" title="Permalink"></a></h2><p>タプル型は興味深い特別なケースを構成します。 <code>x::Tuple</code>のような宣言でディスパッチが機能するためには、その型が任意のタプルを受け入れることができなければなりません。パラメータを確認してみましょう：</p><pre><code class="language-julia-repl hljs">julia&gt; Tuple
Tuple

julia&gt; Tuple.parameters
svec(Vararg{Any})</code></pre><p>他のタイプとは異なり、タプルタイプはそのパラメータにおいて共変であるため、この定義により <code>Tuple</code> は任意のタイプのタプルと一致することができます：</p><pre><code class="language-julia-repl hljs">julia&gt; typeintersect(Tuple, Tuple{Int,Float64})
Tuple{Int64, Float64}

julia&gt; typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})
Tuple{Int64, Float64}</code></pre><p>しかし、可変長引数（<code>Vararg</code>）のタプル型に自由変数がある場合、異なる種類のタプルを記述することができます：</p><pre><code class="language-julia-repl hljs">julia&gt; typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})
Tuple{Int64, Float64}

julia&gt; typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})
Union{}</code></pre><p><code>T</code>が<code>Tuple</code>型に対して自由である（すなわち、その束縛<code>UnionAll</code>型が<code>Tuple</code>型の外にある）場合、全体の型に対して1つの<code>T</code>値のみが機能しなければなりません。したがって、異種のタプルは一致しません。</p><p>最後に、<code>Tuple{}</code>は異なるものであることに注意する価値があります：</p><pre><code class="language-julia-repl hljs">julia&gt; Tuple{}
Tuple{}

julia&gt; Tuple{}.parameters
svec()

julia&gt; typeintersect(Tuple{}, Tuple{Int})
Union{}</code></pre><p>「プライマリ」タプル型とは何ですか？</p><pre><code class="language-julia-repl hljs">julia&gt; pointer_from_objref(Tuple)
Ptr{Cvoid} @0x00007f5998a04370

julia&gt; pointer_from_objref(Tuple{})
Ptr{Cvoid} @0x00007f5998a570d0

julia&gt; pointer_from_objref(Tuple.name.wrapper)
Ptr{Cvoid} @0x00007f5998a04370

julia&gt; pointer_from_objref(Tuple{}.name.wrapper)
Ptr{Cvoid} @0x00007f5998a04370</code></pre><p>そう <code>Tuple == Tuple{Vararg{Any}}</code> は確かに主要な型です。</p><h2 id="Diagonal-types"><a class="docs-heading-anchor" href="#Diagonal-types">Diagonal types</a><a id="Diagonal-types-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonal-types" title="Permalink"></a></h2><p><code>Tuple{T,T} where T</code>の型を考えてみましょう。このシグネチャを持つメソッドは次のようになります:</p><pre><code class="language-julia hljs">f(x::T, y::T) where {T} = ...</code></pre><p>通常の<code>UnionAll</code>型の解釈によれば、この<code>T</code>はすべての型、つまり<code>Any</code>を含むすべての型にわたるため、この型は<code>Tuple{Any,Any}</code>と同等であるべきです。しかし、この解釈は実際的な問題を引き起こします。</p><p>まず、<code>T</code> の値がメソッド定義内で利用可能である必要があります。<code>f(1, 1.0)</code> のような呼び出しでは、<code>T</code> が何であるべきかは明確ではありません。<code>Union{Int,Float64}</code> である可能性もありますし、あるいは <a href="../base/numbers.html#Core.Real"><code>Real</code></a> かもしれません。直感的には、宣言 <code>x::T</code> は <code>T === typeof(x)</code> を意味することを期待します。この不変条件を確保するためには、このメソッド内で <code>typeof(x) === typeof(y) === T</code> である必要があります。つまり、このメソッドは正確に同じ型の引数に対してのみ呼び出されるべきです。</p><p>2つの値が同じ型を持つかどうかに基づいてディスパッチできることは非常に便利であることがわかりました（これはプロモーションシステムによって使用されます）。したがって、<code>Tuple{T,T} where T</code>の異なる解釈を望む理由がいくつかあります。これを機能させるために、サブタイピングに次のルールを追加します：変数が共変位置に複数回出現する場合、それは具体的な型のみに制限されます。（「共変位置」とは、変数の出現とそれを導入する<code>UnionAll</code>型の間に<code>Tuple</code>および<code>Union</code>型のみが出現することを意味します。）このような変数は「対角変数」または「具体的変数」と呼ばれます。</p><p>例えば、<code>Tuple{T,T} where T</code> は <code>Union{Tuple{Int8,Int8}, Tuple{Int16,Int16}, ...}</code> と見なすことができ、ここで <code>T</code> はすべての具体的な型を範囲とします。これにより、いくつかの興味深いサブタイピングの結果が生じます。例えば、<code>Tuple{Real,Real}</code> は <code>Tuple{T,T} where T</code> のサブタイプではありません。なぜなら、<code>Tuple{Int8,Int16}</code> のように、2つの要素が異なる型を持つ型を含むからです。<code>Tuple{Real,Real}</code> と <code>Tuple{T,T} where T</code> は、非自明な交差 <code>Tuple{T,T} where T&lt;:Real</code> を持ちます。しかし、<code>Tuple{Real}</code> は <code>Tuple{T} where T</code> のサブタイプです。なぜなら、その場合 <code>T</code> は一度だけ出現し、対角的ではないからです。</p><p>次に、以下のような署名を考えてみてください：</p><pre><code class="language-julia hljs">f(a::Array{T}, x::T, y::T) where {T} = ...</code></pre><p>この場合、<code>T</code>は<code>Array{T}</code>の不変位置に出現します。つまり、渡される配列の型が明確に<code>T</code>の値を決定することを意味します – 我々は<code>T</code>に<em>等式制約</em>があると言います。したがって、この場合、対角ルールは本当に必要ではありません。なぜなら、配列が<code>T</code>を決定し、その後<code>x</code>と<code>y</code>が<code>T</code>の任意のサブタイプであることを許可できるからです。したがって、不変位置に出現する変数は決して対角的とは見なされません。この動作の選択はやや物議を醸しています – 一部の人々はこの定義を次のように書くべきだと感じています。</p><pre><code class="language-julia hljs">f(a::Array{T}, x::S, y::S) where {T, S&lt;:T} = ...</code></pre><p><code>x</code> と <code>y</code> が同じ型である必要があるかどうかを明確にするために。このバージョンのシグネチャでは、同じ型である必要がありますが、<code>x</code> と <code>y</code> が異なる型を持つことができる場合は、<code>y</code> の型のために第三の変数を導入することができます。</p><p>次の複雑さは、連合と対角変数の相互作用です。例えば、</p><pre><code class="language-julia hljs">f(x::Union{Nothing,T}, y::T) where {T} = ...</code></pre><p>この宣言が意味することを考えてみてください。<code>y</code>は型<code>T</code>を持っています。<code>x</code>は同じ型<code>T</code>を持つか、または型<a href="../base/base.html#Core.Nothing"><code>Nothing</code></a>である可能性があります。したがって、以下のすべての呼び出しは一致する必要があります：</p><pre><code class="language-julia hljs">f(1, 1)
f(&quot;&quot;, &quot;&quot;)
f(2.0, 2.0)
f(nothing, 1)
f(nothing, &quot;&quot;)
f(nothing, 2.0)</code></pre><p>これらの例は私たちに何かを伝えています：<code>x</code>が<code>nothing::Nothing</code>であるとき、<code>y</code>に対する追加の制約はありません。まるでメソッドシグネチャに<code>y::Any</code>があるかのようです。実際、次の型の同値性があります：</p><pre><code class="language-julia hljs">(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}</code></pre><p>一般的なルールは、共変位置にある具体的な変数は、サブタイピングアルゴリズムがそれを一度だけ<em>使用</em>する場合、具体的でないかのように振る舞うということです。<code>x</code>が<code>Nothing</code>型を持つとき、<code>Union{Nothing,T}</code>の中で<code>T</code>を使用する必要はありません; それは2番目のスロットでのみ使用されます。これは、<code>Tuple{T} where T</code>において、<code>T</code>を具体的な型に制限しても違いがないという観察から自然に生じます; どちらの場合も型は<code>Tuple{Any}</code>に等しいです。</p><p>しかし、<em>不変</em>な位置に現れることは、変数が具体的であることを無効にします。その変数の出現が使用されるかどうかにかかわらずです。そうでなければ、型は比較される他の型によって異なる動作をする可能性があり、サブタイプ関係が推移的でなくなります。例えば、次のように考えてみてください。</p><pre><code class="language-julia hljs">Tuple{Int,Int8,Vector{Integer}} &lt;: Tuple{T,T,Vector{Union{Integer,T}}} where T</code></pre><p><code>Union</code>の中の<code>T</code>が無視されると、<code>T</code>は具体的であり、最初の2つの型が同じではないため、答えは「偽」となります。しかし、代わりに考えてみてください。</p><pre><code class="language-julia hljs">Tuple{Int,Int8,Vector{Any}} &lt;: Tuple{T,T,Vector{Union{Integer,T}}} where T</code></pre><p>今、私たちは <code>Union</code> の中の <code>T</code> を無視することはできません（<code>T == Any</code> でなければなりません）、したがって <code>T</code> は具体的ではなく、答えは「真」です。これは <code>T</code> の具体性が他の型に依存することを意味し、型は自分自身で明確な意味を持たなければならないため、受け入れられません。したがって、<code>Vector</code> 内の <code>T</code> の出現は両方のケースで考慮されます。</p><h2 id="Subtyping-diagonal-variables"><a class="docs-heading-anchor" href="#Subtyping-diagonal-variables">Subtyping diagonal variables</a><a id="Subtyping-diagonal-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Subtyping-diagonal-variables" title="Permalink"></a></h2><p>対角変数のサブタイピングアルゴリズムには2つの要素があります：(1) 変数の出現を特定すること、(2) 対角変数が具体的な型のみに範囲を持つことを保証することです。</p><p>最初のタスクは、環境内の各変数に対して不変出現数 <code>occurs_inv</code> と共変出現数 <code>occurs_cov</code>（<code>src/subtype.c</code>内）を保持することで達成されます。それぞれの出現数を追跡します。変数が対角であるのは、<code>occurs_inv == 0 &amp;&amp; occurs_cov &gt; 1</code> のときです。</p><p>第二のタスクは、変数の下限に条件を課すことによって達成されます。サブタイピングアルゴリズムが実行されると、各変数の範囲を狭め（下限を上げ、上限を下げ）、サブタイプ関係が成り立つ変数値の範囲を追跡します。<code>UnionAll</code>型の体を評価し終えたとき、変数が対角線上にある場合、境界の最終値を見ます。変数は具体的でなければならないため、その下限が具体的な型のサブタイプでない場合、矛盾が発生します。例えば、<a href="../base/arrays.html#Core.AbstractArray"><code>AbstractArray</code></a>のような抽象型は具体的な型のサブタイプにはなれませんが、<code>Int</code>のような具体的な型はサブタイプになれますし、空の型<code>Bottom</code>もそうです。下限がこのテストに失敗した場合、アルゴリズムは<code>false</code>という答えで停止します。</p><p>例えば、問題 <code>Tuple{Int,String} &lt;: Tuple{T,T} where T</code> において、<code>T</code> が <code>Union{Int,String}</code> の上位型であればこれは真であると導きます。しかし、<code>Union{Int,String}</code> は抽象型であるため、この関係は成り立ちません。</p><p>この具体性テストは、関数 <code>is_leaf_bound</code> によって行われます。このテストは <code>jl_is_leaf_type</code> とは少し異なり、<code>Bottom</code> に対しても <code>true</code> を返します。現在、この関数はヒューリスティックであり、すべての可能な具体的型を捕捉するわけではありません。下限が具体的であるかどうかは、他の型変数の下限の値に依存する場合があります。たとえば、<code>Vector{T}</code> は、<code>T</code> の上限と下限が両方とも <code>Int</code> の場合にのみ、具体的な型 <code>Vector{Int}</code> と同等です。私たちはまだこれに対する完全なアルゴリズムを考案していません。</p><h2 id="Introduction-to-the-internal-machinery"><a class="docs-heading-anchor" href="#Introduction-to-the-internal-machinery">Introduction to the internal machinery</a><a id="Introduction-to-the-internal-machinery-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-the-internal-machinery" title="Permalink"></a></h2><p>タイプを扱うためのほとんどの操作は、<code>jltypes.c</code> と <code>subtype.c</code> のファイルにあります。始める良い方法は、サブタイピングの実行を観察することです。<code>make debug</code> で Julia をビルドし、デバッガ内で Julia を起動します。<a href="debuggingtips.html#gdb-debugging-tips">gdb debugging tips</a> には役立つかもしれないいくつかのヒントがあります。</p><p>REPL自体でサブタイピングコードが頻繁に使用されるため、このコードのブレークポイントがしばしばトリガーされます。そのため、次の定義を行うのが最も簡単です：</p><pre><code class="language-julia-repl hljs">julia&gt; function mysubtype(a,b)
           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)
           a &lt;: b
       end</code></pre><p>そして、<code>jl_breakpoint</code>にブレークポイントを設定します。このブレークポイントがトリガーされると、他の関数にブレークポイントを設定できます。</p><p>ウォームアップとして、次のことを試してみてください：</p><pre><code class="language-julia hljs">mysubtype(Tuple{Int, Float64}, Tuple{Integer, Real})</code></pre><p>より複雑なケースに挑戦することで、もっと面白くすることができます:</p><pre><code class="language-julia hljs">mysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)</code></pre><h2 id="Subtyping-and-method-sorting"><a class="docs-heading-anchor" href="#Subtyping-and-method-sorting">Subtyping and method sorting</a><a id="Subtyping-and-method-sorting-1"></a><a class="docs-heading-anchor-permalink" href="#Subtyping-and-method-sorting" title="Permalink"></a></h2><p><code>type_morespecific</code> 関数は、メソッドテーブル内の関数に部分順序を課すために使用されます（最も特定的なものから最も一般的なものへ）。特異性は厳密です；もし <code>a</code> が <code>b</code> よりも特定的であれば、<code>a</code> は <code>b</code> と等しくなく、<code>b</code> は <code>a</code> よりも特定的ではありません。</p><p>もし <code>a</code> が <code>b</code> の厳密なサブタイプであれば、自動的により具体的であると見なされます。そこから、<code>type_morespecific</code> はいくつかのあまり形式的でないルールを適用します。例えば、<code>subtype</code> は引数の数に敏感ですが、<code>type_morespecific</code> はそうではないかもしれません。特に、<code>Tuple{Int,AbstractFloat}</code> は <code>Tuple{Integer}</code> よりも具体的ですが、サブタイプではありません。 (<code>Tuple{Int,AbstractFloat}</code> と <code>Tuple{Integer,Float64}</code> のどちらも、互いにより具体的ではありません。) 同様に、<code>Tuple{Int,Vararg{Int}}</code> は <code>Tuple{Integer}</code> のサブタイプではありませんが、より具体的であると見なされます。しかし、<code>morespecific</code> は長さに対してボーナスを得ます：特に、<code>Tuple{Int,Int}</code> は <code>Tuple{Int,Vararg{Int}}</code> よりも具体的です。</p><p>メソッドがどのようにソートされるかをデバッグしている場合、関数を定義することが便利です：</p><pre><code class="language-julia hljs">type_morespecific(a, b) = ccall(:jl_type_morespecific, Cint, (Any,Any), a, b)</code></pre><p>タプル型 <code>a</code> がタプル型 <code>b</code> よりも特化しているかどうかをテストすることを可能にします。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ast.html">« Julia ASTs</a><a class="docs-footer-nextpage" href="object.html">Memory layout of Julia Objects »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 31 May 2025 00:57">Saturday 31 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
