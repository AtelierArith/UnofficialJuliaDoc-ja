<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EscapeAnalysis · The Julia Language</title><meta name="title" content="EscapeAnalysis · The Julia Language"/><meta property="og:title" content="EscapeAnalysis · The Julia Language"/><meta property="twitter:title" content="EscapeAnalysis · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox" checked/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="ast.html">Julia ASTs</a></li><li><a class="tocitem" href="types.html">More about types</a></li><li><a class="tocitem" href="object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="functions.html">Julia Functions</a></li><li><a class="tocitem" href="cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="subarrays.html">SubArrays</a></li><li><a class="tocitem" href="isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="sysimg.html">System Image Building</a></li><li><a class="tocitem" href="pkgimg.html">Package Images</a></li><li><a class="tocitem" href="llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="require.html">Module loading</a></li><li><a class="tocitem" href="inference.html">Inference</a></li><li><a class="tocitem" href="ssair.html">Julia SSA-form IR</a></li><li class="is-active"><a class="tocitem" href="EscapeAnalysis.html"><code>EscapeAnalysis</code></a><ul class="internal"><li><a class="tocitem" href="#Try-it-out!"><span>Try it out!</span></a></li><li><a class="tocitem" href="#Analysis-Design"><span>Analysis Design</span></a></li><li><a class="tocitem" href="#Analysis-Usage"><span>Analysis Usage</span></a></li></ul></li><li><a class="tocitem" href="aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="build/linux.html">Linux</a></li><li><a class="tocitem" href="build/macos.html">macOS</a></li><li><a class="tocitem" href="build/windows.html">Windows</a></li><li><a class="tocitem" href="build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href="EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="EscapeAnalysis"><a class="docs-heading-anchor" href="#EscapeAnalysis"><code>EscapeAnalysis</code></a><a id="EscapeAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#EscapeAnalysis" title="Permalink"></a></h1><p><code>Core.Compiler.EscapeAnalysis</code> は、<a href="ssair.html#Julia-SSA-form-IR">Julia&#39;s SSA-form IR</a>、すなわち <code>IRCode</code> のエスケープ情報を分析することを目的としたコンパイラユーティリティモジュールです。</p><p>このエスケープ分析の目的は：</p><ul><li>Juliaの高レベルのセマンティクスを活用し、特に手続き間呼び出しを通じてエスケープとエイリアシングについて考察します。</li><li>さまざまな最適化に使用できるように柔軟である必要があります。これには、<a href="https://github.com/JuliaLang/julia/pull/43888">alias-aware SROA</a>、<a href="https://github.com/JuliaLang/julia/pull/44056">early <code>finalize</code> insertion</a>、<a href="https://github.com/JuliaLang/julia/pull/42465">copy-free <code>ImmutableArray</code> construction</a>、可変オブジェクトのスタック割り当てなどが含まれます。</li><li>単純な実装を達成するために、完全な逆データフロー分析の実装と、直交格子特性を組み合わせた新しい格子設計を基にします。</li></ul><h2 id="Try-it-out!"><a class="docs-heading-anchor" href="#Try-it-out!">Try it out!</a><a id="Try-it-out!-1"></a><a class="docs-heading-anchor-permalink" href="#Try-it-out!" title="Permalink"></a></h2><p><code>EAUtils.jl</code>ユーティリティスクリプトをロードすることで、エスケープ分析を試すことができます。このスクリプトは、テストおよびデバッグ目的のために便利なエントリ<code>code_escapes</code>と<code>@code_escapes</code>を定義しています。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; let JULIA_DIR = normpath(Sys.BINDIR, &quot;..&quot;, &quot;share&quot;, &quot;julia&quot;)
           # load `EscapeAnalysis` module to define the core analysis code
           include(normpath(JULIA_DIR, &quot;base&quot;, &quot;compiler&quot;, &quot;ssair&quot;, &quot;EscapeAnalysis&quot;, &quot;EscapeAnalysis.jl&quot;))
           using .EscapeAnalysis
           # load `EAUtils` module to define the utilities
           include(normpath(JULIA_DIR, &quot;test&quot;, &quot;compiler&quot;, &quot;EscapeAnalysis&quot;, &quot;EAUtils.jl&quot;))
           using .EAUtils
       end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mutable struct SafeRef{T}
           x::T
       end</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.getindex(x::SafeRef) = x.x;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.setindex!(x::SafeRef, v) = x.x = v;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.isassigned(x::SafeRef) = true;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get′(x) = isassigned(x) ? x[] : throw(x);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; result = code_escapes((String,String,String,String)) do s1, s2, s3, s4
           r1 = Ref(s1)
           r2 = Ref(s2)
           r3 = SafeRef(s3)
           try
               s1 = get′(r1)
               ret = sizeof(s1)
           catch err
               global GV = err # will definitely escape `r1`
           end
           s2 = get′(r2)       # still `r2` doesn&#39;t escape fully
           s3 = get′(r3)       # still `r3` doesn&#39;t escape fully
           s4 = sizeof(s4)     # the argument `s4` doesn&#39;t escape here
           return s2, s3, s4
       end</code><code class="nohighlight hljs ansi" style="display:block;">#1(<span class="sgr31">X s1::String</span>, <span class="sgr33">↑ s2::String</span>, <span class="sgr34">↑ s3::String</span>, <span class="sgr36">✓ s4::String</span>)<span class="sgr1"> in Main at REPL[7]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ──</span> %1  = %new(Base.RefValue{String}, _2)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr33">*′ </span><span class="sgr90">│   </span> %2  = %new(Base.RefValue{String}, _3)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr32">✓′ </span><span class="sgr90">└───</span> %3  = %new(Main.SafeRef{String}, _4)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr32">✓′ </span><span class="sgr90">2 ──</span> %4  = ϒ (%3)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr33">*′ </span><span class="sgr90">│   </span> %5  = ϒ (%2)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr36">✓  </span><span class="sgr90">│   </span> %6  = ϒ (_5)<span class="sgr36">::String</span>
◌  <span class="sgr90">└───</span> %7  = enter #8
◌  <span class="sgr90">3 ──</span> %8  = Base.isdefined(%1, :x)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #5 if not %8
<span class="sgr31">X  </span><span class="sgr90">4 ──</span>       Base.getfield(%1, :x)<span class="sgr90">::String</span>
◌  <span class="sgr90">└───</span>       goto #6
◌  <span class="sgr90">5 ──</span>       Main.throw(%1)<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
◌  <span class="sgr90">6 ──</span>       $(Expr(:leave, :(%7)))
◌  <span class="sgr90">7 ──</span>       goto #11
<span class="sgr32">✓′ </span><span class="sgr90">8 ┄─</span> %16 = φᶜ (%4)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr33">*′ </span><span class="sgr90">│   </span> %17 = φᶜ (%5)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr36">✓  </span><span class="sgr90">│   </span> %18 = φᶜ (%6)<span class="sgr36">::String</span>
<span class="sgr31">X  </span><span class="sgr90">└───</span> %19 = $(Expr(:the_exception))<span class="sgr36">::Any</span>
◌  <span class="sgr90">9 ──</span>       nothing<span class="sgr90">::Nothing</span>
◌  <span class="sgr90">10 ─</span>       (Main.GV = %19)<span class="sgr90">::Any</span>
◌  <span class="sgr90">└───</span>       $(Expr(:pop_exception, :(%7)))<span class="sgr90">::Core.Const(nothing)</span>
<span class="sgr32">✓′ </span><span class="sgr90">11 ┄</span> %23 = φ (#7 =&gt; %3, #10 =&gt; %16)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr33">*′ </span><span class="sgr90">│   </span> %24 = φ (#7 =&gt; %2, #10 =&gt; %17)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr36">✓  </span><span class="sgr90">│   </span> %25 = φ (#7 =&gt; _5, #10 =&gt; %18)<span class="sgr36">::String</span>
◌  <span class="sgr90">│   </span> %26 = Base.isdefined(%24, :x)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #13 if not %26
<span class="sgr33">↑  </span><span class="sgr90">12 ─</span> %28 = Base.getfield(%24, :x)<span class="sgr36">::String</span>
◌  <span class="sgr90">└───</span>       goto #14
◌  <span class="sgr90">13 ─</span>       Main.throw(%24)<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr34">↑  </span><span class="sgr90">14 ─</span> %32 = Base.getfield(%23, :x)<span class="sgr36">::String</span>
◌  <span class="sgr90">│   </span> %33 = Core.sizeof(%25)<span class="sgr36">::Int64</span>
<span class="sgr34">↑′ </span><span class="sgr90">│   </span> %34 = Core.tuple(%28, %32, %33)<span class="sgr36">::Tuple{String, String, Int64}</span>
◌  <span class="sgr90">└───</span>       return %34</code></pre><p>各呼び出し引数およびSSAステートメントの横にある記号は、以下の意味を表します：</p><ul><li><code>◌</code> (plain): この値は分析されません。なぜなら、オブジェクトが <code>isbitstype</code> の場合など、エスケープ情報は結局使用されないからです。</li><li><code>✓</code> (緑またはシアン): この値は決してエスケープしません（<code>has_no_escape(result.state[x])</code> が成立します）、引数エスケープもある場合は青色になります（<code>has_arg_escape(result.state[x])</code> が成立します）</li><li><code>↑</code> (青または黄): この値は呼び出し元に戻ることでエスケープすることができます（<code>has_return_escape(result.state[x])</code> が成立する場合）、未処理のスローエスケープがある場合は黄色に色付けされます（<code>has_thrown_escape(result.state[x])</code> が成立する場合）。</li><li><code>X</code> (赤): この値は、グローバルメモリへのエスケープのように、エスケープ分析が推論できない場所にエスケープする可能性があります（<code>has_all_escape(result.state[x])</code> が成り立ちます）。</li><li><code>*</code> (太字): この値のエスケープ状態は、<code>ReturnEscape</code> と <code>AllEscape</code> の間にあり、部分順序の中で <a href="EscapeAnalysis.html#Core.Compiler.EscapeAnalysis.EscapeInfo"><code>EscapeInfo</code></a> にあります。未処理のスローエスケープがある場合は黄色で表示されます（<code>has_thrown_escape(result.state[x])</code> が真である場合）。</li><li><code>′</code>: この値は、その <code>AliasInfo</code> プロパティに追加のオブジェクトフィールド / 配列要素情報を持っています。</li></ul><p>各呼び出し引数およびSSA値のエスケープ情報は、次のようにプログラム的に検査できます:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.state[Core.Argument(3)] # get EscapeInfo of `s2`</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr33">ReturnEscape</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; result.state[Core.SSAValue(3)] # get EscapeInfo of `r3`</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32">NoEscape′</span></code></pre><h2 id="Analysis-Design"><a class="docs-heading-anchor" href="#Analysis-Design">Analysis Design</a><a id="Analysis-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-Design" title="Permalink"></a></h2><h3 id="Lattice-Design"><a class="docs-heading-anchor" href="#Lattice-Design">Lattice Design</a><a id="Lattice-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-Design" title="Permalink"></a></h3><p><code>EscapeAnalysis</code>は、<a href="https://en.wikipedia.org/wiki/Data-flow_analysis">data-flow analysis</a>として実装されており、<a href="EscapeAnalysis.html#Core.Compiler.EscapeAnalysis.EscapeInfo"><code>x::EscapeInfo</code></a>の格子で動作します。これは以下のプロパティで構成されています：</p><ul><li><code>x.Analyzed::Bool</code>: 格子の正式な一部ではなく、単に <code>x</code> が分析されていないか、またはそうでないことを示します。</li><li><code>x.ReturnEscape::BitSet</code>: 呼び出し元に戻ることで <code>x</code> がエスケープできるSSAステートメントを記録します。</li><li><code>x.ThrownEscape::BitSet</code>: 例外として投げられる可能性のあるSSAステートメントを記録します（以下に説明する<a href="EscapeAnalysis.html#EA-Exception-Handling">exception handling</a>で使用されます）</li><li><code>x.AliasInfo</code>: <code>x</code>のフィールドや配列要素にエイリアスできるすべての可能な値を保持します（以下に説明する<a href="EscapeAnalysis.html#EA-Alias-Analysis">alias analysis</a>で使用されます）</li><li><code>x.ArgEscape::Int</code>（未実装）：引数を介して<code>setfield!</code>で呼び出し元にエスケープすることを示します。</li></ul><p>これらの属性は、入力プログラムが有限の文の数を持つという不変条件の下で、有限の高さを持つ部分格子を作成するために組み合わせることができます。これはJuliaのセマンティクスによって保証されています。この格子設計の巧妙な部分は、各格子プロパティを個別に処理できるようにすることで、格子操作の実装を簡素化できる点です<sup class="footnote-reference"><a id="citeref-LatticeDesign" href="#footnote-LatticeDesign">[LatticeDesign]</a></sup>。</p><h3 id="Backward-Escape-Propagation"><a class="docs-heading-anchor" href="#Backward-Escape-Propagation">Backward Escape Propagation</a><a id="Backward-Escape-Propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Backward-Escape-Propagation" title="Permalink"></a></h3><p>このエスケープ分析の実装は、論文<sup class="footnote-reference"><a id="citeref-MM02" href="#footnote-MM02">[MM02]</a></sup>で説明されているデータフローアルゴリズムに基づいています。この分析は<code>EscapeInfo</code>のラティス上で動作し、すべてのラティス要素が収束点に到達するまで、ラティス要素を下から上へと遷移させます。これは、分析対象の残りのSSAステートメントに対応するプログラムカウンタを含む（概念的な）作業セットを維持することによって行われます。この分析は、各引数とSSAステートメントの<code>EscapeInfo</code>を追跡する単一のグローバル状態を管理しますが、<code>EscapeInfo</code>の<code>ReturnEscape</code>プロパティに記録されたプログラムカウンタとしてエンコードされた一部のフロー感度にも注意が必要です。これは、必要に応じて支配分析と組み合わせてフロー感度について推論するために使用できます。</p><p>このエスケープ分析の特徴的な設計は、それが完全に<em>逆方向</em>であること、すなわちエスケープ情報が<em>使用から定義へ</em>流れることです。例えば、以下のコードスニペットでは、EAは最初にステートメント<code>return %1</code>を分析し、<code>%1</code>（<code>obj</code>に対応）に<code>ReturnEscape</code>を課します。そして、次に<code>%1 = %new(Base.RefValue{String, _2}))</code>を分析し、<code>%1</code>に課された<code>ReturnEscape</code>を呼び出し引数<code>_2</code>（<code>s</code>に対応）に伝播させます。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((String,)) do s
           obj = Ref(s)
           return obj
       end</code><code class="nohighlight hljs ansi" style="display:block;">#3(<span class="sgr34">↑ s::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
<span class="sgr34">↑′ </span><span class="sgr90">1 ─</span> %1 = %new(Base.RefValue{String}, _2)<span class="sgr36">::Base.RefValue{String}</span>
◌  <span class="sgr90">└──</span>      return %1</code></pre><p>ここでの重要な観察は、この逆向きの分析が使用-定義チェーンに沿って自然にエスケープ情報を流すことを可能にするということです<sup class="footnote-reference"><a id="citeref-BackandForth" href="#footnote-BackandForth">[BackandForth]</a></sup>。その結果、このスキームはエスケープ分析のシンプルな実装を可能にします。例えば、<code>PhiNode</code>は、<code>PhiNode</code>に課せられたエスケープ情報をその前駆値に伝播させることで簡単に処理できます。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((Bool, String, String)) do cnd, s, t
           if cnd
               obj = Ref(s)
           else
               obj = Ref(t)
           end
           return obj
       end</code><code class="nohighlight hljs ansi" style="display:block;">#5(<span class="sgr36">✓ cnd::Bool</span>, <span class="sgr34">↑ s::String</span>, <span class="sgr34">↑ t::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
◌  <span class="sgr90">1 ─</span>      goto #3 if not _2
<span class="sgr34">↑′ </span><span class="sgr90">2 ─</span> %2 = %new(Base.RefValue{String}, _3)<span class="sgr36">::Base.RefValue{String}</span>
◌  <span class="sgr90">└──</span>      goto #4
<span class="sgr34">↑′ </span><span class="sgr90">3 ─</span> %4 = %new(Base.RefValue{String}, _4)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr34">↑′ </span><span class="sgr90">4 ┄</span> %5 = φ (#2 =&gt; %2, #3 =&gt; %4)<span class="sgr36">::Base.RefValue{String}</span>
◌  <span class="sgr90">└──</span>      return %5</code></pre><h3 id="EA-Alias-Analysis"><a class="docs-heading-anchor" href="#EA-Alias-Analysis">Alias Analysis</a><a id="EA-Alias-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#EA-Alias-Analysis" title="Permalink"></a></h3><p><code>EscapeAnalysis</code>は、特定の精度でオブジェクトフィールドに課せられたエスケープについて推論するために、逆向きフィールド分析を実装しています。また、<code>x::EscapeInfo</code>の<code>x.AliasInfo</code>プロパティはこの目的のために存在します。これは、「使用」サイトで<code>x</code>のフィールドにエイリアスされる可能性のあるすべての値を記録し、その後、記録された値のエスケープ情報が「定義」サイトで実際のフィールド値に伝播されます。より具体的には、分析は<code>getfield</code>呼び出しを分析することによってオブジェクトのフィールドにエイリアスされる可能性のある値を記録し、その後、<code>%new(...)</code>式または<code>setfield!</code>呼び出しを分析する際にそのエスケープ情報をフィールドに伝播させます<sup class="footnote-reference"><a id="citeref-Dynamism" href="#footnote-Dynamism">[Dynamism]</a></sup>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((String,)) do s
           obj = SafeRef(&quot;init&quot;)
           obj[] = s
           v = obj[]
           return v
       end</code><code class="nohighlight hljs ansi" style="display:block;">#7(<span class="sgr34">↑ s::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
◌  <span class="sgr90">1 ─</span>     return _2</code></pre><p>上記の例では、<code>ReturnEscape</code>が<code>%3</code>（<code>v</code>に対応）に課せられていますが、これは直接<code>%1</code>（<code>obj</code>に対応）に伝播されるのではなく、<code>ReturnEscape</code>は<code>_2</code>（<code>s</code>に対応）にのみ伝播されます。ここで、<code>%3</code>は<code>%1</code>の<code>AliasInfo</code>プロパティに記録され、<code>%1</code>の最初のフィールドにエイリアスされる可能性があるため、次に<code>Base.setfield!(%1, :x, _2)::String</code>を分析する際に、そのエスケープ情報は<code>_2</code>に伝播されますが、<code>%1</code>には伝播されません。</p><p><code>EscapeAnalysis</code>は、オブジェクトフィールドのエスケープを分析するために、<code>getfield</code>-<code>%new</code>/<code>setfield!</code>チェーンを横断することができるIR要素を追跡しますが、実際にはこのエイリアス分析は他のIR要素も処理できるように一般化する必要があります。これは、JuliaのIRでは同じオブジェクトが異なるIR要素によって表現されることがあるためであり、実際に同じオブジェクトを表すことができる異なるIR要素が同じエスケープ情報を共有することを確認する必要があります。オペランドとして同じオブジェクトを返すIR要素、例えば<code>PiNode</code>や<code>typeassert</code>は、IRレベルのエイリアシングを引き起こす可能性があり、そのため、エイリアスされた値のいずれかに課せられたエスケープ情報をそれらの間で共有する必要があります。さらに興味深いことに、<code>PhiNode</code>の変異について正しく推論するためにも必要です。次の例を考えてみましょう：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((Bool, String,)) do cond, x
           if cond
               ϕ2 = ϕ1 = SafeRef(&quot;foo&quot;)
           else
               ϕ2 = ϕ1 = SafeRef(&quot;bar&quot;)
           end
           ϕ2[] = x
           y = ϕ1[]
           return y
       end</code><code class="nohighlight hljs ansi" style="display:block;">#9(<span class="sgr36">✓ cond::Bool</span>, <span class="sgr34">↑ x::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
◌  <span class="sgr90">1 ─</span>      goto #3 if not _2
<span class="sgr32">✓′ </span><span class="sgr90">2 ─</span> %2 = %new(Main.SafeRef{String}, &quot;foo&quot;)<span class="sgr36">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└──</span>      goto #4
<span class="sgr32">✓′ </span><span class="sgr90">3 ─</span> %4 = %new(Main.SafeRef{String}, &quot;bar&quot;)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr32">✓′ </span><span class="sgr90">4 ┄</span> %5 = φ (#2 =&gt; %2, #3 =&gt; %4)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr32">✓′ </span><span class="sgr90">│  </span> %6 = φ (#2 =&gt; %2, #3 =&gt; %4)<span class="sgr36">::Main.SafeRef{String}</span>
◌  <span class="sgr90">│  </span>      Base.setfield!(%5, :x, _3)<span class="sgr90">::String</span>
<span class="sgr34">↑  </span><span class="sgr90">│  </span> %8 = Base.getfield(%6, :x)<span class="sgr36">::String</span>
◌  <span class="sgr90">└──</span>      return %8</code></pre><p><code>ϕ1 = %5</code> と <code>ϕ2 = %6</code> はエイリアスされているため、<code>ReturnEscape</code> が <code>%8 = Base.getfield(%6, :x)::String</code>（<code>y = ϕ1[]</code> に対応）に課せられ、これを <code>Base.setfield!(%5, :x, _3)::String</code>（<code>ϕ2[] = x</code> に対応）に伝播させる必要があります。このようなエスケープ情報が正しく伝播されるためには、分析が <code>ϕ1</code> と <code>ϕ2</code> の <em>前駆体</em> もエイリアスされる可能性があることを認識し、それらのエスケープ情報を等しくする必要があります。</p><p>そのようなエイリアス情報の興味深い特性の一つは、それが「使用」サイトでは知られておらず、「定義」サイトでのみ導出できるということです（エイリアスは概念的に代入と同等であるため）、したがって、自然に逆方向の分析には適合しません。関連する値間でエスケープ情報を効率的に伝播させるために、EscapeAnalysis.jlは古いJVM論文<sup class="footnote-reference"><a id="citeref-JVM05" href="#footnote-JVM05">[JVM05]</a></sup>で説明されているエスケープ分析アルゴリズムに触発されたアプローチを使用しています。つまり、エスケープラティス要素を管理することに加えて、分析は「等価」エイリアスセットも維持します。これは、エイリアスされた引数とSSAステートメントの互いに排他的なセットです。エイリアスセットは、お互いにエイリアスされる可能性のある値を管理し、これらのエイリアスされた値のいずれかに課せられたエスケープ情報をそれらの間で等しくすることを可能にします。</p><h3 id="EA-Array-Analysis"><a class="docs-heading-anchor" href="#EA-Array-Analysis">Array Analysis</a><a id="EA-Array-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#EA-Array-Analysis" title="Permalink"></a></h3><p>上記で説明したオブジェクトフィールドのエイリアス分析は、配列操作を分析するためにも一般化できます。<code>EscapeAnalysis</code>は、さまざまなプリミティブ配列操作の処理を実装しており、<code>arrayref</code>-<code>arrayset</code>の使用-定義チェーンを介してエスケープを伝播させ、割り当てられた配列が過度にエスケープしないようにします。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((String,)) do s
           ary = Any[]
           push!(ary, SafeRef(s))
           return ary[1], length(ary)
       end</code><code class="nohighlight hljs ansi" style="display:block;">#11(<span class="sgr31">X s::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ──</span> %1  = Core.getproperty(Memory{Any}, :instance)<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %2  = invoke Core.memoryref(%1::Memory{Any})<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %3  = %new(Vector{Any}, %2, (0,))<span class="sgr36">::Vector{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %4  = %new(Main.SafeRef{String}, _2)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %5  = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %6  = Base.getfield(%5, :mem)<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %7  = Base.getfield(%6, :length)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %8  = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %9  = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %10 = Base.getfield(%8, 1, %9)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %11 = Base.add_int(%10, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %12 = Base.memoryrefoffset(%5)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %13 = Core.tuple(%11)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span>       Base.setfield!(%3, :size, %13)<span class="sgr90">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %15 = Base.add_int(%12, %11)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %16 = Base.sub_int(%15, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %17 = Base.slt_int(%7, %16)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #3 if not %17
<span class="sgr31">X  </span><span class="sgr90">2 ──</span> %19 = %new(Base.var&quot;#133#134&quot;{Vector{Any}, Int64, Int64, Int64, Int64, Int64, Memory{Any}, MemoryRef{Any}}, %3, %16, %12, %11, %10, %7, %6, %5)<span class="sgr36">::Base.var&quot;#133#134&quot;{Vector{Any}, Int64, Int64, Int64, Int64, Int64, Memory{Any}, MemoryRef{Any}}</span>
<span class="sgr32">✓  </span><span class="sgr90">└───</span>       invoke %19()<span class="sgr90">::MemoryRef{Any}</span>
◌  <span class="sgr90">3 ┄─</span>       goto #4
<span class="sgr31">X  </span><span class="sgr90">4 ──</span> %22 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %23 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %24 = Base.getfield(%22, 1, %23)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %25 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %26 = Base.memoryrefnew(%25, %24, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%26, %4, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #5
◌  <span class="sgr90">5 ──</span> %29 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #9 if not %29
◌  <span class="sgr90">6 ──</span> %31 = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %32 = Base.bitcast(Base.UInt, %31)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %33 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %34 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %35 = Base.getfield(%33, 1, %34)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %36 = Base.bitcast(Base.UInt, %35)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %37 = Base.ult_int(%32, %36)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #8 if not %37
◌  <span class="sgr90">7 ──</span>       goto #9
◌  <span class="sgr90">8 ──</span> %40 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %40::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">9 ┄─</span> %43 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %44 = Base.memoryrefnew(%43, 1, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %45 = Base.memoryrefget(%44, :not_atomic, false)<span class="sgr36">::Any</span>
◌  <span class="sgr90">└───</span>       goto #10
<span class="sgr31">X  </span><span class="sgr90">10 ─</span> %47 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %48 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %49 = Base.getfield(%47, 1, %48)<span class="sgr36">::Int64</span>
<span class="sgr34">↑′ </span><span class="sgr90">│   </span> %50 = Core.tuple(%45, %49)<span class="sgr36">::Tuple{Any, Int64}</span>
◌  <span class="sgr90">└───</span>       return %50</code></pre><p>上記の例では、<code>EscapeAnalysis</code>は<code>%20</code>と<code>%2</code>（割り当てられたオブジェクト<code>SafeRef(s)</code>に対応）が<code>arrayset</code>-<code>arrayref</code>チェーンを介してエイリアスされていることを理解し、これらに<code>ReturnEscape</code>を課しますが、割り当てられた配列<code>%1</code>（<code>ary</code>に対応）にはそれを課しません。<code>EscapeAnalysis</code>は、<code>BoundsError</code>を介した潜在的なエスケープを考慮する必要があるため、<code>ary</code>に対して<code>ThrownEscape</code>を課しますが、このような未処理の<code>ThrownEscape</code>は、<code>ary</code>の割り当てを最適化する際に無視されることがよくあります。</p><p>さらに、配列インデックス情報と配列の次元が<em>正確に</em>わかる場合、<code>EscapeAnalysis</code>は<code>arrayref</code>-<code>arrayset</code>チェーンを介して「要素ごとの」エイリアスについても推論することができます。これは、<code>EscapeAnalysis</code>がオブジェクトに対して「フィールドごとの」エイリアス分析を行うためです。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((String,String)) do s, t
           ary = Vector{Any}(undef, 2)
           ary[1] = SafeRef(s)
           ary[2] = SafeRef(t)
           return ary[1], length(ary)
       end</code><code class="nohighlight hljs ansi" style="display:block;">#13(<span class="sgr31">X s::String</span>, <span class="sgr31">X t::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ──</span> %1  = $(Expr(:foreigncall, :(:jl_alloc_genericmemory), Ref{Memory{Any}}, svec(Any, Int64), 0, :(:ccall), Memory{Any}, 2, 2))<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %2  = Core.memoryrefnew(%1)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %3  = %new(Vector{Any}, %2, (2,))<span class="sgr36">::Vector{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %4  = %new(Main.SafeRef{String}, _2)<span class="sgr36">::Main.SafeRef{String}</span>
◌  <span class="sgr90">│   </span> %5  = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #5 if not %5
◌  <span class="sgr90">2 ──</span> %7  = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %8  = Base.bitcast(Base.UInt, %7)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %9  = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %10 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %11 = Base.getfield(%9, 1, %10)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %12 = Base.bitcast(Base.UInt, %11)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %13 = Base.ult_int(%8, %12)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #4 if not %13
◌  <span class="sgr90">3 ──</span>       goto #5
◌  <span class="sgr90">4 ──</span> %16 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %16::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">5 ┄─</span> %19 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %20 = Base.memoryrefnew(%19, 1, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%20, %4, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #6
<span class="sgr31">X  </span><span class="sgr90">6 ──</span> %23 = %new(Main.SafeRef{String}, _3)<span class="sgr36">::Main.SafeRef{String}</span>
◌  <span class="sgr90">│   </span> %24 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #10 if not %24
◌  <span class="sgr90">7 ──</span> %26 = Base.sub_int(2, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %27 = Base.bitcast(Base.UInt, %26)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %28 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %29 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %30 = Base.getfield(%28, 1, %29)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %31 = Base.bitcast(Base.UInt, %30)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %32 = Base.ult_int(%27, %31)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #9 if not %32
◌  <span class="sgr90">8 ──</span>       goto #10
◌  <span class="sgr90">9 ──</span> %35 = Core.tuple(2)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %35::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">10 ┄</span> %38 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %39 = Base.memoryrefnew(%38, 2, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%39, %23, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #11
◌  <span class="sgr90">11 ─</span> %42 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #15 if not %42
◌  <span class="sgr90">12 ─</span> %44 = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %45 = Base.bitcast(Base.UInt, %44)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %46 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %47 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %48 = Base.getfield(%46, 1, %47)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %49 = Base.bitcast(Base.UInt, %48)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %50 = Base.ult_int(%45, %49)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #14 if not %50
◌  <span class="sgr90">13 ─</span>       goto #15
◌  <span class="sgr90">14 ─</span> %53 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %53::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">15 ┄</span> %56 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %57 = Base.memoryrefnew(%56, 1, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %58 = Base.memoryrefget(%57, :not_atomic, false)<span class="sgr36">::Any</span>
◌  <span class="sgr90">└───</span>       goto #16
<span class="sgr31">X  </span><span class="sgr90">16 ─</span> %60 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %61 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %62 = Base.getfield(%60, 1, %61)<span class="sgr36">::Int64</span>
<span class="sgr34">↑′ </span><span class="sgr90">│   </span> %63 = Core.tuple(%58, %62)<span class="sgr36">::Tuple{Any, Int64}</span>
◌  <span class="sgr90">└───</span>       return %63</code></pre><p><code>ReturnEscape</code>は<code>%2</code>（<code>SafeRef(s)</code>に対応）にのみ課せられますが、<code>%4</code>（<code>SafeRef(t)</code>に対応）には課せられません。これは、割り当てられた配列の次元と、すべての<code>arrayref</code>/<code>arrayset</code>操作に関与するインデックスが定数情報として利用可能であり、<code>EscapeAnalysis</code>が<code>%6</code>が<code>%2</code>にエイリアスされることは理解できるが、<code>%4</code>にエイリアスされることは決してないからです。このような場合、後続の最適化パスは<code>Base.arrayref(true, %1, 1)::Any</code>を<code>%2</code>（いわゆる「ロードフォワーディング」）に置き換えることができ、最終的には配列<code>%1</code>の割り当てを完全に排除することができます（いわゆる「スカラー置換」）。</p><p>オブジェクトフィールド分析と比較すると、オブジェクトフィールドへのアクセスは推論によって得られた型情報を使用して簡単に分析できますが、配列の次元は型情報としてエンコードされていないため、その情報を導き出すために追加の分析が必要です。<code>EscapeAnalysis</code>は、まず割り当てられた配列の次元を分析するために追加の単純な線形スキャンを行い、その後、主要な分析ルーチンを起動して、次のエスケープ分析がそれらの配列に対する操作を正確に分析できるようにします。</p><p>しかし、そのような正確な「要素ごとの」エイリアス解析はしばしば困難です。本質的に、配列に固有の主な難しさは、配列の次元とインデックスがしばしば定数でないことです：</p><ul><li>ループはしばしばループ変数、非定数の配列インデックスを生成します。</li><li>（ベクトルに特有）配列のサイズ変更は配列の次元を変更し、その定数性を無効にします。</li></ul><p>具体的な例を挙げて、その困難について話し合いましょう。</p><p>次の例では、<code>EscapeAnalysis</code>が正確なエイリアス分析に失敗します。なぜなら、<code>Base.arrayset(false, %4, %8, %6)::Vector{Any}</code>のインデックスが（自明に）定数ではないからです。特に、<code>Any[nothing, nothing]</code>はループを形成し、そのループ内で<code>arrayset</code>操作を呼び出します。このとき、<code>%6</code>は制御フローに依存するϕノード値として表されます。その結果、<code>ReturnEscape</code>は<code>%23</code>（<code>SafeRef(s)</code>に対応）と<code>%25</code>（<code>SafeRef(t)</code>に対応）の両方に課せられますが、理想的には<code>%23</code>のみに課せられ、<code>%25</code>には課せられないことを望んでいます。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((String,String)) do s, t
           ary = Any[nothing, nothing]
           ary[1] = SafeRef(s)
           ary[2] = SafeRef(t)
           return ary[1], length(ary)
       end</code><code class="nohighlight hljs ansi" style="display:block;">#15(<span class="sgr31">X s::String</span>, <span class="sgr31">X t::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ──</span> %1  = $(Expr(:foreigncall, :(:jl_alloc_genericmemory), Ref{Memory{Any}}, svec(Any, Int64), 0, :(:ccall), Memory{Any}, 2, 2))<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %2  = Core.memoryrefnew(%1)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">└───</span> %3  = %new(Vector{Any}, %2, (2,))<span class="sgr36">::Vector{Any}</span>
◌  <span class="sgr90">2 ┄─</span> %4  = φ (#1 =&gt; 1, #6 =&gt; %14)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %5  = φ (#1 =&gt; 1, #6 =&gt; %15)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %6  = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %7  = Base.memoryrefnew(%6, %4, false)<span class="sgr36">::MemoryRef{Any}</span>
◌  <span class="sgr90">│   </span>       Base.memoryrefset!(%7, nothing, :not_atomic, false)<span class="sgr90">::Nothing</span>
◌  <span class="sgr90">│   </span> %9  = (%5 === 2)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #4 if not %9
◌  <span class="sgr90">3 ──</span>       goto #5
◌  <span class="sgr90">4 ──</span> %12 = Base.add_int(%5, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">└───</span>       goto #5
◌  <span class="sgr90">5 ┄─</span> %14 = φ (#4 =&gt; %12)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %15 = φ (#4 =&gt; %12)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %16 = φ (#3 =&gt; true, #4 =&gt; false)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">│   </span> %17 = Base.not_int(%16)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #7 if not %17
◌  <span class="sgr90">6 ──</span>       goto #2
◌  <span class="sgr90">7 ──</span>       goto #8
<span class="sgr31">X  </span><span class="sgr90">8 ──</span> %21 = %new(Main.SafeRef{String}, _2)<span class="sgr36">::Main.SafeRef{String}</span>
◌  <span class="sgr90">│   </span> %22 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #12 if not %22
◌  <span class="sgr90">9 ──</span> %24 = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %25 = Base.bitcast(Base.UInt, %24)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %26 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %27 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %28 = Base.getfield(%26, 1, %27)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %29 = Base.bitcast(Base.UInt, %28)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %30 = Base.ult_int(%25, %29)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #11 if not %30
◌  <span class="sgr90">10 ─</span>       goto #12
◌  <span class="sgr90">11 ─</span> %33 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %33::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">12 ┄</span> %36 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %37 = Base.memoryrefnew(%36, 1, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%37, %21, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #13
<span class="sgr31">X  </span><span class="sgr90">13 ─</span> %40 = %new(Main.SafeRef{String}, _3)<span class="sgr36">::Main.SafeRef{String}</span>
◌  <span class="sgr90">│   </span> %41 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #17 if not %41
◌  <span class="sgr90">14 ─</span> %43 = Base.sub_int(2, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %44 = Base.bitcast(Base.UInt, %43)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %45 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %46 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %47 = Base.getfield(%45, 1, %46)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %48 = Base.bitcast(Base.UInt, %47)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %49 = Base.ult_int(%44, %48)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #16 if not %49
◌  <span class="sgr90">15 ─</span>       goto #17
◌  <span class="sgr90">16 ─</span> %52 = Core.tuple(2)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %52::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">17 ┄</span> %55 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %56 = Base.memoryrefnew(%55, 2, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%56, %40, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #18
◌  <span class="sgr90">18 ─</span> %59 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #22 if not %59
◌  <span class="sgr90">19 ─</span> %61 = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %62 = Base.bitcast(Base.UInt, %61)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %63 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %64 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %65 = Base.getfield(%63, 1, %64)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %66 = Base.bitcast(Base.UInt, %65)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %67 = Base.ult_int(%62, %66)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #21 if not %67
◌  <span class="sgr90">20 ─</span>       goto #22
◌  <span class="sgr90">21 ─</span> %70 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %70::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">22 ┄</span> %73 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %74 = Base.memoryrefnew(%73, 1, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %75 = Base.memoryrefget(%74, :not_atomic, false)<span class="sgr36">::Any</span>
◌  <span class="sgr90">└───</span>       goto #23
<span class="sgr31">X  </span><span class="sgr90">23 ─</span> %77 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %78 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %79 = Base.getfield(%77, 1, %78)<span class="sgr36">::Int64</span>
<span class="sgr34">↑′ </span><span class="sgr90">│   </span> %80 = Core.tuple(%75, %79)<span class="sgr36">::Tuple{Any, Int64}</span>
◌  <span class="sgr90">└───</span>       return %80</code></pre><p>次の例は、ベクターのサイズ変更が正確なエイリアス分析を困難にする様子を示しています。基本的な難しさは、割り当てられた配列 <code>%1</code> の次元が最初に <code>0</code> に初期化されることですが、その後の2回の <code>:jl_array_grow_end</code> 呼び出しによって変更されることです。現在、<code>EscapeAnalysis</code> は、配列のサイズ変更操作に遭遇すると正確なエイリアス分析を単純に諦めてしまい、そのため <code>%2</code>（<code>SafeRef(s)</code> に対応）と <code>%20</code>（<code>SafeRef(t)</code> に対応）の両方に <code>ReturnEscape</code> が課せられます。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes((String,String)) do s, t
           ary = Any[]
           push!(ary, SafeRef(s))
           push!(ary, SafeRef(t))
           ary[1], length(ary)
       end</code><code class="nohighlight hljs ansi" style="display:block;">#17(<span class="sgr31">X s::String</span>, <span class="sgr31">X t::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ──</span> %1  = Core.getproperty(Memory{Any}, :instance)<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %2  = invoke Core.memoryref(%1::Memory{Any})<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %3  = %new(Vector{Any}, %2, (0,))<span class="sgr36">::Vector{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %4  = %new(Main.SafeRef{String}, _2)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %5  = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %6  = Base.getfield(%5, :mem)<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %7  = Base.getfield(%6, :length)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %8  = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %9  = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %10 = Base.getfield(%8, 1, %9)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %11 = Base.add_int(%10, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %12 = Base.memoryrefoffset(%5)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %13 = Core.tuple(%11)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span>       Base.setfield!(%3, :size, %13)<span class="sgr90">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %15 = Base.add_int(%12, %11)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %16 = Base.sub_int(%15, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %17 = Base.slt_int(%7, %16)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #3 if not %17
<span class="sgr31">X  </span><span class="sgr90">2 ──</span> %19 = %new(Base.var&quot;#133#134&quot;{Vector{Any}, Int64, Int64, Int64, Int64, Int64, Memory{Any}, MemoryRef{Any}}, %3, %16, %12, %11, %10, %7, %6, %5)<span class="sgr36">::Base.var&quot;#133#134&quot;{Vector{Any}, Int64, Int64, Int64, Int64, Int64, Memory{Any}, MemoryRef{Any}}</span>
<span class="sgr32">✓  </span><span class="sgr90">└───</span>       invoke %19()<span class="sgr90">::MemoryRef{Any}</span>
◌  <span class="sgr90">3 ┄─</span>       goto #4
<span class="sgr31">X  </span><span class="sgr90">4 ──</span> %22 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %23 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %24 = Base.getfield(%22, 1, %23)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %25 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %26 = Base.memoryrefnew(%25, %24, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%26, %4, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #5
<span class="sgr31">X  </span><span class="sgr90">5 ──</span> %29 = %new(Main.SafeRef{String}, _3)<span class="sgr36">::Main.SafeRef{String}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %30 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %31 = Base.getfield(%30, :mem)<span class="sgr36">::Memory{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %32 = Base.getfield(%31, :length)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %33 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %34 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %35 = Base.getfield(%33, 1, %34)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %36 = Base.add_int(%35, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %37 = Base.memoryrefoffset(%30)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %38 = Core.tuple(%36)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span>       Base.setfield!(%3, :size, %38)<span class="sgr90">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %40 = Base.add_int(%37, %36)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %41 = Base.sub_int(%40, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %42 = Base.slt_int(%32, %41)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #7 if not %42
<span class="sgr31">X  </span><span class="sgr90">6 ──</span> %44 = %new(Base.var&quot;#133#134&quot;{Vector{Any}, Int64, Int64, Int64, Int64, Int64, Memory{Any}, MemoryRef{Any}}, %3, %41, %37, %36, %35, %32, %31, %30)<span class="sgr36">::Base.var&quot;#133#134&quot;{Vector{Any}, Int64, Int64, Int64, Int64, Int64, Memory{Any}, MemoryRef{Any}}</span>
<span class="sgr32">✓  </span><span class="sgr90">└───</span>       invoke %44()<span class="sgr90">::MemoryRef{Any}</span>
◌  <span class="sgr90">7 ┄─</span>       goto #8
<span class="sgr31">X  </span><span class="sgr90">8 ──</span> %47 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %48 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %49 = Base.getfield(%47, 1, %48)<span class="sgr36">::Int64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %50 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %51 = Base.memoryrefnew(%50, %49, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span>       Base.memoryrefset!(%51, %29, :not_atomic, false)<span class="sgr90">::Main.SafeRef{String}</span>
◌  <span class="sgr90">└───</span>       goto #9
◌  <span class="sgr90">9 ──</span> %54 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #13 if not %54
◌  <span class="sgr90">10 ─</span> %56 = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %57 = Base.bitcast(Base.UInt, %56)<span class="sgr36">::UInt64</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %58 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %59 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %60 = Base.getfield(%58, 1, %59)<span class="sgr36">::Int64</span>
◌  <span class="sgr90">│   </span> %61 = Base.bitcast(Base.UInt, %60)<span class="sgr36">::UInt64</span>
◌  <span class="sgr90">│   </span> %62 = Base.ult_int(%57, %61)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #12 if not %62
◌  <span class="sgr90">11 ─</span>       goto #13
◌  <span class="sgr90">12 ─</span> %65 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr32">✓  </span><span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Any}, %65::Tuple{Int64})<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
<span class="sgr31">X  </span><span class="sgr90">13 ┄</span> %68 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %69 = Base.memoryrefnew(%68, 1, false)<span class="sgr36">::MemoryRef{Any}</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %70 = Base.memoryrefget(%69, :not_atomic, false)<span class="sgr36">::Any</span>
◌  <span class="sgr90">└───</span>       goto #14
<span class="sgr31">X  </span><span class="sgr90">14 ─</span> %72 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
◌  <span class="sgr90">│   </span> %73 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr31">X  </span><span class="sgr90">│   </span> %74 = Base.getfield(%72, 1, %73)<span class="sgr36">::Int64</span>
<span class="sgr34">↑′ </span><span class="sgr90">│   </span> %75 = Core.tuple(%70, %74)<span class="sgr36">::Tuple{Any, Int64}</span>
◌  <span class="sgr90">└───</span>       return %75</code></pre><p>これらの課題に対処するためには、推論が配列の次元を認識し、フローに敏感な方法で配列の次元を伝播させる必要があります<sup class="footnote-reference"><a id="citeref-ArrayDimension" href="#footnote-ArrayDimension">[ArrayDimension]</a></sup>。また、ループ変数の値の良い表現を考案する必要があります。</p><p><code>EscapeAnalysis</code> は、配列の次元やインデックスが明らかに定数でない場合に、正確なインデックス情報を追跡しないより不正確な分析に迅速に切り替わります。この切り替えは、データフロー分析フレームワークにおける <code>EscapeInfo.AliasInfo</code> プロパティのラティス結合操作として自然に実装できます。</p><h3 id="EA-Exception-Handling"><a class="docs-heading-anchor" href="#EA-Exception-Handling">Exception Handling</a><a id="EA-Exception-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#EA-Exception-Handling" title="Permalink"></a></h3><p><code>EscapeAnalysis</code>が例外を介した可能性のあるエスケープをどのように処理するかについても言及する価値があります。単純に考えると、対応する<code>try</code>ブロックでスローされる可能性のあるすべての値に対して<code>:the_exception</code>オブジェクトに課せられたエスケープ情報を伝播させるだけで十分なように思えます。しかし、実際には、<code>Base.current_exceptions</code>や<code>rethrow</code>など、Juliaで例外オブジェクトにアクセスするための他のいくつかの方法があります。たとえば、エスケープ分析は、以下の例で<code>r</code>の潜在的なエスケープを考慮する必要があります。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const GR = Ref{Any}();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @noinline function rethrow_escape!()
           try
               rethrow()
           catch err
               GR[] = err
           end
       end;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get′(x) = isassigned(x) ? x[] : throw(x);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_escapes() do
           r = Ref{String}()
           local t
           try
               t = get′(r)
           catch err
               t = typeof(err)   # `err` (which `r` aliases to) doesn&#39;t escape here
               rethrow_escape!() # but `r` escapes here
           end
           return t
       end</code><code class="nohighlight hljs ansi" style="display:block;">#19()<span class="sgr1"> in Main at REPL[4]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ─</span> %1  = %new(Base.RefValue{String})<span class="sgr36">::Base.RefValue{String}</span>
◌  <span class="sgr90">2 ─</span> %2  = enter #8
◌  <span class="sgr90">3 ─</span> %3  = Base.isdefined(%1, :x)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└──</span>       goto #5 if not %3
<span class="sgr31">X  </span><span class="sgr90">4 ─</span> %5  = Base.getfield(%1, :x)<span class="sgr36">::String</span>
◌  <span class="sgr90">└──</span>       goto #6
◌  <span class="sgr90">5 ─</span>       Main.throw(%1)<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└──</span>       unreachable
◌  <span class="sgr90">6 ─</span>       $(Expr(:leave, :(%2)))
◌  <span class="sgr90">7 ─</span>       goto #9
<span class="sgr32">✓  </span><span class="sgr90">8 ┄</span> %11 = $(Expr(:the_exception))<span class="sgr36">::Any</span>
<span class="sgr31">X  </span><span class="sgr90">│  </span> %12 = Main.typeof(%11)<span class="sgr36">::DataType</span>
<span class="sgr32">✓  </span><span class="sgr90">│  </span>       invoke Main.rethrow_escape!()<span class="sgr90">::Any</span>
◌  <span class="sgr90">└──</span>       $(Expr(:pop_exception, :(%2)))<span class="sgr90">::Core.Const(nothing)</span>
<span class="sgr31">X  </span><span class="sgr90">9 ┄</span> %15 = φ (#7 =&gt; %5, #8 =&gt; %12)<span class="sgr36">::Union{DataType, String}</span>
◌  <span class="sgr90">└──</span>       return %15</code></pre><p>すべての可能なエスケープを既存の例外インターフェースを介して正しく推論するには、グローバルな分析が必要です。現時点では、例外処理とエラーパスが通常それほどパフォーマンスに敏感である必要がないことを考慮して、すべての潜在的にスローされるオブジェクトに対して最上位のエスケープ情報を保守的に伝播させています。また、エラーパスの最適化は、遅延の理由から意図的に「最適化されていない」ことが多いため、非常に効果的でない可能性があります。</p><p><code>x::EscapeInfo</code>の<code>x.ThrownEscape</code>プロパティは、<code>x</code>が例外としてスローされる可能性のあるSSAステートメントを記録します。この情報を使用して、<code>EscapeAnalysis</code>は、各<code>try</code>領域でスローされる可能性のある例外に限定して、例外を介した可能なエスケープを制限的に伝播させることができます。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result = code_escapes((String,String)) do s1, s2
           r1 = Ref(s1)
           r2 = Ref(s2)
           local ret
           try
               s1 = get′(r1)
               ret = sizeof(s1)
           catch err
               global GV = err # will definitely escape `r1`
           end
           s2 = get′(r2)       # still `r2` doesn&#39;t escape fully
           return s2
       end</code><code class="nohighlight hljs ansi" style="display:block;">#21(<span class="sgr31">X s1::String</span>, <span class="sgr33">↑ s2::String</span>)<span class="sgr1"> in Main at REPL[1]:2</span>
<span class="sgr31">X  </span><span class="sgr90">1 ──</span> %1  = %new(Base.RefValue{String}, _2)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr33">*′ </span><span class="sgr90">└───</span> %2  = %new(Base.RefValue{String}, _3)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr33">*′ </span><span class="sgr90">2 ──</span> %3  = ϒ (%2)<span class="sgr36">::Base.RefValue{String}</span>
◌  <span class="sgr90">└───</span> %4  = enter #8
◌  <span class="sgr90">3 ──</span> %5  = Base.isdefined(%1, :x)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #5 if not %5
<span class="sgr31">X  </span><span class="sgr90">4 ──</span>       Base.getfield(%1, :x)<span class="sgr90">::String</span>
◌  <span class="sgr90">└───</span>       goto #6
◌  <span class="sgr90">5 ──</span>       Main.throw(%1)<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
◌  <span class="sgr90">6 ──</span>       $(Expr(:leave, :(%4)))
◌  <span class="sgr90">7 ──</span>       goto #11
<span class="sgr33">*′ </span><span class="sgr90">8 ┄─</span> %13 = φᶜ (%3)<span class="sgr36">::Base.RefValue{String}</span>
<span class="sgr31">X  </span><span class="sgr90">└───</span> %14 = $(Expr(:the_exception))<span class="sgr36">::Any</span>
◌  <span class="sgr90">9 ──</span>       nothing<span class="sgr90">::Nothing</span>
◌  <span class="sgr90">10 ─</span>       (Main.GV = %14)<span class="sgr90">::Any</span>
◌  <span class="sgr90">└───</span>       $(Expr(:pop_exception, :(%4)))<span class="sgr90">::Core.Const(nothing)</span>
<span class="sgr33">*′ </span><span class="sgr90">11 ┄</span> %18 = φ (#7 =&gt; %2, #10 =&gt; %13)<span class="sgr36">::Base.RefValue{String}</span>
◌  <span class="sgr90">│   </span> %19 = Base.isdefined(%18, :x)<span class="sgr36">::Bool</span>
◌  <span class="sgr90">└───</span>       goto #13 if not %19
<span class="sgr33">↑  </span><span class="sgr90">12 ─</span> %21 = Base.getfield(%18, :x)<span class="sgr36">::String</span>
◌  <span class="sgr90">└───</span>       goto #14
◌  <span class="sgr90">13 ─</span>       Main.throw(%18)<span class="sgr90">::Union{}</span>
◌  <span class="sgr90">└───</span>       unreachable
◌  <span class="sgr90">14 ─</span>       return %21</code></pre><h2 id="Analysis-Usage"><a class="docs-heading-anchor" href="#Analysis-Usage">Analysis Usage</a><a id="Analysis-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-Usage" title="Permalink"></a></h2><p><code>analyze_escapes</code>は、SSA-IR要素のエスケープ情報を分析するためのエントリーポイントです。</p><p>最適化の多くは、インライン化パス（<code>ssa_inlining_pass!</code>）によって手続き間呼び出しが解決され、呼び出し元が展開された最適化されたソースに適用されると、より効果的です。それに応じて、<code>analyze_escapes</code>もインライン化後のIRを分析し、特定のメモリ関連の最適化に役立つエスケープ情報を収集することができます。</p><p>しかし、インライン化のような特定の最適化パスは制御フローを変更し、デッドコードを排除することができるため、エスケープ情報の手続き間の有効性を破る可能性があります。特に、手続き間で有効なエスケープ情報を収集するためには、インライン化前の中間表現（IR）を分析する必要があります。</p><p>この理由から、<code>analyze_escapes</code> は任意のJuliaレベルの最適化ステージで <code>IRCode</code> を分析でき、特に以下の2つのステージで使用されることが想定されています：</p><ul><li><code>IPO EA</code>: プレインライニングIRを分析して、IPO有効なエスケープ情報キャッシュを生成する</li><li><code>Local EA</code>: インライン後のIRを分析して、ローカルに有効なエスケープ情報を収集します。</li></ul><p><code>IPO EA</code> によって得られたエスケープ情報は、<code>ArgEscapeCache</code> データ構造に変換され、グローバルにキャッシュされます。適切な <code>get_escape_cache</code> コールバックを <code>analyze_escapes</code> に渡すことで、エスケープ分析は以前の <code>IPO EA</code> によって得られたインラインされていない呼び出し先のキャッシュされた手続き間情報を利用することで分析の精度を向上させることができます。さらに興味深いことに、<code>IPO EA</code> のエスケープ情報を型推論に使用することも有効であり、例えば、可変オブジェクトの <code>Const</code> / <code>PartialStruct</code> / <code>MustAlias</code> を形成することで推論の精度を向上させることができます。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Compiler.EscapeAnalysis.analyze_escapes" href="#Core.Compiler.EscapeAnalysis.analyze_escapes"><code>Core.Compiler.EscapeAnalysis.analyze_escapes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">analyze_escapes(ir::IRCode, nargs::Int, get_escape_cache) -&gt; estate::EscapeState</code></pre><p><code>ir</code>内のエスケープ情報を分析します：</p><ul><li><code>nargs</code>: 分析対象の呼び出しの実際の引数の数</li><li><code>get_escape_cache(::MethodInstance) -&gt; Union{Bool,ArgEscapeCache}</code>: キャッシュされた引数エスケープ情報を取得します</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/compiler/ssair/EscapeAnalysis/EscapeAnalysis.jl#L608-L615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Compiler.EscapeAnalysis.EscapeState" href="#Core.Compiler.EscapeAnalysis.EscapeState"><code>Core.Compiler.EscapeAnalysis.EscapeState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estate::EscapeState</code></pre><p>引き延ばされた格子で、引数とSSA値を<a href="EscapeAnalysis.html#Core.Compiler.EscapeAnalysis.EscapeInfo"><code>EscapeInfo</code></a>として表現されたエスケープ情報にマッピングします。SSA IR要素<code>x</code>に課せられたエスケープ情報は、<code>estate[x]</code>を使用して取得できます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/compiler/ssair/EscapeAnalysis/EscapeAnalysis.jl#L440-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Compiler.EscapeAnalysis.EscapeInfo" href="#Core.Compiler.EscapeAnalysis.EscapeInfo"><code>Core.Compiler.EscapeAnalysis.EscapeInfo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">x::EscapeInfo</code></pre><p>エスケープ情報の格子で、以下のプロパティを保持します：</p><ul><li><p><code>x.Analyzed::Bool</code>: 格子の正式な部分ではなく、<code>x</code> が分析されたかどうかを示します</p></li><li><p><code>x.ReturnEscape::Bool</code>: <code>x</code> が戻り値を介して呼び出し元にエスケープできることを示します</p></li><li><p><code>x.ThrownEscape::BitSet</code>: <code>x</code> が例外としてスローされる可能性のあるSSAステートメント番号を記録します：</p><ul><li><code>isempty(x.ThrownEscape)</code>: <code>x</code> はこの呼び出しフレームで決してスローされません（底）</li><li><code>pc ∈ x.ThrownEscape</code>: <code>x</code> は <code>pc</code> のSSAステートメントでスローされる可能性があります</li><li><code>-1 ∈ x.ThrownEscape</code>: <code>x</code> はこの呼び出しフレームの任意のポイントでスローされる可能性があります（上）</li></ul><p>この情報は、<code>escape_exception!</code> によって例外を介して潜在的なエスケープを伝播するために使用されます。</p></li><li><p><code>x.AliasInfo::Union{Bool,IndexableFields,IndexableElements,Unindexable}</code>: <code>x</code> のフィールドまたは配列要素にエイリアスされる可能性のあるすべての値を保持します：</p><ul><li><code>x.AliasInfo === false</code> は、<code>x</code> のフィールド/要素がまだ分析されていないことを示します</li><li><code>x.AliasInfo === true</code> は、<code>x</code> のフィールド/要素が分析できないことを示します。例えば、<code>x</code> の型が不明であるか、具体的でないため、そのフィールド/要素を正確に知ることができません</li><li><code>x.AliasInfo::IndexableFields</code> は、オブジェクト <code>x</code> のフィールドにエイリアスされる可能性のあるすべての値を正確なインデックス情報と共に記録します</li><li><code>x.AliasInfo::IndexableElements</code> は、配列 <code>x</code> の要素にエイリアスされる可能性のあるすべての値を正確なインデックス情報と共に記録します</li><li><code>x.AliasInfo::Unindexable</code> は、正確なインデックス情報なしに <code>x</code> のフィールド/要素にエイリアスされる可能性のあるすべての値を記録します</li></ul></li><li><p><code>x.Liveness::BitSet</code>: <code>x</code> が生きているべきSSAステートメント番号を記録します。例えば、呼び出し引数として使用される、呼び出し元に返される、または <code>:foreigncall</code> のために保持されるべきです：</p><ul><li><code>isempty(x.Liveness)</code>: <code>x</code> はこの呼び出しフレームで決して使用されません（底）</li><li><code>0 ∈ x.Liveness</code> は、現在分析中の呼び出しフレームの呼び出し引数であることを示す特別な意味を持ちます（したがって、呼び出し元からすぐに見える）。</li><li><code>pc ∈ x.Liveness</code>: <code>x</code> は <code>pc</code> のSSAステートメントで使用される可能性があります</li><li><code>-1 ∈ x.Liveness</code>: <code>x</code> はこの呼び出しフレームの任意のポイントで使用される可能性があります（上）</li></ul></li></ul><p>一般的な <code>EscapeInfo</code> を作成するためのユーティリティコンストラクタがあります。例えば、</p><ul><li><code>NoEscape()</code>: この格子の底（類似）要素で、どこにもエスケープしないことを意味します</li><li><code>AllEscape()</code>: この格子の最上位要素で、どこにでもエスケープすることを意味します</li></ul><p><code>analyze_escapes</code> は、これらの要素を底から上に移行させ、Julia のネイティブ型推論ルーチンと同じ方向に進みます。抽象状態は底（類似）要素で初期化されます：</p><ul><li>呼び出し引数は <code>ArgEscape()</code> として初期化され、その <code>Liveness</code> プロパティには <code>0</code> が含まれ、呼び出し引数として渡され、呼び出し元からすぐに見えることを示します</li><li>他の状態は <code>NotAnalyzed()</code> として初期化され、これは <code>NoEscape</code> よりもわずかに低い特別な格子要素ですが、同時にまだ分析されていないこと以外の意味を持ちません（したがって、正式には格子の一部ではありません）</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/compiler/ssair/EscapeAnalysis/EscapeAnalysis.jl#L41-L81">source</a></section></article><hr/><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-LatticeDesign"><a class="tag is-link" href="#citeref-LatticeDesign">LatticeDesign</a>Our type inference implementation takes the alternative approach, where each lattice property is represented by a special lattice element type object. It turns out that it started to complicate implementations of the lattice operations mainly because it often requires conversion rules between each lattice element type object. And we are working on <a href="https://github.com/JuliaLang/julia/pull/42596">overhauling our type inference lattice implementation</a> with <code>EscapeInfo</code>-like lattice design.</li><li class="footnote" id="footnote-MM02"><a class="tag is-link" href="#citeref-MM02">MM02</a><em>A Graph-Free approach to Data-Flow Analysis</em>.      Markas Mohnen, 2002, April.      <a href="https://api.semanticscholar.org/CorpusID:28519618">https://api.semanticscholar.org/CorpusID:28519618</a>.</li><li class="footnote" id="footnote-BackandForth"><a class="tag is-link" href="#citeref-BackandForth">BackandForth</a>Our type inference algorithm in contrast is implemented as a forward analysis, because type information usually flows from &quot;definition&quot; to &quot;usage&quot; and it is more natural and effective to propagate such information in a forward way.</li><li class="footnote" id="footnote-Dynamism"><a class="tag is-link" href="#citeref-Dynamism">Dynamism</a>In some cases, however, object fields can&#39;t be analyzed precisely. For example, object may escape to somewhere <code>EscapeAnalysis</code> can&#39;t account for possible memory effects on it, or fields of the objects simply can&#39;t be known because of the lack of type information. In such cases <code>AliasInfo</code> property is raised to the topmost element within its own lattice order, and it causes succeeding field analysis to be conservative and escape information imposed on fields of an unanalyzable object to be propagated to the object itself.</li><li class="footnote" id="footnote-JVM05"><a class="tag is-link" href="#citeref-JVM05">JVM05</a><em>Escape Analysis in the Context of Dynamic Compilation and Deoptimization</em>.       Thomas Kotzmann and Hanspeter Mössenböck, 2005, June.       <a href="https://dl.acm.org/doi/10.1145/1064979.1064996">https://dl.acm.org/doi/10.1145/1064979.1064996</a>.</li><li class="footnote" id="footnote-ArrayDimension"><a class="tag is-link" href="#citeref-ArrayDimension">ArrayDimension</a>Otherwise we will need yet another forward data-flow analysis on top of the escape analysis.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ssair.html">« Julia SSA-form IR</a><a class="docs-footer-nextpage" href="aot.html">Ahead of Time Compilation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 20 May 2025 07:07">Tuesday 20 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
