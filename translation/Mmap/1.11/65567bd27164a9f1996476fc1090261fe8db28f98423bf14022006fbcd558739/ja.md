```
mmap(io::Union{IOStream,AbstractString,Mmap.AnonymousMmap}[, type::Type{Array{T,N}}, dims, offset]; grow::Bool=true, shared::Bool=true)
mmap(type::Type{Array{T,N}}, dims)
```

メモリマッピングを使用して、ファイルにリンクされた `Array` を作成します。これは、コンピュータのメモリに収まりきらないほど大きなデータを扱うための便利な方法です。

型は `Array{T,N}` で、`T` のビット型要素と、配列のバイトがどのように解釈されるかを決定する次元 `N` があります。ファイルはバイナリ形式で保存されている必要があり、フォーマット変換はできません（これはオペレーティングシステムの制限であり、Juliaの制限ではありません）。

`dims` は、配列のサイズまたは長さを指定するタプルまたは単一の [`Integer`](@ref) です。

ファイルはストリーム引数を介して渡され、オープンされた [`IOStream`](@ref) またはファイル名文字列として渡されます。ストリームを初期化する際は、"読み取り専用" 配列には `"r"` を、ディスクに値を書き込むために新しい配列を作成するには `"w+"` を使用します。

`type` 引数が指定されていない場合、デフォルトは `Vector{UInt8}` です。

オプションで、例えばファイルのヘッダーをスキップしたい場合は、オフセット（バイト単位）を指定できます。オフセットのデフォルト値は、`IOStream` の現在のストリーム位置です。

`grow` キーワード引数は、要求された配列のサイズに合わせてディスクファイルを拡張する必要があるかどうかを指定します（ファイルの総サイズが要求された配列サイズより小さい場合）。ファイルを拡張するには書き込み権限が必要です。

`shared` キーワード引数は、結果として得られる `Array` とそれに加えられた変更が、同じファイルをマッピングしている他のプロセスに見えるかどうかを指定します。

例えば、以下のコードは

```julia
# mmapping用のファイルを作成
# （このステップもmmapを使用して行うことができます）
using Mmap
A = rand(1:20, 5, 30)
s = open("/tmp/mmap.bin", "w+")
# 配列の次元をファイルの最初の2つのIntとして書き込みます
write(s, size(A,1))
write(s, size(A,2))
# データを書き込みます
write(s, A)
close(s)

# 読み戻してテスト
s = open("/tmp/mmap.bin")   # デフォルトは読み取り専用
m = read(s, Int)
n = read(s, Int)
A2 = mmap(s, Matrix{Int}, (m,n))
```

ストリーム `s` に関連付けられたファイルにリンクされた `m` 行 `n` 列の `Matrix{Int}` を作成します。

よりポータブルなファイルは、ワードサイズ – 32ビットまたは64ビット – とエンディアン情報をヘッダーにエンコードする必要があります。実際には、メモリマッピングと共に使用できる標準フォーマット（HDF5など）を使用してバイナリデータをエンコードすることを検討してください。
