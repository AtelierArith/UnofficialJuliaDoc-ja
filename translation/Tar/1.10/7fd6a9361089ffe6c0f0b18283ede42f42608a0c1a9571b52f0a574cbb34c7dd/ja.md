```julia
tree_hash([ predicate, ] tarball;
          [ algorithm = "git-sha1", ]
          [ skip_empty = false ]) -> hash::String

    predicate  :: Header --> Bool
    tarball    :: Union{AbstractString, AbstractCmd, IO}
    algorithm  :: AbstractString
    skip_empty :: Bool
```

tarballが含むファイルツリーのツリーハッシュ値を計算します。デフォルトでは、これはgitのツリーハッシュアルゴリズムを使用し、SHA1セキュアハッシュ関数を用います（現在のgitのバージョンのように）。これは、gitが表現できるファイルツリーを持つ任意のtarball、すなわちファイル、シンボリックリンク、および非空のディレクトリのみを含むtarballに対して、この関数によって計算されるハッシュ値が、そのファイルツリーに対してgitが計算するハッシュ値と同じであることを意味します。tarballは空のディレクトリを持つファイルツリーを表現できることに注意してください。gitはそれを保存できませんが、この関数はそれらのハッシュを生成できます。デフォルトでは（この動作を変更する方法については以下の`skip_empty`を参照）、これらの空のディレクトリを省略したtarballのハッシュとは異なります。要するに、ハッシュ関数はgitが表現できるすべてのツリーに対してgitと一致しますが、gitが表現できない他のツリーに対して一貫した方法でハッシュ可能なツリーのドメインを拡張します。

`predicate`関数が渡されると、`tarball`を処理している間に遭遇する各`Header`オブジェクトに対して呼び出され、`predicate(hdr)`がtrueの場合にのみエントリがハッシュされます。これは、アーカイブの一部のみを選択的にハッシュしたり、`extract`がエラーをスローするエントリをスキップしたり、ハッシュ処理中に抽出されたものを記録するために使用できます。

`Header`オブジェクトは、tarball内の生のヘッダーから多少修正されてからpredicate関数に渡されます：`path`フィールドは、`.`エントリを削除し、連続するスラッシュを単一のスラッシュに置き換えるように正規化されます。エントリが`:hardlink`タイプの場合、リンクターゲットパスも同様に正規化され、ターゲットエントリのパスと一致するようになります；サイズフィールドはターゲットパスのサイズに設定されます（これはすでに見たファイルでなければなりません）。

現在サポートされている`algorithm`の値は、`git-sha1`（デフォルト）と`git-sha256`です。後者は、`git-sha1`と同じ基本アルゴリズムを使用しますが、SHA1ハッシュ関数をSHA2-256に置き換えます。これは、gitが将来的に使用することになるハッシュ関数です（SHA1に対する既知の攻撃のため）。将来的には他のファイルツリーハッシングアルゴリズムのサポートが追加される可能性があります。

`skip_empty`オプションは、再帰的にファイルやシンボリックリンクを含まないディレクトリがハッシュに含まれるか無視されるかを制御します。一般的に、tarballやファイルツリーの内容をハッシュする場合、非空のものだけでなくすべてのディレクトリに関心があるため、これらを計算されたハッシュに含めるのがデフォルトです。では、なぜこの関数は空のディレクトリをスキップするオプションを提供するのでしょうか？それは、gitが空のディレクトリを保存することを拒否し、リポジトリに追加しようとすると無視するからです。したがって、ファイルをgitリポジトリに追加して参照ツリーハッシュを計算し、その後gitにツリーハッシュを要求すると、得られるハッシュ値は`skip_empty=true`の`tree_hash`によって計算されたハッシュ値と一致します。言い換えれば、このオプションは`tree_hash`が空のディレクトリを持つツリーをgitがどのようにハッシュするかをエミュレートできるようにします。ただし、空のディレクトリを含むツリー（すなわち、gitリポジトリから来ていないもの）をハッシュする場合は、空のディレクトリを無視しないツール（このツールなど）を使用してハッシュすることをお勧めします。
