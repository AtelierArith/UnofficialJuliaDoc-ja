```julia
SharedArray{T}(dims::NTuple; init=false, pids=Int[])
SharedArray{T,N}(...)
```

ビット型 `T` とサイズ `dims` の `SharedArray` を、指定されたプロセス `pids` にわたって構築します - すべて同じホスト上に存在する必要があります。`N` が `SharedArray{T,N}(dims)` を呼び出すことで指定される場合、`N` は `dims` の長さと一致しなければなりません。

`pids` が指定されていない場合、共有配列は現在のホスト上のすべてのプロセスにマッピングされ、マスターを含みます。しかし、`localindices` と `indexpids` はワーカープロセスのみを参照します。これにより、作業分配コードが実際の計算にワーカーを使用し、マスタープロセスがドライバーとして機能することが容易になります。

`init` 関数の型 `initfn(S::SharedArray)` が指定されている場合、それはすべての参加ワーカーで呼び出されます。

共有配列は、マッピングを作成したノードに `SharedArray` オブジェクトへの参照が存在する限り有効です。

```julia
SharedArray{T}(filename::AbstractString, dims::NTuple, [offset=0]; mode=nothing, init=false, pids=Int[])
SharedArray{T,N}(...)
```

ファイル `filename` にバックアップされた `SharedArray` を、要素型 `T`（ビット型でなければならない）とサイズ `dims` で、指定されたプロセス `pids` にわたって構築します - すべて同じホスト上に存在する必要があります。このファイルはホストメモリにマップされ、以下の結果をもたらします：

  * 配列データはバイナリ形式で表現される必要があります（例：CSVのようなASCII形式はサポートされません）
  * 配列の値に対する変更（例：`A[3] = 0`）は、ディスク上の値も変更します

`pids` が指定されていない場合、共有配列は現在のホスト上のすべてのプロセスにマッピングされ、マスターを含みます。しかし、`localindices` と `indexpids` はワーカープロセスのみを参照します。これにより、作業分配コードが実際の計算にワーカーを使用し、マスタープロセスがドライバーとして機能することが容易になります。

`mode` は `"r"`、`"r+"`、`"w+"`、または `"a+"` のいずれかでなければならず、指定されたファイル `filename` がすでに存在する場合はデフォルトで `"r+"`、存在しない場合は `"w+"` になります。`init` 関数の型 `initfn(S::SharedArray)` が指定されている場合、それはすべての参加ワーカーで呼び出されます。ファイルが書き込み可能でない場合、`init` 関数を指定することはできません。

`offset` はファイルの先頭で指定されたバイト数をスキップすることを可能にします。
