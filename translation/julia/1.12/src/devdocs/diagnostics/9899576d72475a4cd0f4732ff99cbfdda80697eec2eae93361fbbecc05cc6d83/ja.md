# Diagnostics used by the package ecosystem

このページは、主に外部ツールによって使用されるJuliaに埋め込まれた「フック」を文書化しています。これらのツールの多くは、Julia本体の一部にするにはあまりにも複雑な分析を実行するように設計されています。

## SnoopCompile

SnoopCompile "snoops" は、無効化や型推論に関する分析のために情報を抽出するために、Juliaのコンパイラ上で動作します。さまざまな目的のために使用されるいくつかの内部機能があります：

  * 無効化の記録: `Base.StaticData.debug_method_invalidation` と `ccall(:jl_debug_method_invalidation, ...)`: これらは無効化の異なるモードを記録します。SnoopCompileのユーザーは、例えばパッケージを読み込む際に、一時的にこれらをオンにします。各々は標準のログ形式を生成します; ログ形式を変更する場合は、SnoopCompileへの補完的なプルリクエストが必要になるかもしれません。SnoopCompileはこれらのログを処理し、メソッドテーブルやバインディングの特定の変更に起因する無効化されたCodeInstancesのツリーを生成します。
  * 推論の観察: `ccall(:jl_set_newly_inferred, ...)` と `ccall(:jl_set_inference_entrance_backtraces, ...)`: これらは推論がどのようにトリガーされるかを理解するために使用されます。主な目的は、パフォーマンス診断がTTFXの原因を理解できるようにすることです。これらの `ccall` の2つ目は、型推論へのすべての入口でバックトレースを記録するため、SnoopCompileが動的ディスパッチされた呼び出しの呼び出し元を特定できるようにします。これは、新しい型推論の「原因」を特定するために必要です。

    `jl_set_inference_entrance_backtraces` 関数は、推論入口イベントが記録される配列を受け取ります。各推論イベントは、2つの連続した配列要素を格納します。最初に `CodeInstance` オブジェクトがあり、その後にバックトレースの表現があります。したがって、N 個の推論イベントの場合、配列は 2N 個の要素を含み、次のように配置されます: `[ci₁, bt₁, ci₂, bt₂, ..., ciₙ, btₙ]`。

    注意してください。バックトレース要素 `btᵢ` には、生のバックトレースデータが含まれており、通常は `stacktrace(Base._reformat_bt(btᵢ...))` を使用して処理する必要があります。これにより、分析のために使用可能なスタックトレース形式に変換されます。
