```
@r_str -> Regex
```

正規表現を構築します。例えば、`r"^[a-z]*$"`のように、補間やエスケープを行わずに（引用符 `"` はエスケープする必要があります）。正規表現は、動作を変更するために終了引用符の後にリストされた1つ以上のフラグも受け入れます：

  * `i` は大文字と小文字を区別しないマッチングを有効にします。
  * `m` は `^` と `$` トークンを文字列全体ではなく、個々の行の開始と終了にマッチさせます。
  * `s` は `.` 修飾子が改行にマッチすることを許可します。
  * `x` は「自由スペースモード」を有効にします：正規表現トークン間の空白はエスケープされていない限り無視され、`#` はコメントの開始として扱われ（行末まで無視されます）。
  * `a` はASCIIモードを有効にします（`UTF`および`UCP`モードを無効にします）。デフォルトでは、`\B`、`\b`、`\D`、`\d`、`\S`、`\s`、`\W`、`\w`などはUnicode文字プロパティに基づいてマッチします。このオプションを使用すると、これらのシーケンスはASCII文字のみをマッチします。これには`\u`も含まれ、指定された文字値を単一バイトとして直接出力し、UTF-8にエンコードしようとはしません。重要なことに、このオプションは無効なUTF-8文字列に対してマッチングを許可し、マッチャーとターゲットの両方を単純なバイト（ISO/IEC 8859-1 / Latin-1バイトのように）として扱います。この場合、このオプションはしばしば`s`と組み合わせて使用されます。このオプションは、パターンを(*UCP)または(*UTF)で開始することによってさらに洗練されることがあります。

補間が必要な場合は、[`Regex`](@ref)を参照してください。

# 例

```jldoctest
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
```

この正規表現は最初の3つのフラグが有効になっています。
