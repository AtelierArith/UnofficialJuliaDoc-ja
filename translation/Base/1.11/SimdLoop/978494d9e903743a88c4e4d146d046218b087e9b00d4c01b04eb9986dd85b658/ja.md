```
@simd
```

`@simd`を使用して、コンパイラがループの再配置を許可するために`for`ループに注釈を付けます。

!!! warning
    この機能は実験的であり、将来のJuliaのバージョンで変更されたり消失したりする可能性があります。`@simd`マクロの不適切な使用は予期しない結果を引き起こす可能性があります。


`@simd for`ループで反復されるオブジェクトは、一次元の範囲である必要があります。`@simd`を使用することで、ループのいくつかの特性を主張しています：

  * 繰り返しを任意または重複した順序で実行することが安全であり、特に還元変数に関して考慮されます。
  * 還元変数に対する浮動小数点演算は再配置または収束される可能性があり、`@simd`なしでの結果とは異なる結果を引き起こす可能性があります。

多くの場合、Juliaは`@simd`を使用せずに内部の`for`ループを自動的にベクトル化することができます。`@simd`を使用することで、コンパイラはより多くの状況でそれを可能にするための少し余裕を持つことができます。いずれの場合でも、内部ループはベクトル化を許可するために以下の特性を持っている必要があります：

  * ループは最も内側のループでなければなりません。
  * ループ本体は直線的なコードでなければなりません。したがって、すべての配列アクセスには現在[`@inbounds`](@ref)が必要です。コンパイラは、すべてのオペランドを無条件に評価することが安全である場合、短い`&&`、`||`、および`?:`の式を直線的なコードに変換することがあります。ループ内で安全に行える場合は、`?:`の代わりに[`ifelse`](@ref)関数を使用することを検討してください。
  * アクセスはストライドパターンを持っている必要があり、「ギャザー」（ランダムインデックスの読み取り）や「スキャッター」（ランダムインデックスの書き込み）ではあってはなりません。
  * ストライドは単位ストライドである必要があります。

!!! note
    `@simd`はデフォルトでループが完全にループ運搬メモリ依存性から自由であることを主張しません。これは一般的なコードでは簡単に違反される仮定です。非一般的なコードを書いている場合は、`@simd ivdep for ... end`を使用して、以下も主張できます：


  * ループ運搬メモリ依存性は存在しない
  * どの反復も前の反復が前進するのを待つことはありません。
