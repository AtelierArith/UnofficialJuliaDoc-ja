```
@inline
```

コンパイラにこの関数をインライン化する価値があることを示します。

小さな関数には通常、`@inline` アノテーションは必要ありません。コンパイラが自動的に処理します。大きな関数に `@inline` を使用することで、コンパイラにインライン化を促すことができます。

`@inline` は関数定義の直前または関数本体内で適用できます。

```julia
# 長い定義にアノテーションを付ける
@inline function longdef(x)
    ...
end

# 短い定義にアノテーションを付ける
@inline shortdef(x) = ...

# `do` ブロックが作成する無名関数にアノテーションを付ける
f() do
    @inline
    ...
end
```

!!! compat "Julia 1.8"
    関数本体内での使用は、少なくとも Julia 1.8 が必要です。


---

```
@inline block
```

`block` 内の呼び出しがインライン化する価値があることをコンパイラに示します。

```julia
# コンパイラは `f` をインライン化しようとします
@inline f(...)

# コンパイラは `f`、`g` および `+` をインライン化しようとします
@inline f(...) + g(...)
```

!!! note
    呼び出し元のアノテーションは、呼び出された関数の定義に適用されたアノテーションよりも常に優先されます：

    ```julia
    @noinline function explicit_noinline(args...)
        # 本体
    end

    let
        @inline explicit_noinline(args...) # これはインライン化されます
    end
    ```


!!! note
    ネストされた呼び出し元のアノテーションがある場合、最も内側のアノテーションが優先されます：

    ```julia
    @noinline let a0, b0 = ...
        a = @inline f(a0)  # コンパイラはこの呼び出しをインライン化しようとします
        b = f(b0)          # コンパイラはこの呼び出しをインライン化しようとはしません
        return a, b
    end
    ```


!!! warning
    呼び出し元のアノテーションはコストモデルに関係なくインライン化を強制しようとしますが、成功しない可能性もあります。特に、再帰呼び出しは `@inline` としてアノテーションされていてもインライン化できません。


!!! compat "Julia 1.8"
    呼び出し元のアノテーションは、少なくとも Julia 1.8 が必要です。

