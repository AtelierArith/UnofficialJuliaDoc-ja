```
reduce(op, itr; [init])
```

与えられた二項演算子 `op` を使って、与えられたコレクション `itr` を縮約します。提供された場合、初期値 `init` は `op` の中立要素でなければならず、空のコレクションに対して返されます。非空のコレクションに対して `init` が使用されるかどうかは不明です。

空のコレクションに対しては、`init` を提供する必要がありますが、いくつかの特別なケース（例えば、`op` が `+`、`*`、`max`、`min`、`&`、`|` のいずれかである場合）では、Julia が `op` の中立要素を決定できます。

特定の一般的に使用される演算子の縮約には特別な実装がある場合があり、代わりに使用すべきです: [`maximum`](@ref)`(itr)`, [`minimum`](@ref)`(itr)`, [`sum`](@ref)`(itr)`, [`prod`](@ref)`(itr)`, [`any`](@ref)`(itr)`, [`all`](@ref)`(itr)`. 配列の配列を連結するための効率的な方法は、`reduce(`[`vcat`](@ref)`, arr)` または `reduce(`[`hcat`](@ref)`, arr)` を呼び出すことです。

縮約の結合性は実装に依存します。これは、`-` のような非結合的な操作を使用できないことを意味します。なぜなら、`reduce(-,[1,2,3])` が `(1-2)-3` または `1-(2-3)` として評価されるべきかは未定義だからです。左または右の結合性が保証されるためには、代わりに [`foldl`](@ref) または [`foldr`](@ref) を使用してください。

いくつかの操作は誤差を蓄積します。縮約がグループで実行できる場合、並列処理が容易になります。将来のバージョンの Julia ではアルゴリズムが変更される可能性があります。順序付きコレクションを使用する場合、要素は再配置されないことに注意してください。

# 例

```jldoctest
julia> reduce(*, [2; 3; 4])
24

julia> reduce(*, [2; 3; 4]; init=-1)
-24
```
