`AbstractString`型は、Juliaにおけるすべての文字列実装のスーパークラスです。文字列は、`AbstractChar`型によって表される[Unicode](https://unicode.org/)コードポイントのシーケンスのエンコーディングです。Juliaは文字列についていくつかの仮定をしています：

  * 文字列は固定サイズの「コードユニット」に基づいてエンコードされています。

      * コードユニットは`codeunit(s, i)`で抽出できます
      * 最初のコードユニットのインデックスは`1`です
      * 最後のコードユニットのインデックスは`ncodeunits(s)`です
      * `1 ≤ i ≤ ncodeunits(s)`を満たす任意のインデックス`i`は範囲内です
  * 文字列のインデックスはこれらのコードユニットに基づいて行われます：

      * 文字は有効な文字列インデックス`i`を使って`s[i]`で抽出されます
      * 文字列内の各`AbstractChar`は1つ以上のコードユニットでエンコードされています
      * `AbstractChar`の最初のコードユニットのインデックスのみが有効なインデックスです
      * `AbstractChar`のエンコーディングは、その前後に何があるかに依存しません
      * 文字列のエンコーディングは[自己同期](https://en.wikipedia.org/wiki/Self-synchronizing_code)しており、すなわち`isvalid(s, i)`はO(1)です

コードユニット、文字、または部分文字列を文字列から抽出するいくつかの文字列関数は、範囲外または無効な文字列インデックスを渡すとエラーになります。これには`codeunit(s, i)`や`s[i]`が含まれます。文字列インデックスの算術を行う関数は、インデックスに対してより緩やかなアプローチを取り、範囲内のときには最も近い有効な文字列インデックスを返し、範囲外のときには文字列の両側に無限の数の文字がパディングされているかのように振る舞います。通常、これらの想像上のパディング文字はコードユニットの長さが`1`ですが、文字列型はその実装に応じて異なる「想像上の」文字サイズを選択することがあります（例：部分文字列は、提供するビューの基になる文字列にインデックス算術を通すことがあります）。緩やかなインデックス関数には、インデックス算術を目的としたものが含まれます：`thisind`、`nextind`、および`prevind`。このモデルにより、インデックス算術は範囲外のインデックスを中間値として扱うことができ、文字を取得するためにそれらを使用しない限り、エッジケースを回避するのに役立ちます。

また、[`codeunit`](@ref)、[`ncodeunits`](@ref)、[`thisind`](@ref)、[`nextind`](@ref)、[`prevind`](@ref)も参照してください。
