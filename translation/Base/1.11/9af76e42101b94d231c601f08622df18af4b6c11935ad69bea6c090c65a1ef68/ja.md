```
unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)
```

指定されたアドレス `pointer` にあるデータの周りに Julia `Array` オブジェクトをラップしますが、コピーは作成しません。ポインタ要素型 `T` は配列要素型を決定します。 `dims` は整数（1次元配列の場合）または配列の次元のタプルです。 `own` はオプションで、Julia がメモリの所有権を取得し、配列がもはや参照されなくなったときにポインタに対して `free` を呼び出すかどうかを指定します。

この関数は「unsafe」とラベル付けされています。なぜなら、`pointer` が要求された長さのデータに対する有効なメモリアドレスでない場合、クラッシュするからです。 [`unsafe_load`](@ref) や [`unsafe_store!`](@ref) とは異なり、プログラマーは、C の厳密なエイリアス規則に似て、異なる要素型の2つの配列を介して基礎データにアクセスされないようにする責任も負います。
