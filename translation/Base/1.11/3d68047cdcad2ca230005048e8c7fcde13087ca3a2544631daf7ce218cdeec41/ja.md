```
ReentrantLock()
```

再入ロックを作成して、[`Task`](@ref)sを同期させます。同じタスクは必要な回数だけロックを取得できます（これが名前の「再入可能」という部分を意味します）。各[`lock`](@ref)は[`unlock`](@ref)と対になっている必要があります。

`lock`を呼び出すと、そのスレッドでのファイナライザの実行が対応する`unlock`まで抑制されます。以下に示す標準的なロックパターンの使用は自然にサポートされるべきですが、try/lockの順序を逆にしたり、tryブロックを完全に欠落させたりすることには注意してください（例えば、ロックを保持したまま戻ろうとすること）。

これは、ロック/アンロック呼び出しに対して取得/解放のメモリ順序を提供します。

```
lock(l)
try
    <atomic work>
finally
    unlock(l)
end
```

[`!islocked(lck::ReentrantLock)`](@ref islocked)が成り立つ場合、[`trylock(lck)`](@ref trylock)は、他のタスクが「同時に」ロックを保持しようとしていない限り成功します。
