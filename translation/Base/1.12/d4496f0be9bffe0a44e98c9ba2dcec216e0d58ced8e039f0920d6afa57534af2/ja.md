```julia
@r_str -> Regex
```

正規表現を構築します。例えば、`r"^[a-z]*$"`のように、補間やエスケープを行わずに（ただし、引用符`"`はエスケープする必要があります）。正規表現は、動作を変更するために、終了引用符の後に1つ以上のフラグを受け入れます：

  * `i` は大文字と小文字を区別しないマッチングを有効にします。
  * `m` は `^` と `$` トークンを全体の文字列ではなく、個々の行の開始と終了にマッチさせます。
  * `s` は `.` 修飾子が改行にマッチすることを許可します。
  * `x` は「自由スペースモード」を有効にします：正規表現トークン間の空白は、`\` でエスケープされている場合を除いて無視され、正規表現内の `#` はコメントの開始として扱われ（行の終わりまで無視されます）。
  * `a` はASCIIモードを有効にします（`UTF`および`UCP`モードを無効にします）。デフォルトでは、`\B`、`\b`、`\D`、`\d`、`\S`、`\s`、`\W`、`\w`などはUnicode文字プロパティに基づいてマッチします。このオプションを使用すると、これらのシーケンスはASCII文字のみをマッチします。これには`\u`も含まれ、指定された文字値を直接単一バイトとして出力し、UTF-8にエンコードしようとはしません。重要なことに、このオプションは、マッチャーとターゲットの両方を単純なバイト（ISO/IEC 8859-1 / Latin-1バイトのように）として扱うことにより、無効なUTF-8文字列に対してマッチングを許可します。この場合、このオプションはしばしば`s`と組み合わせて使用されます。このオプションは、パターンを(*UCP)または(*UTF)で始めることによってさらに洗練されることがあります。

補間が必要な場合は、[`Regex`](@ref)を参照してください。

# 例

```jldoctest
julia> match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")
```

この正規表現は最初の3つのフラグが有効になっています。
