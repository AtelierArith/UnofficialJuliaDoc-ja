```julia
invoke(f, argtypes::Type, args...; kwargs...)
invoke(f, argtypes::Method, args...; kwargs...)
invoke(f, argtypes::CodeInstance, args...; kwargs...)
```

Invoke a method for the given generic function `f` matching the specified types `argtypes` on the specified arguments `args` and passing the keyword arguments `kwargs`. The arguments `args` must conform with the specified types in `argtypes`, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function). However, because this means the runtime must do more work, `invoke` is generally also slower–sometimes significantly so–than doing normal dispatch with a regular call.

Be careful when using `invoke` for functions that you don't write. What definition is used for given `argtypes` is an implementation detail unless the function is explicitly states that calling with certain `argtypes` is a part of public API.  For example, the change between `f1` and `f2` in the example below is usually considered compatible because the change is invisible by the caller with a normal (non-`invoke`) call.  However, the change is visible if you use `invoke`.

# Passing a `Method` instead of a signature

The `argtypes` argument may be a `Method`, in which case the ordinary method table lookup is bypassed entirely and the given method is invoked directly. Needing this feature is uncommon. Note in particular that the specified `Method` may be entirely unreachable from ordinary dispatch (or ordinary invoke), e.g. because it was replaced or fully covered by more specific methods. If the method is part of the ordinary method table, this call behaves similar to `invoke(f, method.sig, args...)`.

!!! compat "Julia 1.12"
    Passing a `Method` requires Julia 1.12.


# Passing a `CodeInstance` instead of a signature

The `argtypes` argument may be a `CodeInstance`, bypassing both method lookup and specialization. The semantics of this invocation are similar to a function pointer call of the `CodeInstance`'s `invoke` pointer. It is an error to invoke a `CodeInstance` with arguments that do not match its parent `MethodInstance` or from a world age not included in the `min_world`/`max_world` range. It is undefined behavior to invoke a `CodeInstance` whose behavior does not match the constraints specified in its fields. For some code instances with `owner !== nothing` (i.e. those generated by external compilers), it may be an error to invoke them after passing through precompilation. This is an advanced interface intended for use with external compiler plugins.

!!! compat "Julia 1.12"
    Passing a `CodeInstance` requires Julia 1.12.


# Examples

```jldoctest
julia> f(x::Real) = x^2;

julia> f(x::Integer) = 1 + invoke(f, Tuple{Real}, x);

julia> f(2)
5

julia> f1(::Integer) = Integer
       f1(::Real) = Real;

julia> f2(x::Real) = _f2(x)
       _f2(::Integer) = Integer
       _f2(_) = Real;

julia> f1(1)
Integer

julia> f2(1)
Integer

julia> invoke(f1, Tuple{Real}, 1)
Real

julia> invoke(f2, Tuple{Real}, 1)
Integer
```
