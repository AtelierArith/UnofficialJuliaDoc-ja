```julia
unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)
```

ポインタによって与えられたアドレスのデータの周りにJulia `Array`オブジェクトをラップしますが、コピーは作成しません。ポインタ要素型 `T` は配列要素型を決定します。 `dims` は整数（1次元配列の場合）または配列の次元のタプルです。 `own` はオプションで、配列がもはや参照されなくなったときにポインタに対して `free` を呼び出すことで、Juliaがメモリの所有権を持つべきかどうかを指定します。

この関数は「unsafe」とラベル付けされています。なぜなら、`pointer` が要求された長さのデータに対する有効なメモリアドレスでない場合、クラッシュするからです。 [`unsafe_load`](@ref) や [`unsafe_store!`](@ref) とは異なり、プログラマーは、Cの厳密なエイリアス規則に似て、異なる要素型の2つの配列を介して基礎データにアクセスされないことを保証する責任があります。
