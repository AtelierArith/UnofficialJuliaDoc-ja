```julia
==(x, y)
```

汎用等価演算子。[`===`](@ref)にフォールバックします。等価性の概念を持つすべての型に対して実装されるべきです。例えば、すべての数値型は型を無視して数値として比較されます。文字列はエンコーディングを無視して文字のシーケンスとして比較されます。同じ型のコレクションは一般的にキーセットを比較し、それらが`==`であれば、各キーの値を比較し、すべてのペアが`==`であればtrueを返します。他のプロパティは通常考慮されません（例えば、正確な型など）。

この演算子は浮動小数点数に対してIEEEのセマンティクスに従います：`0.0 == -0.0`および`NaN != NaN`。

結果は`Bool`型ですが、オペランドの一方が[`missing`](@ref)である場合は`missing`が返されます（[三値論理](https://en.wikipedia.org/wiki/Three-valued_logic)）。コレクションは一般的に[`all`](@ref)に似た三値論理を実装し、いずれかのオペランドにmissing値が含まれている場合はmissingを返し、他のすべてのペアが等しい場合にのみ等しいと見なします。常に`Bool`の結果を得るには[`isequal`](@ref)または[`===`](@ref)を使用してください。

# 実装

新しい数値型は、この関数を新しい型の2つの引数に対して実装し、可能な限り昇格ルールを介して他の型との比較を処理するべきです。

等価性とハッシュは密接に関連しています；[`isequal`](@ref)と見なされる2つの値は**必ず**同じ[`hash`](@ref)を持ち、デフォルトでは`isequal`は`==`にフォールバックします。型が`==`および/または[`isequal`](@ref)の動作をカスタマイズする場合、[`hash`](@ref)も同様に実装され、`isequal`と`hash`が一致することを保証する必要があります。`Set`、`Dict`、および多くの他の内部実装は、この不変条件が成り立つことを前提としています。

もしある型が`==`、[`isequal`](@ref)、および[`isless`](@ref）を定義している場合、比較の一貫性を確保するために[`<`](@ref)も実装するべきです。
