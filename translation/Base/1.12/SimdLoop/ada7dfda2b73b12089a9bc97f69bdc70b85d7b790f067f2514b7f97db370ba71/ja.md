```julia
@simd
```

`@simd for` ループで反復されるオブジェクトは、一次元の範囲である必要があります。 `@simd` を使用することで、ループのいくつかの特性を主張しています：

  * 繰り返しを任意または重複した順序で実行することが安全であり、特に還元変数に関して考慮されます。
  * 還元変数に対する浮動小数点演算は再配置または収束させることができ、`@simd` を使用しない場合とは異なる結果を引き起こす可能性があります。

多くの場合、Julia は `@simd` を使用せずに内部の for ループを自動的にベクトル化することができます。 `@simd` を使用することで、コンパイラはより多くの状況でそれを可能にするための少し余裕を持つことができます。いずれの場合でも、内部ループはベクトル化を許可するために次の特性を持っている必要があります：

  * ループは最も内側のループでなければなりません。
  * ループ本体は直線的なコードでなければなりません。したがって、[`@inbounds`](@ref) はすべての配列アクセスに現在必要です。コンパイラは、すべてのオペランドを無条件に評価することが安全である場合、短い `&&`、`||`、および `?:` の式を直線的なコードに変換することがあります。ループ内で安全に行える場合は、`?:` の代わりに [`ifelse`](@ref) 関数を使用することを検討してください。
  * アクセスはストライドパターンを持っている必要があり、「ギャザー」（ランダムインデックスの読み取り）や「スキャッター」（ランダムインデックスの書き込み）であってはなりません。
  * ストライドは単位ストライドである必要があります。

!!! note
    `@simd` はデフォルトでループがループキャリードメモリ依存性から完全に自由であることを主張しません。これは、一般的なコードでは簡単に違反される仮定です。非一般的なコードを書いている場合は、`@simd ivdep for ... end` を使用して、次のことも主張できます：


  * ループキャリードメモリ依存性は存在しない
  * どの反復も、前の反復が前進するのを待つことはありません。
