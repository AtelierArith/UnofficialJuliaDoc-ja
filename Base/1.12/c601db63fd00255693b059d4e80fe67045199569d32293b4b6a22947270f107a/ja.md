```julia
IndexCartesian()
```

[`IndexStyle`](@ref) のサブタイプで、Cartesianインデックスによって最適にインデックス付けされる配列を説明するために使用されます。これは新しいカスタム [`AbstractArray`](@ref) サブタイプのデフォルトです。

Cartesianインデックススタイルは、複数の整数インデックスを使用して多次元配列内の位置を説明し、各次元に対して正確に1つのインデックスを持ちます。これは、`IndexCartesian` の配列から [`eachindex`](@ref) を要求すると、[`CartesianIndices`](@ref) の範囲が返されることを意味します。

`IndexStyle` を `IndexCartesian` として報告する `N` 次元のカスタム配列は、正確に `N` の `Int` インデックスでインデックス付け（およびインデックス付き代入）を実装する必要があります。他のすべてのインデックス式 — 線形インデックスを含む — は、同等のCartesian位置に再計算されます。たとえば、`A` がCartesianインデックスを持つ `2×3` のカスタム行列であり、`A[5]` を参照した場合、これは同等のCartesianインデックスに再計算され、`A[1, 3]` が呼び出されます。なぜなら、`5 = 1 + 2*(3 - 1)` だからです。

線形インデックスからCartesianインデックスを計算するのは、逆に行くよりもはるかに高コストです。前者の操作は割り算を必要とし — 非常にコストのかかる操作 — 後者は乗算と加算のみを使用し、基本的に無料です。この非対称性は、`IndexCartesian` 配列で線形インデックスを使用することが、`IndexLinear` 配列でCartesianインデックスを使用することよりもはるかに高コストであることを意味します。

[`IndexLinear`](@ref) も参照してください。
