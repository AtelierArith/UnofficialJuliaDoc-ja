```julia
__has_internal_change(version_or::VersionNumber, change_name::Symbol)
```

一部のJuliaパッケージは、Juliaの内部に依存していることが知られています（例：内部のJuliaデータ構造のイントロスペクションのため）。このようなパッケージとJuliaの共同開発を容易にするために、`change_name`が最善の努力に基づいて、または明示的に要求された場合に割り当てられます。この`change_name`は、特定のプレリリースビルドのJuliaに特定の変更があるかどうかを調べるために使用できます。特に、この関数は、`version_or`のために予定されている変更が現在のJuliaビルドに存在するかどうかをテストします。これは、現在のバージョンが`version_or`よりも大きい場合、または変更を含むプレリリースビルドを実行している場合です。

このメカニズムを使用することは、コミット番号ベースの`VERSION`比較の優れた代替手段であり、プレリリース段階で複数のアクティブに開発されているブランチがある場合に脆弱になる可能性があります。

変更のリストは、リリースプロセス中に2回クリアされます：

1. 最初のアルファのリリース時
2. 最初のリリース候補のため

リリース候補やバグ修正リリース中に新しい`change_name`は追加されません（したがって、特にリリースされたバージョンでは、変更のリストは空になり、`__has_internal_change`は常にバージョン比較と同等になります）。

# 例

Juliaバージョン`v"1.12.0-DEV.173"`は、行番号デバッグ情報の内部表現を変更しました。いくつかのデバッグパッケージは、この情報を表示するためのカスタムコードを持っており、それに応じて変更する必要があります。以前の慣行では、これはしばしば次のようなもので達成されていました。

```julia
@static if VERSION > v"1.12.0-DEV.173"
    # 新しいフォーマットを処理するためのコード
else
    # 古いフォーマットを処理するためのコード
end
```

しかし、そのようなチェックはVERSION番号が割り当てられるまで導入できないため（これにより自動的にすべてのナイトリーユーザーに変更がプッシュされます）、内蔵の破損期間がありました。`__has_internal_change`を使用すると、代わりに次のように書くことができます。

```julia
@static if __has_internal_change(v"1.12-alpha", :invertedlinenames)
    # 新しいフォーマットを処理するためのコード
else
    # 古いフォーマットを処理するためのコード
end
```

最初の引数として使用する正しいバージョンを見つけるには、`Base.__next_removal_version`を使用できます。これは、変更のリストがクリアされる次のバージョン番号に設定されています。

このアプローチの主な利点は、パッケージの新しいバージョンをナイトリービルドの破損の*前に*タグ付けしてリリースできるため、ナイトリーユーザーのパッケージ操作の継続性が確保されることです。

!!! warning
    この機能は、内部のJulia機能を利用するパッケージ開発者を支援することを目的としています。絶対に必要な場合を除き、これを行うことは明示的に推奨されておらず、パッケージが壊れることを明示的に理解した上で行われます。特に、これは一般的な機能テストメカニズムではなく、Juliaの内部に依存するパッケージを壊すことが知られている（または発見された）変更のための単純な礼儀的調整メカニズムです。

