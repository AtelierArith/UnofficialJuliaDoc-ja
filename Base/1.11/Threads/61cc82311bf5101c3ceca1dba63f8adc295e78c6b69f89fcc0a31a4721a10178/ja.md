```
Threads.@threads [schedule] for ... end
```

`for` ループを並列に実行するためのマクロです。反復空間は粗粒度のタスクに分配されます。このポリシーは `schedule` 引数によって指定できます。ループの実行は、すべての反復の評価が完了するまで待機します。

参照: [`@spawn`](@ref Threads.@spawn) および [`Distributed`](@ref man-distributed) の `pmap`。

# 拡張ヘルプ

## セマンティクス

スケジューリングオプションによってより強力な保証が指定されない限り、`@threads` マクロによって実行されるループは以下のセマンティクスを持ちます。

`@threads` マクロは、ループ本体を不特定の順序で、かつ潜在的に同時に実行します。タスクとワーカースレッドの正確な割り当ては指定されていません。割り当ては各実行ごとに異なる場合があります。ループ本体のコード（それから遷移的に呼び出されるコードを含む）は、タスクへの反復の分配や、それらが実行されるワーカースレッドについての仮定をしてはいけません。各反復のループ本体は、他の反復に依存せずに前進することができ、データ競合から解放されている必要があります。そのため、反復間での無効な同期はデッドロックを引き起こす可能性があり、同期されていないメモリアクセスは未定義の動作を引き起こす可能性があります。

例えば、上記の条件は以下を示唆します：

  * 反復内で取得されたロックは、同じ反復内で解放されなければなりません。
  * `Channel` のようなブロッキングプリミティブを使用して反復間で通信することは不正です。
  * 反復間で共有されていない場所にのみ書き込みを行います（ロックまたはアトミック操作が使用されていない限り）。
  * `:static` スケジュールが使用されない限り、[`threadid()`](@ref Threads.threadid) の値は単一の反復内でも変わる可能性があります。[`Task Migration`](@ref man-task-migration) を参照してください。

## スケジューラ

スケジューラ引数がない場合、正確なスケジューリングは指定されておらず、Julia のリリースによって異なります。現在、スケジューラが指定されていない場合は `:dynamic` が使用されます。

!!! compat "Julia 1.5"
    `schedule` 引数は Julia 1.5 以降で利用可能です。


### `:dynamic` (デフォルト)

`:dynamic` スケジューラは、利用可能なワーカースレッドに対して反復を動的に実行します。現在の実装は、各反復の作業負荷が均一であると仮定しています。ただし、この仮定は将来的に削除される可能性があります。

このスケジューリングオプションは、基盤となる実行メカニズムへの単なるヒントです。ただし、いくつかの特性が期待できます。`:dynamic` スケジューラによって使用される `Task` の数は、利用可能なワーカースレッドの数の小さな定数倍に制限されています（[`Threads.threadpoolsize()`](@ref)）。各タスクは反復空間の連続した領域を処理します。したがって、`@threads :dynamic for x in xs; f(x); end` は、`length(xs)` がワーカースレッドの数よりも大幅に大きく、`f(x)` の実行時間がタスクの生成と同期のコスト（通常は 10 マイクロ秒未満）よりも相対的に小さい場合、通常は `@sync for x in xs; @spawn f(x); end` よりも効率的です。

!!! compat "Julia 1.8"
    `schedule` 引数の `:dynamic` オプションは Julia 1.8 以降で利用可能で、デフォルトです。


### `:greedy`

`:greedy` スケジューラは、[`Threads.threadpoolsize()`](@ref) タスクを生成し、各タスクは生成される反復値に貪欲に取り組みます。1 つのタスクが作業を終えると、次の値をイテレータから取得します。個々のタスクが行う作業は、必ずしもイテレータからの連続した値に対して行われるわけではありません。与えられたイテレータは永遠に値を生成する可能性があり、イテレータインターフェースのみが必要です（インデックス付けは不要です）。

このスケジューリングオプションは、個々の反復の作業負荷が均一でない/大きなばらつきがある場合に一般的に良い選択です。

!!! compat "Julia 1.11"
    `schedule` 引数の `:greedy` オプションは Julia 1.11 以降で利用可能です。


### `:static`

`:static` スケジューラは、スレッドごとに 1 つのタスクを作成し、反復を均等に分割し、各タスクを特定のスレッドに割り当てます。特に、[`threadid()`](@ref Threads.threadid) の値は 1 つの反復内で一定であることが保証されています。別の `@threads` ループ内または 1 以外のスレッドから使用する場合、`:static` を指定することはエラーです。

!!! note
    `:static` スケジューリングは、Julia 1.3 より前に書かれたコードの移行をサポートするために存在します。新しく書かれたライブラリ関数では、`:static` スケジューリングは推奨されません。このオプションを使用する関数は、任意のワーカースレッドから呼び出すことができないためです。


## 例

異なるスケジューリング戦略を示すために、指定された秒数間実行される非待機のタイムループを含む次の関数 `busywait` を考えます。

```julia-repl
julia> function busywait(seconds)
            tstart = time_ns()
            while (time_ns() - tstart) / 1e9 < seconds
            end
        end

julia> @time begin
            Threads.@spawn busywait(5)
            Threads.@threads :static for i in 1:Threads.threadpoolsize()
                busywait(1)
            end
        end
6.003001 seconds (16.33 k allocations: 899.255 KiB, 0.25% compilation time)

julia> @time begin
            Threads.@spawn busywait(5)
            Threads.@threads :dynamic for i in 1:Threads.threadpoolsize()
                busywait(1)
            end
        end
2.012056 seconds (16.05 k allocations: 883.919 KiB, 0.66% compilation time)
```

`:dynamic` の例は 2 秒かかります。なぜなら、占有されていないスレッドの 1 つが 1 秒の反復を 2 回実行して for ループを完了できるからです。 ```
