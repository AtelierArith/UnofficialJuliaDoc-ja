```
to_indices(A, I::Tuple)
```

タプル `I` を配列 `A` にインデックスを付けるためのインデックスのタプルに変換します。

返されるタプルは、配列 `A` によってサポートされるスカラーインデックスの `Int` または `AbstractArray` のいずれかのみを含む必要があります。処理できない新しいインデックスタイプに遭遇するとエラーが発生します。

単純なインデックスタイプの場合、各インデックス `i` を処理するためにエクスポートされていない `Base.to_index(A, i)` に委ねます。この内部関数は直接呼び出すことを意図していませんが、カスタム配列やインデックスタイプによって `Base.to_index` を拡張してカスタムインデクシング動作を提供することができます。

より複雑なインデックスタイプは、インデックスする次元に関するより多くのコンテキストを必要とする場合があります。それらのケースをサポートするために、`to_indices(A, I)` は `to_indices(A, axes(A), I)` を呼び出し、与えられたインデックスのタプルと `A` の次元インデックスを同時に再帰的に歩きます。そのため、すべてのインデックスタイプが `Base.to_index` に伝播することが保証されているわけではありません。

# 例

```jldoctest
julia> A = zeros(1,2,3,4);

julia> to_indices(A, (1,1,2,2))
(1, 1, 2, 2)

julia> to_indices(A, (1,1,2,20)) # 境界チェックなし
(1, 1, 2, 20)

julia> to_indices(A, (CartesianIndex((1,)), 2, CartesianIndex((3,4)))) # エキゾチックなインデックス
(1, 2, 3, 4)

julia> to_indices(A, ([1,1], 1:2, 3, 4))
([1, 1], 1:2, 3, 4)

julia> to_indices(A, (1,2)) # 形状チェックなし
(1, 2)
```
