```
==(x, y)
```

汎用等価演算子。[`===`](@ref)にフォールバックします。等価性の概念を持つすべての型に対して実装されるべきです。これは、インスタンスが表す抽象的な値に基づいています。たとえば、すべての数値型は型を無視して数値で比較されます。文字列はエンコーディングを無視して文字のシーケンスとして比較されます。同じ型のコレクションは一般的にキーセットを比較し、それらが`==`であれば、各キーの値を比較し、すべてのペアが`==`であればtrueを返します。他のプロパティは通常考慮されません（例えば、正確な型など）。

この演算子は浮動小数点数に対してIEEEのセマンティクスに従います：`0.0 == -0.0`および`NaN != NaN`。

結果は`Bool`型ですが、オペランドの一方が[`missing`](@ref)である場合は`missing`が返されます（[三値論理](https://en.wikipedia.org/wiki/Three-valued_logic)）。コレクションは一般的に[`all`](@ref)に似た三値論理を実装し、いずれかのオペランドにmissing値が含まれている場合はmissingを返し、他のすべてのペアが等しい場合にのみ等しいと見なします。常に`Bool`型の結果を得るには、[`isequal`](@ref)または[`===`](@ref)を使用してください。

# 実装

新しい数値型は、この関数を新しい型の2つの引数に対して実装し、可能な限り昇格ルールを介して他の型との比較を処理するべきです。

[`isequal`](@ref)は`==`にフォールバックするため、`==`の新しいメソッドは[`Dict`](@ref)型によってキーを比較するために使用されます。あなたの型が辞書のキーとして使用される場合、それはしたがって[`hash`](@ref)も実装するべきです。

もしある型が`==`、[`isequal`](@ref)、および[`isless`](@ref)を定義している場合、それは比較の一貫性を確保するために[`<`](@ref)も実装するべきです。
