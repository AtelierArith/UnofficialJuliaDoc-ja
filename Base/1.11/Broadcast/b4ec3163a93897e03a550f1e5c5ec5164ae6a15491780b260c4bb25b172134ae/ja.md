```
broadcast(f, As...)
```

関数 `f` を配列、タプル、コレクション、[`Ref`](@ref)s および/またはスカラー `As` に対してブロードキャストします。

ブロードキャスティングは、コンテナ引数の要素と `As` 内のスカラー自体に対して関数 `f` を適用します。シングルトンおよび欠損次元は、他の引数の範囲に一致するように値を仮想的に繰り返すことで拡張されます。デフォルトでは、スカラーと見なされる型は限られており、`Number`、`String`、`Symbol`、`Type`、`Function` および [`missing`](@ref) や [`nothing`](@ref) のような一般的なシングルトンが含まれます。他のすべての引数は要素ごとに反復処理されるか、インデックス指定されます。

結果のコンテナ型は、以下のルールによって決定されます：

  * すべての引数がスカラーまたはゼロ次元配列である場合、アンラップされたスカラーを返します。
  * 1つ以上の引数がタプルであり、他のすべてがスカラーまたはゼロ次元配列である場合、タプルを返します。
  * 他のすべての引数の組み合わせは `Array` を返すのがデフォルトですが、カスタムコンテナ型は、引数として現れたときに結果をカスタマイズするために独自の実装および昇格のようなルールを定義できます。

ブロードキャスティングのための特別な構文があります：`f.(args...)` は `broadcast(f, args...)` と同等であり、ネストされた `f.(g.(args...))` 呼び出しは単一のブロードキャストループに融合されます。

# 例

```jldoctest
julia> A = [1, 2, 3, 4, 5]
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia> B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Matrix{Int64}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia> broadcast(+, A, B)
5×2 Matrix{Int64}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia> parse.(Int, ["1", "2"])
2-element Vector{Int64}:
 1
 2

julia> abs.((1, -2))
(1, 2)

julia> broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia> (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Vector{Vector{Int64}}:
 [1, 1]
 [2, 2]

julia> string.(("one","two","three","four"), ": ", 1:4)
4-element Vector{String}:
 "one: 1"
 "two: 2"
 "three: 3"
 "four: 4"

```
