<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calling C and Fortran Code · The Julia Language</title><meta name="title" content="Calling C and Fortran Code · The Julia Language"/><meta property="og:title" content="Calling C and Fortran Code · The Julia Language"/><meta property="twitter:title" content="Calling C and Fortran Code · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="variables.html">Variables</a></li><li><a class="tocitem" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="functions.html">Functions</a></li><li><a class="tocitem" href="control-flow.html">Control Flow</a></li><li><a class="tocitem" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="types.html">Types</a></li><li><a class="tocitem" href="methods.html">Methods</a></li><li><a class="tocitem" href="constructors.html">Constructors</a></li><li><a class="tocitem" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li><a class="tocitem" href="modules.html">Modules</a></li><li><a class="tocitem" href="documentation.html">Documentation</a></li><li><a class="tocitem" href="metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="missing.html">Missing Values</a></li><li><a class="tocitem" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="running-external-programs.html">Running External Programs</a></li><li class="is-active"><a class="tocitem" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a><ul class="internal"><li><a class="tocitem" href="#Creating-C-Compatible-Julia-Function-Pointers"><span>Creating C-Compatible Julia Function Pointers</span></a></li><li><a class="tocitem" href="#mapping-c-types-to-julia"><span>Mapping C Types to Julia</span></a></li><li><a class="tocitem" href="#Mapping-C-Functions-to-Julia"><span>Mapping C Functions to Julia</span></a></li><li><a class="tocitem" href="#C-Wrapper-Examples"><span>C Wrapper Examples</span></a></li><li><a class="tocitem" href="#Fortran-Wrapper-Example"><span>Fortran Wrapper Example</span></a></li><li><a class="tocitem" href="#Garbage-Collection-Safety"><span>Garbage Collection Safety</span></a></li><li><a class="tocitem" href="#Non-constant-Function-Specifications"><span>Non-constant Function Specifications</span></a></li><li><a class="tocitem" href="#Indirect-Calls"><span>Indirect Calls</span></a></li><li><a class="tocitem" href="#Closure-cfunctions"><span>Closure cfunctions</span></a></li><li><a class="tocitem" href="#Closing-a-Library"><span>Closing a Library</span></a></li><li><a class="tocitem" href="#Variadic-function-calls"><span>Variadic function calls</span></a></li><li><a class="tocitem" href="#ccall-interface"><span><code>ccall</code> interface</span></a></li><li><a class="tocitem" href="#calling-convention"><span>Calling Convention</span></a></li><li><a class="tocitem" href="#Accessing-Global-Variables"><span>Accessing Global Variables</span></a></li><li><a class="tocitem" href="#Accessing-Data-through-a-Pointer"><span>Accessing Data through a Pointer</span></a></li><li><a class="tocitem" href="#Thread-safety"><span>Thread-safety</span></a></li><li><a class="tocitem" href="#More-About-Callbacks"><span>More About Callbacks</span></a></li><li><a class="tocitem" href="#C"><span>C++</span></a></li></ul></li><li><a class="tocitem" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="code-loading.html">Code Loading</a></li><li><a class="tocitem" href="profile.html">Profiling</a></li><li><a class="tocitem" href="stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="style-guide.html">Style Guide</a></li><li><a class="tocitem" href="faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Calling-C-and-Fortran-Code"><a class="docs-heading-anchor" href="#Calling-C-and-Fortran-Code">Calling C and Fortran Code</a><a id="Calling-C-and-Fortran-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-C-and-Fortran-Code" title="Permalink"></a></h1><p>ほとんどのコードはJuliaで書くことができますが、すでにCやFortranで書かれた高品質で成熟した数値計算用のライブラリが多数存在します。この既存のコードを簡単に利用できるように、JuliaはCおよびFortranの関数を呼び出すのを簡単かつ効率的にします。Juliaは「ボイラープレートなし」の哲学を持っています：関数は「グルー」コード、コード生成、またはコンパイルなしで、直接Juliaから呼び出すことができます - インタラクティブプロンプトからでも同様です。これは、適切な呼び出しを<a href="../base/c.html#Base.@ccall"><code>@ccall</code></a>マクロ（または、あまり便利ではない<a href="../base/c.html#ccall"><code>ccall</code></a>構文、詳細は<a href="calling-c-and-fortran-code.html#ccall-interface"><code>ccall</code> syntax section</a>を参照）を使うことで実現されます。</p><p>呼び出されるコードは、共有ライブラリとして利用可能でなければなりません。ほとんどのCおよびFortranライブラリは、すでに共有ライブラリとしてコンパイルされて出荷されますが、GCC（またはClang）を使用して自分でコードをコンパイルする場合は、<code>-shared</code>および<code>-fPIC</code>オプションを使用する必要があります。JuliaのJITによって生成される機械命令は、ネイティブC呼び出しと同じであるため、結果としてのオーバーヘッドはCコードからライブラリ関数を呼び出すのと同じです。 <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>デフォルトでは、Fortran コンパイラは <a href="https://en.wikipedia.org/wiki/Name_mangling#Fortran">generate mangled names</a> （例えば、関数名を小文字または大文字に変換し、しばしばアンダースコアを追加します）を使用します。そのため、Fortran 関数を呼び出すには、使用している Fortran コンパイラによって従われるルールに対応するマングルされた識別子を渡す必要があります。また、Fortran 関数を呼び出す際には、すべての入力をヒープまたはスタック上の割り当てられた値へのポインタとして渡す必要があります。これは、通常ヒープに割り当てられる配列や他の可変オブジェクトだけでなく、通常スタックに割り当てられ、C や Julia の呼び出し規約を使用する際に一般的にレジスタに渡される整数や浮動小数点数などのスカラー値にも適用されます。</p><p><a href="../base/c.html#Base.@ccall"><code>@ccall</code></a>を使用してライブラリ関数を呼び出すための構文は次のとおりです：</p><pre><code class="language-julia hljs">  @ccall library.function_name(argvalue1::argtype1, ...)::returntype
  @ccall function_name(argvalue1::argtype1, ...)::returntype
  @ccall $function_pointer(argvalue1::argtype1, ...)::returntype</code></pre><p><code>library</code> は文字列定数またはリテラルです（ただし、以下の <a href="calling-c-and-fortran-code.html#Non-constant-Function-Specifications">Non-constant Function Specifications</a> を参照してください）。ライブラリは省略可能で、その場合、関数名は現在のプロセスで解決されます。この形式は、Cライブラリ関数、Juliaランタイム内の関数、またはJuliaにリンクされたアプリケーション内の関数を呼び出すために使用できます。ライブラリへのフルパスも指定できます。あるいは、<code>@ccall</code> を使用して、<code>Libdl.dlsym</code> によって返されるような関数ポインタ <code>$function_pointer</code> を呼び出すこともできます。<code>argtype</code> はC関数のシグネチャに対応し、<code>argvalue</code> は関数に渡される実際の引数値です。</p><div class="admonition is-info" id="Note-ab8a33bf2dc9f978"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ab8a33bf2dc9f978" title="Permalink"></a></header><div class="admonition-body"><p>以下は、<a href="calling-c-and-fortran-code.html#mapping-c-types-to-julia">map C types to Julia types</a>の方法です。</p></div></div><p>完全でありながらシンプルな例として、以下はほとんどのUnix系システムの標準Cライブラリから<code>clock</code>関数を呼び出します：</p><pre><code class="language-julia-repl hljs">julia&gt; t = @ccall clock()::Int32
2292761

julia&gt; typeof(t)
Int32</code></pre><p><code>clock</code> は引数を取らず、<code>Int32</code> を返します。環境変数の値へのポインタを取得するために <code>getenv</code> 関数を呼び出すには、次のように呼び出します:</p><pre><code class="language-julia-repl hljs">julia&gt; path = @ccall getenv(&quot;SHELL&quot;::Cstring)::Cstring
Cstring(@0x00007fff5fbffc45)

julia&gt; unsafe_string(path)
&quot;/bin/bash&quot;</code></pre><p>実際には、特に再利用可能な機能を提供する際に、一般的に <code>@ccall</code> の使用を引数を設定し、その後CまたはFortran関数が指定する方法でエラーをチェックするJulia関数にラップします。そして、エラーが発生した場合は、通常のJulia例外としてスローされます。これは特に重要です。なぜなら、CおよびFortranのAPIはエラー条件を示す方法が非常に一貫性がないからです。例えば、<code>getenv</code> Cライブラリ関数は、以下のJulia関数にラップされています。これは、<a href="https://github.com/JuliaLang/julia/blob/master/base/env.jl"><code>env.jl</code></a>からの実際の定義の簡略版です。</p><pre><code class="language-julia hljs">function getenv(var::AbstractString)
    val = @ccall getenv(var::Cstring)::Cstring
    if val == C_NULL
        error(&quot;getenv: undefined variable: &quot;, var)
    end
    return unsafe_string(val)
end</code></pre><p>Cの<code>getenv</code>関数は、<code>C_NULL</code>を返すことでエラーを示しますが、他の標準C関数は、-1、0、1、その他の特別な値を返すなど、異なる方法でエラーを示します。このラッパーは、呼び出し元が存在しない環境変数を取得しようとした場合に、問題を示す例外をスローします：</p><pre><code class="language-julia-repl hljs">julia&gt; getenv(&quot;SHELL&quot;)
&quot;/bin/bash&quot;

julia&gt; getenv(&quot;FOOBAR&quot;)
ERROR: getenv: undefined variable: FOOBAR</code></pre><p>ここに、ローカルマシンのホスト名を発見する少し複雑な例があります。</p><pre><code class="language-julia hljs">function gethostname()
    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN
    err = @ccall gethostname(hostname::Ptr{UInt8}, sizeof(hostname)::Csize_t)::Int32
    Base.systemerror(&quot;gethostname&quot;, err != 0)
    hostname[end] = 0 # ensure null-termination
    return GC.@preserve hostname unsafe_string(pointer(hostname))
end</code></pre><p>この例では、最初にバイトの配列を割り当てます。次に、Cライブラリ関数<code>gethostname</code>を呼び出して、配列にホスト名を格納します。最後に、ホスト名バッファへのポインタを取得し、そのポインタをヌル終端のC文字列であると仮定してJuliaの文字列に変換します。</p><p>Cライブラリが呼び出し元にメモリを割り当てさせ、それを呼び出し先に渡して populated させるというパターンを使用するのは一般的です。このようにしてJuliaからメモリを割り当てることは、未初期化の配列を作成し、そのデータへのポインタをC関数に渡すことで一般的に達成されます。これが、ここで<code>Cstring</code>型を使用しない理由です：配列が未初期化であるため、ヌルバイトを含む可能性があります。<code>@ccall</code>の一部として<code>Cstring</code>に変換すると、含まれているヌルバイトをチェックし、そのため変換エラーが発生する可能性があります。</p><p><code>unsafe_string</code>を使って<code>pointer(hostname)</code>を逆参照することは、安全でない操作です。これは、<code>hostname</code>に割り当てられたメモリにアクセスする必要があり、そのメモリがその間にガーベジコレクションされている可能性があるためです。マクロ<a href="../base/base.html#Base.GC.@preserve"><code>GC.@preserve</code></a>は、これが発生するのを防ぎ、無効なメモリ位置へのアクセスを防ぎます。</p><p>最後に、パスを指定してライブラリを指定する例を示します。次の内容で共有ライブラリを作成します。</p><pre><code class="language-c hljs">#include &lt;stdio.h&gt;

void say_y(int y)
{
    printf(&quot;Hello from C: got y = %d.\n&quot;, y);
}</code></pre><p><code>gcc -fPIC -shared -o mylib.so mylib.c</code> でコンパイルします。これにより、ライブラリ名として（絶対）パスを指定することで呼び出すことができます：</p><pre><code class="language-julia-repl hljs">julia&gt; @ccall &quot;./mylib.so&quot;.say_y(5::Cint)::Cvoid
Hello from C: got y = 5.</code></pre><h2 id="Creating-C-Compatible-Julia-Function-Pointers"><a class="docs-heading-anchor" href="#Creating-C-Compatible-Julia-Function-Pointers">Creating C-Compatible Julia Function Pointers</a><a id="Creating-C-Compatible-Julia-Function-Pointers-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-C-Compatible-Julia-Function-Pointers" title="Permalink"></a></h2><p>Juliaの関数を、関数ポインタ引数を受け入れるネイティブC関数に渡すことが可能です。例えば、次のようなCプロトタイプに一致させるために:</p><pre><code class="language-c hljs">typedef returntype (*functiontype)(argumenttype, ...)</code></pre><p>マクロ <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> は、Julia関数への呼び出しのためのC互換の関数ポインタを生成します。 <code>4d61726b646f776e2e436f64652822222c2022406366756e6374696f6e2229_40726566</code> の引数は次のとおりです：</p><ol><li>ジュリアの関数</li><li>関数の戻り値の型</li><li>関数シグネチャに対応する入力タイプのタプル</li></ol><div class="admonition is-info" id="Note-cbdcc9ef8245c63f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-cbdcc9ef8245c63f" title="Permalink"></a></header><div class="admonition-body"><p><code>@ccall</code>と同様に、戻り値の型と入力の型はリテラル定数でなければなりません。</p></div></div><div class="admonition is-info" id="Note-383662c3477be39a"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-383662c3477be39a" title="Permalink"></a></header><div class="admonition-body"><p>現在、プラットフォームデフォルトのC呼び出し規約のみがサポートされています。これは、<code>@cfunction</code>で生成されたポインタが、32ビットWindowsでWINAPIが<code>stdcall</code>関数を期待する呼び出しに使用できないことを意味しますが、WIN64では（<code>stdcall</code>がC呼び出し規約と統一されているため）使用できます。</p></div></div><div class="admonition is-info" id="Note-2cd357a9ccff409"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2cd357a9ccff409" title="Permalink"></a></header><div class="admonition-body"><p><code>@cfunction</code>を介して公開されるコールバック関数はエラーをスローしてはいけません。そうすると、制御が予期せずJuliaランタイムに戻り、プログラムが未定義の状態になる可能性があります。</p></div></div><p>標準Cライブラリの<code>qsort</code>関数の典型的な例は、次のように宣言されています：</p><pre><code class="language-c hljs">void qsort(void *base, size_t nitems, size_t size,
           int (*compare)(const void*, const void*));</code></pre><p><code>base</code> 引数は、各要素が <code>size</code> バイトの長さ <code>nitems</code> の配列へのポインタです。 <code>compare</code> はコールバック関数で、2 つの要素 <code>a</code> と <code>b</code> へのポインタを受け取り、<code>a</code> が <code>b</code> の前に出るべき場合はゼロ未満、後に出るべき場合はゼロより大きい整数を返します（または、任意の順序が許可される場合はゼロを返します）。</p><p>さて、1次元配列 <code>A</code> の値を持つJuliaで、<code>sort</code>関数ではなく<code>qsort</code>関数を使用してソートしたいとします。<code>qsort</code>を呼び出して引数を渡す前に、比較関数を書く必要があります。</p><pre><code class="language-julia-repl hljs">julia&gt; function mycompare(a, b)::Cint
           return (a &lt; b) ? -1 : ((a &gt; b) ? +1 : 0)
       end;</code></pre><p><code>qsort</code> は C の <code>int</code> を返す比較関数を期待するため、戻り値の型を <code>Cint</code> として注釈を付けます。</p><p>この関数をCに渡すために、マクロ<code>@cfunction</code>を使用してそのアドレスを取得します:</p><pre><code class="language-julia-repl hljs">julia&gt; mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));</code></pre><p><a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> は3つの引数を必要とします: Julia関数（<code>mycompare</code>）、戻り値の型（<code>Cint</code>）、および入力引数の型のリテラルタプル。この場合、<code>Cdouble</code>（<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>）要素の配列をソートするためのものです。</p><p>最終的な <code>qsort</code> の呼び出しは次のようになります:</p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.3, -2.7, 4.4, 3.1];

julia&gt; @ccall qsort(A::Ptr{Cdouble}, length(A)::Csize_t, sizeof(eltype(A))::Csize_t, mycompare_c::Ptr{Cvoid})::Cvoid

julia&gt; A
4-element Vector{Float64}:
 -2.7
  1.3
  3.1
  4.4</code></pre><p>例に示すように、元のJulia配列 <code>A</code> は現在ソートされています: <code>[-2.7, 1.3, 3.1, 4.4]</code>。Julia <a href="calling-c-and-fortran-code.html#automatic-type-conversion">takes care of converting the array to a <code>Ptr{Cdouble}</code></a>)、要素型のサイズをバイト単位で計算することなど。</p><p>楽しむために、<code>mycompare</code> に <code>println(&quot;mycompare($a, $b)&quot;)</code> 行を挿入してみてください。これにより、<code>qsort</code> が実行している比較を確認でき（実際に渡したJulia関数が呼び出されていることを確認するために）、デバッグに役立ちます。</p><h2 id="mapping-c-types-to-julia"><a class="docs-heading-anchor" href="#mapping-c-types-to-julia">Mapping C Types to Julia</a><a id="mapping-c-types-to-julia-1"></a><a class="docs-heading-anchor-permalink" href="#mapping-c-types-to-julia" title="Permalink"></a></h2><p>宣言されたC型とJuliaでの宣言を正確に一致させることが重要です。不一致があると、あるシステムで正しく動作するコードが別のシステムで失敗したり、不確定な結果を生じたりする可能性があります。</p><p>C関数を呼び出すプロセスでは、どこにもCヘッダーファイルは使用されていないことに注意してください。あなたは、Juliaの型と呼び出しシグネチャがCヘッダーファイルのものと正確に一致することを確認する責任があります。<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><h3 id="automatic-type-conversion"><a class="docs-heading-anchor" href="#automatic-type-conversion">Automatic Type Conversion</a><a id="automatic-type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#automatic-type-conversion" title="Permalink"></a></h3><p>Juliaは、各引数を指定された型に変換するために、<a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a>関数への呼び出しを自動的に挿入します。たとえば、次の呼び出し：</p><pre><code class="language-julia hljs">@ccall &quot;libfoo&quot;.foo(x::Int32, y::Float64)::Cvoid</code></pre><p>そのように書かれたかのように振る舞います:</p><pre><code class="language-julia hljs">c_x = Base.cconvert(Int32, x)
c_y = Base.cconvert(Float64, y)
GC.@preserve c_x c_y begin
    @ccall &quot;libfoo&quot;.foo(
        Base.unsafe_convert(Int32, c_x)::Int32,
        Base.unsafe_convert(Float64, c_y)::Float64
    )::Cvoid
end</code></pre><p><a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> は通常 <a href="../base/base.html#Base.convert"><code>convert</code></a> を呼び出しますが、Cに渡すのにより適した任意の新しいオブジェクトを返すように定義できます。これは、Cコードによってアクセスされるすべてのメモリの割り当てを行うために使用されます。例えば、これはオブジェクトの <code>Array</code>（例えば文字列）をポインタの配列に変換するために使用されます。</p><p><a href="../base/c.html#Base.unsafe_convert"><code>Base.unsafe_convert</code></a> は <a href="../base/c.html#Core.Ptr"><code>Ptr</code></a> タイプへの変換を処理します。これは、オブジェクトをネイティブポインタに変換することでガーベジコレクタからオブジェクトが隠され、早期に解放される可能性があるため、安全ではないと見なされます。</p><h3 id="Type-Correspondences"><a class="docs-heading-anchor" href="#Type-Correspondences">Type Correspondences</a><a id="Type-Correspondences-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Correspondences" title="Permalink"></a></h3><p>まず、関連するJuliaの型用語を確認しましょう：</p><table><tr><th style="text-align: left">Syntax / Keyword</th><th style="text-align: left">Example</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>mutable struct</code></td><td style="text-align: left"><code>BitSet</code></td><td style="text-align: left">&quot;Leaf Type&quot; :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no <code>TypeVars</code> are allowed) in order for the instance to be constructed.</td></tr><tr><td style="text-align: left"><code>abstract type</code></td><td style="text-align: left"><code>Any</code>, <code>AbstractArray{T, N}</code>, <code>Complex{T}</code></td><td style="text-align: left">&quot;Super Type&quot; :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.</td></tr><tr><td style="text-align: left"><code>T{A}</code></td><td style="text-align: left"><code>Vector{Int}</code></td><td style="text-align: left">&quot;Type Parameter&quot; :: A specialization of a type (typically used for dispatch or storage optimization).</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">&quot;TypeVar&quot; :: The <code>T</code> in the type parameter declaration is referred to as a TypeVar (short for type variable).</td></tr><tr><td style="text-align: left"><code>primitive type</code></td><td style="text-align: left"><code>Int</code>, <code>Float64</code></td><td style="text-align: left">&quot;Primitive Type&quot; :: A type with no fields, but a size. It is stored and defined by-value.</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left"><code>Pair{Int, Int}</code></td><td style="text-align: left">&quot;Struct&quot; :: A type with all fields defined to be constant. It is defined by-value, and may be stored with a type-tag.</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><code>ComplexF64</code> (<code>isbits</code>)</td><td style="text-align: left">&quot;Is-Bits&quot;   :: A <code>primitive type</code>, or a <code>struct</code> type where all fields are other <code>isbits</code> types. It is defined by-value, and is stored without a type-tag.</td></tr><tr><td style="text-align: left"><code>struct ...; end</code></td><td style="text-align: left"><code>nothing</code></td><td style="text-align: left">&quot;Singleton&quot; :: a Leaf Type or Struct with no fields.</td></tr><tr><td style="text-align: left"><code>(...)</code> or <code>tuple(...)</code></td><td style="text-align: left"><code>(1, 2, 3)</code></td><td style="text-align: left">&quot;Tuple&quot; :: an immutable data-structure similar to an anonymous struct type, or a constant array. Represented as either an array or a struct.</td></tr></table><h3 id="man-bits-types"><a class="docs-heading-anchor" href="#man-bits-types">Bits Types</a><a id="man-bits-types-1"></a><a class="docs-heading-anchor-permalink" href="#man-bits-types" title="Permalink"></a></h3><p>特別なタイプがいくつかあり、他のタイプが同じように振る舞うように定義されることはありません。</p><ul><li><p><code>Float32</code></p><p>C（またはFortranの<code>REAL*4</code>）の<code>float</code>型に正確に対応しています。</p></li><li><p><code>Float64</code></p><p>Cの<code>double</code>型（またはFortranの<code>REAL*8</code>）に正確に対応します。</p></li><li><p><code>ComplexF32</code></p><p>C言語の<code>complex float</code>型（またはFortranの<code>COMPLEX*8</code>）に正確に対応します。</p></li><li><p><code>ComplexF64</code></p><p>C言語の<code>complex double</code>型（またはFortranの<code>COMPLEX*16</code>）に正確に対応します。</p></li><li><p><code>署名済み</code></p><p><code>C</code>の<code>signed</code>型注釈（またはFortranの任意の<code>INTEGER</code>型）に正確に対応します。<a href="../base/numbers.html#Core.Signed"><code>Signed</code></a>のサブタイプでない任意のJulia型は、符号なしであると見なされます。</p></li><li><p><code>Ref{T}</code></p><p><code>Ptr{T}</code>のように振る舞い、JuliaのGCを介してメモリを管理できる。</p></li><li><p><code>Array{T,N}</code></p><p>配列がCに<code>Ptr{T}</code>引数として渡されるとき、それは再解釈キャストされません。Juliaは、配列の要素型が<code>T</code>と一致することを要求し、最初の要素のアドレスが渡されます。</p><p>したがって、<code>Array</code> にデータが誤った形式で含まれている場合は、<code>trunc.(Int32, A)</code> のような呼び出しを使用して明示的に変換する必要があります。</p><p>配列 <code>A</code> を異なる型のポインタとして <em>変換せずに</em> 渡すには（例えば、<code>Float64</code> 配列を解釈されていないバイトで動作する関数に渡す場合）、引数を <code>Ptr{Cvoid}</code> として宣言できます。</p><p>配列の要素型 <code>Ptr{T}</code> が <code>Ptr{Ptr{T}}</code> 引数として渡されると、<a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> は、最初に配列のヌル終端コピーを作成し、各要素をその <code>4d61726b646f776e2e436f64652822222c2022426173652e63636f6e766572742229_40726566</code> バージョンに置き換えようとします。これにより、例えば、<code>Vector{String}</code> 型の <code>argv</code> ポインタ配列を <code>Ptr{Ptr{Cchar}}</code> 型の引数に渡すことが可能になります。</p></li></ul><p>現在サポートしているすべてのシステムにおいて、基本的なC/C++の値型は次のようにJulia型に変換される可能性があります。すべてのC型には、同じ名前の対応するJulia型があり、Cでプレフィックスが付けられています。これは、ポータブルなコードを書く際に役立ちます（Cの<code>int</code>はJuliaの<code>Int</code>とは異なることを思い出すため）。</p><p><strong>システム独立型</strong></p><table><tr><th style="text-align: left">C name</th><th style="text-align: left">Fortran name</th><th style="text-align: left">Standard Julia Alias</th><th style="text-align: left">Julia Base Type</th></tr><tr><td style="text-align: left"><code>unsigned char</code></td><td style="text-align: left"><code>CHARACTER</code></td><td style="text-align: left"><code>Cuchar</code></td><td style="text-align: left"><code>UInt8</code></td></tr><tr><td style="text-align: left"><code>bool</code> (_Bool in C99+)</td><td style="text-align: left"></td><td style="text-align: left"><code>Cuchar</code></td><td style="text-align: left"><code>UInt8</code></td></tr><tr><td style="text-align: left"><code>short</code></td><td style="text-align: left"><code>INTEGER*2</code>, <code>LOGICAL*2</code></td><td style="text-align: left"><code>Cshort</code></td><td style="text-align: left"><code>Int16</code></td></tr><tr><td style="text-align: left"><code>unsigned short</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cushort</code></td><td style="text-align: left"><code>UInt16</code></td></tr><tr><td style="text-align: left"><code>int</code>, <code>BOOL</code> (C, typical)</td><td style="text-align: left"><code>INTEGER*4</code>, <code>LOGICAL*4</code></td><td style="text-align: left"><code>Cint</code></td><td style="text-align: left"><code>Int32</code></td></tr><tr><td style="text-align: left"><code>unsigned int</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cuint</code></td><td style="text-align: left"><code>UInt32</code></td></tr><tr><td style="text-align: left"><code>long long</code></td><td style="text-align: left"><code>INTEGER*8</code>, <code>LOGICAL*8</code></td><td style="text-align: left"><code>Clonglong</code></td><td style="text-align: left"><code>Int64</code></td></tr><tr><td style="text-align: left"><code>unsigned long long</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Culonglong</code></td><td style="text-align: left"><code>UInt64</code></td></tr><tr><td style="text-align: left"><code>intmax_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cintmax_t</code></td><td style="text-align: left"><code>Int64</code></td></tr><tr><td style="text-align: left"><code>uintmax_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cuintmax_t</code></td><td style="text-align: left"><code>UInt64</code></td></tr><tr><td style="text-align: left"><code>float</code></td><td style="text-align: left"><code>REAL*4i</code></td><td style="text-align: left"><code>Cfloat</code></td><td style="text-align: left"><code>Float32</code></td></tr><tr><td style="text-align: left"><code>double</code></td><td style="text-align: left"><code>REAL*8</code></td><td style="text-align: left"><code>Cdouble</code></td><td style="text-align: left"><code>Float64</code></td></tr><tr><td style="text-align: left"><code>complex float</code></td><td style="text-align: left"><code>COMPLEX*8</code></td><td style="text-align: left"><code>ComplexF32</code></td><td style="text-align: left"><code>Complex{Float32}</code></td></tr><tr><td style="text-align: left"><code>complex double</code></td><td style="text-align: left"><code>COMPLEX*16</code></td><td style="text-align: left"><code>ComplexF64</code></td><td style="text-align: left"><code>Complex{Float64}</code></td></tr><tr><td style="text-align: left"><code>ptrdiff_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cptrdiff_t</code></td><td style="text-align: left"><code>Int</code></td></tr><tr><td style="text-align: left"><code>ssize_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cssize_t</code></td><td style="text-align: left"><code>Int</code></td></tr><tr><td style="text-align: left"><code>size_t</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Csize_t</code></td><td style="text-align: left"><code>UInt</code></td></tr><tr><td style="text-align: left"><code>void</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Cvoid</code></td></tr><tr><td style="text-align: left"><code>void</code> and <code>[[noreturn]]</code> or <code>_Noreturn</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Union{}</code></td></tr><tr><td style="text-align: left"><code>void*</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ptr{Cvoid}</code> (or similarly <code>Ref{Cvoid}</code>)</td></tr><tr><td style="text-align: left"><code>T*</code> (where T represents an appropriately defined type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ref{T}</code> (T may be safely mutated only if T is an isbits type)</td></tr><tr><td style="text-align: left"><code>char*</code> (or <code>char[]</code>, e.g. a string)</td><td style="text-align: left"><code>CHARACTER*N</code></td><td style="text-align: left"></td><td style="text-align: left"><code>Cstring</code> if null-terminated, or <code>Ptr{UInt8}</code> if not</td></tr><tr><td style="text-align: left"><code>char**</code> (or <code>*char[]</code>)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ptr{Ptr{UInt8}}</code></td></tr><tr><td style="text-align: left"><code>jl_value_t*</code> (any Julia Type)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Any</code></td></tr><tr><td style="text-align: left"><code>jl_value_t* const*</code> (a reference to a Julia value)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>Ref{Any}</code> (const, since mutation would require a write barrier, which is not possible to insert correctly)</td></tr><tr><td style="text-align: left"><code>va_arg</code></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">Not supported</td></tr><tr><td style="text-align: left"><code>...</code> (variadic function specification)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>T...</code> (where <code>T</code> is one of the above types, when using the <code>ccall</code> function)</td></tr><tr><td style="text-align: left"><code>...</code> (variadic function specification)</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><code>; va_arg1::T, va_arg2::S, etc.</code> (only supported with <code>@ccall</code> macro)</td></tr></table><p><a href="../base/c.html#Base.Cstring"><code>Cstring</code></a> 型は、基本的に <code>Ptr{UInt8}</code> の同義語ですが、Julia の文字列に埋め込まれたヌル文字が含まれている場合、<code>Cstring</code> への変換はエラーをスローします（これは、C ルーチンがヌルを終端子として扱う場合、文字列が静かに切り捨てられることになります）。ヌル終端を仮定しない C ルーチンに <code>char*</code> を渡す場合（例えば、明示的な文字列の長さを渡す場合）や、Julia の文字列にヌルが含まれていないことが確実であり、チェックをスキップしたい場合は、引数の型として <code>Ptr{UInt8}</code> を使用できます。<code>Cstring</code> は <a href="../base/c.html#ccall"><code>ccall</code></a> の戻り値の型としても使用できますが、その場合は明らかに追加のチェックを導入せず、呼び出しの可読性を向上させるためだけに意図されています。</p><p><strong>システム依存型</strong></p><table><tr><th style="text-align: left">C name</th><th style="text-align: left">Standard Julia Alias</th><th style="text-align: left">Julia Base Type</th></tr><tr><td style="text-align: left"><code>char</code></td><td style="text-align: left"><code>Cchar</code></td><td style="text-align: left"><code>Int8</code> (x86, x86_64), <code>UInt8</code> (powerpc, arm)</td></tr><tr><td style="text-align: left"><code>long</code></td><td style="text-align: left"><code>Clong</code></td><td style="text-align: left"><code>Int</code> (UNIX), <code>Int32</code> (Windows)</td></tr><tr><td style="text-align: left"><code>unsigned long</code></td><td style="text-align: left"><code>Culong</code></td><td style="text-align: left"><code>UInt</code> (UNIX), <code>UInt32</code> (Windows)</td></tr><tr><td style="text-align: left"><code>wchar_t</code></td><td style="text-align: left"><code>Cwchar_t</code></td><td style="text-align: left"><code>Int32</code> (UNIX), <code>UInt16</code> (Windows)</td></tr></table><div class="admonition is-info" id="Note-4c514859c06a5a88"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-4c514859c06a5a88" title="Permalink"></a></header><div class="admonition-body"><p>Fortranを呼び出す際には、すべての入力はヒープまたはスタックに割り当てられた値へのポインタとして渡さなければならないため、上記のすべての型対応には、その型仕様の周りに追加の <code>Ptr{..}</code> または <code>Ref{..}</code> ラッパーが含まれている必要があります。</p></div></div><div class="admonition is-warning" id="Warning-4dc082880346eb5d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4dc082880346eb5d" title="Permalink"></a></header><div class="admonition-body"><p>文字列引数（<code>char*</code>）の場合、Juliaの型は<code>Cstring</code>（ヌル終端データが期待される場合）であるべきです。それ以外の場合は<code>Ptr{Cchar}</code>または<code>Ptr{UInt8}</code>のいずれか（これら2つのポインタ型は同じ効果があります）であり、<code>String</code>ではありません。同様に、配列引数（<code>T[]</code>または<code>T*</code>）の場合、Juliaの型は再び<code>Ptr{T}</code>であるべきであり、<code>Vector{T}</code>ではありません。</p></div></div><div class="admonition is-warning" id="Warning-b8dd1e8434710cd1"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b8dd1e8434710cd1" title="Permalink"></a></header><div class="admonition-body"><p>Juliaの<code>Char</code>型は32ビットであり、これはすべてのプラットフォームでのワイドキャラクター型（<code>wchar_t</code>または<code>wint_t</code>）とは異なります。</p></div></div><div class="admonition is-warning" id="Warning-3898ed02ae7b70ae"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-3898ed02ae7b70ae" title="Permalink"></a></header><div class="admonition-body"><p><code>Union{}</code>の戻り値の型は、関数が戻らないことを意味します。つまり、C++11の<code>[[noreturn]]</code>やC11の<code>_Noreturn</code>（例：<code>jl_throw</code>や<code>longjmp</code>）です。戻り値がない（<code>void</code>）が実際には戻る関数にはこれを使用しないでください。その場合は、代わりに<code>Cvoid</code>を使用してください。</p></div></div><div class="admonition is-info" id="Note-602f1782e0852606"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-602f1782e0852606" title="Permalink"></a></header><div class="admonition-body"><p><code>wchar_t*</code> 引数の場合、Julia の型は <a href="../base/c.html#Base.Cwstring"><code>Cwstring</code></a> であるべきです（C ルーチンがヌル終端文字列を期待する場合）、それ以外の場合は <code>Ptr{Cwchar_t}</code> です。また、Julia の UTF-8 文字列データは内部的にヌル終端されているため、ヌル終端データを期待する C 関数にコピーを作成せずに渡すことができます（ただし、<code>Cwstring</code> 型を使用すると、文字列自体にヌル文字が含まれている場合にエラーが発生します）。</p></div></div><div class="admonition is-info" id="Note-1157c114e7f79cbc"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1157c114e7f79cbc" title="Permalink"></a></header><div class="admonition-body"><p>Cの関数で<code>char**</code>型の引数を取るものは、Julia内で<code>Ptr{Ptr{UInt8}}</code>型を使用して呼び出すことができます。例えば、次のようなC関数：</p><pre><code class="language-c hljs">int main(int argc, char **argv);</code></pre><p>次のJuliaコードを介して呼び出すことができます:</p><pre><code class="language-julia hljs">argv = [ &quot;a.out&quot;, &quot;arg1&quot;, &quot;arg2&quot; ]
@ccall main(length(argv)::Int32, argv::Ptr{Ptr{UInt8}})::Int32</code></pre></div></div><div class="admonition is-info" id="Note-f2188b9231a339c1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f2188b9231a339c1" title="Permalink"></a></header><div class="admonition-body"><p>Fortran関数が可変長文字列の型 <code>character(len=*)</code> を受け取る場合、文字列の長さは<em>隠れた引数</em>として提供されます。これらの引数の型と位置はコンパイラによって異なり、コンパイラベンダーは通常、<code>Csize_t</code>を型として使用し、隠れた引数を引数リストの最後に追加することをデフォルトとしています。この動作は一部のコンパイラ（GNU）では固定されていますが、他のコンパイラ（Intel、PGI）は<em>オプションで</em>隠れた引数を文字引数の直後に配置することを許可しています。例えば、次のようなFortranサブルーチンが考えられます。</p><pre><code class="language-fortran hljs">subroutine test(str1, str2)
character(len=*) :: str1,str2</code></pre><p>次のJuliaコードを介して呼び出すことができ、長さが追加されます。</p><pre><code class="language-julia hljs">str1 = &quot;foo&quot;
str2 = &quot;bar&quot;
ccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),
                    str1, str2, sizeof(str1), sizeof(str2))</code></pre></div></div><div class="admonition is-warning" id="Warning-a74ad952a6317e8b"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a74ad952a6317e8b" title="Permalink"></a></header><div class="admonition-body"><p>Fortran コンパイラは、ポインタ、仮定形 (<code>:</code>) および仮定サイズ (<code>*</code>) 配列のために他の隠れた引数を追加することがあります。このような動作は、<code>ISO_C_BINDING</code> を使用し、サブルーチンの定義に <code>bind(c)</code> を含めることで回避でき、相互運用可能なコードには強く推奨されます。この場合、隠れた引数はなくなりますが、いくつかの言語機能（例：文字列を渡すためには <code>character(len=1)</code> のみが許可される）を犠牲にすることになります。</p></div></div><div class="admonition is-info" id="Note-5de6cd8c863761eb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-5de6cd8c863761eb" title="Permalink"></a></header><div class="admonition-body"><p>Cで宣言された関数が<code>Cvoid</code>を返す場合、Juliaでは値<code>nothing</code>を返します。</p></div></div><h3 id="Struct-Type-Correspondences"><a class="docs-heading-anchor" href="#Struct-Type-Correspondences">Struct Type Correspondences</a><a id="Struct-Type-Correspondences-1"></a><a class="docs-heading-anchor-permalink" href="#Struct-Type-Correspondences" title="Permalink"></a></h3><p>CやFortran90の<code>TYPE</code>（またはF77の一部のバリアントでの<code>STRUCTURE</code> / <code>RECORD</code>）のような複合型は、同じフィールドレイアウトを持つ<code>struct</code>定義を作成することでJuliaでミラーリングできます。</p><p>再帰的に使用される場合、<code>isbits</code> 型はインラインで保存されます。他のすべての型はデータへのポインタとして保存されます。Cの中で別の構造体に値として使用される構造体をミラーリングする際には、フィールドのコピーを手動で行おうとしないことが重要です。そうしないと、正しいフィールドのアライメントが保持されません。代わりに、<code>isbits</code> 構造体型を宣言し、それを使用してください。無名構造体はJuliaへの翻訳では不可能です。</p><p>Juliaでは、パックされた構造体および共用体の宣言はサポートされていません。</p><p><code>union</code>の近似を得るには、事前に最大サイズを持つフィールド（パディングを含む可能性がある）を知っている必要があります。フィールドをJuliaに翻訳する際には、Juliaのフィールドをその型のみに宣言してください。</p><p>パラメータの配列は <code>NTuple</code> を使って表現できます。例えば、C表記の構造体は次のように書かれます。</p><pre><code class="language-c hljs">struct B {
    int A[3];
};

b_a_2 = B.A[2];</code></pre><p>ジュリアでは次のように書くことができます。</p><pre><code class="language-julia hljs">struct B
    A::NTuple{3, Cint}
end

b_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)</code></pre><p>サイズが不明な配列（<code>[]</code> または <code>[0]</code> で指定された C99 準拠の可変長構造体）は直接サポートされていません。これらに対処する最良の方法は、バイトオフセットを直接扱うことです。たとえば、C ライブラリが適切な文字列型を宣言し、それへのポインタを返した場合：</p><pre><code class="language-c hljs">struct String {
    int strlen;
    char data[];
};</code></pre><p>Juliaでは、文字列の部分に独立してアクセスして、その文字列のコピーを作成することができます：</p><pre><code class="language-julia hljs">str = from_c::Ptr{Cvoid}
len = unsafe_load(Ptr{Cint}(str))
unsafe_string(str + Core.sizeof(Cint), len)</code></pre><h3 id="Type-Parameters"><a class="docs-heading-anchor" href="#Type-Parameters">Type Parameters</a><a id="Type-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Parameters" title="Permalink"></a></h3><p><code>@ccall</code> と <code>@cfunction</code> への型引数は、使用が定義されるときに静的に評価されます。したがって、リテラルタプルの形でなければならず、変数ではなく、ローカル変数を参照することはできません。</p><p>これは奇妙な制限のように聞こえるかもしれませんが、CはJuliaのような動的言語ではないため、その関数は静的に知られた固定のシグネチャを持つ引数の型のみを受け入れることを覚えておいてください。</p><p>しかし、C ABIを計算するためには型レイアウトが静的に知られている必要がありますが、関数の静的パラメータはこの静的環境の一部と見なされます。関数の静的パラメータは、型のレイアウトに影響を与えない限り、呼び出しシグネチャの型パラメータとして使用できます。例えば、<code>f(x::T) where {T} = @ccall valid(x::Ptr{T})::Ptr{T}</code>は有効です。なぜなら、<code>Ptr</code>は常にワードサイズのプリミティブ型だからです。しかし、<code>g(x::T) where {T} = @ccall notvalid(x::T)::T</code>は無効です。なぜなら、<code>T</code>の型レイアウトは静的に知られていないからです。</p><h3 id="SIMD-Values"><a class="docs-heading-anchor" href="#SIMD-Values">SIMD Values</a><a id="SIMD-Values-1"></a><a class="docs-heading-anchor-permalink" href="#SIMD-Values" title="Permalink"></a></h3><p>もしC/C++のルーチンが引数または戻り値としてネイティブのSIMD型を持つ場合、対応するJulia型はSIMD型に自然にマッピングされる<code>VecElement</code>の同種タプルです。具体的には：</p><blockquote><ul><li>タプルはSIMDタイプと同じサイズおよび要素でなければなりません。たとえば、x86上の<code>__m128</code>を表すタプルは、サイズが16バイトでFloat32要素を持っている必要があります。</li><li>タプルの要素タイプは、<code>VecElement{T}</code>のインスタンスでなければならず、<code>T</code>は2の累乗のバイト数を持つプリミティブ型（例：1, 2, 4, 8, 16など）でなければなりません。例えば、Int8やFloat64などです。</li></ul></blockquote><p>例えば、AVXインストリンシックを使用するこのCルーチンを考えてみてください：</p><pre><code class="language-c hljs">#include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</code></pre><p>次のJuliaコードは、<code>ccall</code>を使用して<code>dist</code>を呼び出します：</p><pre><code class="language-julia hljs">const m256 = NTuple{8, VecElement{Float32}}

a = m256(ntuple(i -&gt; VecElement(sin(Float32(i))), 8))
b = m256(ntuple(i -&gt; VecElement(cos(Float32(i))), 8))

function call_dist(a::m256, b::m256)
    @ccall &quot;libdist&quot;.dist(a::m256, b::m256)::m256
end

println(call_dist(a,b))</code></pre><p>ホストマシンは必要なSIMDレジスタを持っている必要があります。たとえば、上記のコードはAVXサポートのないホストでは動作しません。</p><h3 id="Memory-Ownership"><a class="docs-heading-anchor" href="#Memory-Ownership">Memory Ownership</a><a id="Memory-Ownership-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Ownership" title="Permalink"></a></h3><p><strong><code>malloc</code>/<code>free</code></strong></p><p>メモリの割り当てと解放は、使用しているライブラリの適切なクリーンアップルーチンへの呼び出しによって処理されなければなりません。これは、任意のCプログラムと同様です。Juliaで<a href="../base/libc.html#Base.Libc.free"><code>Libc.free</code></a>から受け取ったオブジェクトを解放しようとしないでください。これは、誤ったライブラリを介して<code>free</code>関数が呼び出され、プロセスが中断される原因となる可能性があります。逆に、Juliaで割り当てられたオブジェクトを外部ライブラリによって解放されるように渡すことも同様に無効です。</p><h3 id="When-to-use-T,-Ptr{T}-and-Ref{T}"><a class="docs-heading-anchor" href="#When-to-use-T,-Ptr{T}-and-Ref{T}">When to use <code>T</code>, <code>Ptr{T}</code> and <code>Ref{T}</code></a><a id="When-to-use-T,-Ptr{T}-and-Ref{T}-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-T,-Ptr{T}-and-Ref{T}" title="Permalink"></a></h3><p>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type <code>T</code> inside the <code>@ccall</code>, as they are passed by value. For C code accepting pointers, <a href="../base/c.html#Core.Ref"><code>Ref{T}</code></a> should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to <a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a>. In contrast, pointers returned by the C function called should be declared to be of the output type <a href="../base/c.html#Core.Ptr"><code>Ptr{T}</code></a>, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type <code>Ptr{T}</code> within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</p><p>Juliaコードで外部Fortranルーチンをラップする際、すべての入力引数は<code>Ref{T}</code>型として宣言する必要があります。Fortranはすべての変数をメモリ位置へのポインタとして渡すためです。戻り値の型は、Fortranサブルーチンの場合は<code>Cvoid</code>、または型<code>T</code>を返すFortran関数の場合は<code>T</code>である必要があります。</p><h2 id="Mapping-C-Functions-to-Julia"><a class="docs-heading-anchor" href="#Mapping-C-Functions-to-Julia">Mapping C Functions to Julia</a><a id="Mapping-C-Functions-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-C-Functions-to-Julia" title="Permalink"></a></h2><h3 id="@ccall-/-@cfunction-argument-translation-guide"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-argument-translation-guide"><code>@ccall</code> / <code>@cfunction</code> argument translation guide</a><a id="@ccall-/-@cfunction-argument-translation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-argument-translation-guide" title="Permalink"></a></h3><p>Cの引数リストをJuliaに翻訳するには：</p><ul><li><p><code>T</code> は、次のいずれかの基本型です: <code>char</code>、<code>int</code>、<code>long</code>、<code>short</code>、<code>float</code>、<code>double</code>、<code>complex</code>、<code>enum</code> またはそれらの <code>typedef</code> 等価物。</p><ul><li><code>T</code>、ここで <code>T</code> は上記の表に従った同等のJuliaビット型です。</li><li><code>T</code>が<code>enum</code>である場合、引数の型は<code>Cint</code>または<code>Cuint</code>と同等である必要があります。</li><li>引数の値はコピーされます（値渡し）</li></ul></li><li><p><code>struct T</code>（構造体へのtypedefを含む）</p><ul><li><code>T</code>、ここで <code>T</code> はJuliaのリーフタイプです</li><li>引数の値はコピーされます（値渡し）</li></ul></li><li><p><code>vector T</code>（または <code>__attribute__ vector_size</code>、または <code>__m128</code> のような typedef）</p><ul><li><code>NTuple{N, VecElement{T}}</code>は、<code>T</code>が正しいサイズのプリミティブなJulia型であり、Nがベクトル内の要素数（<code>vector_size / sizeof T</code>に等しい）であることを示します。</li></ul></li><li><p><code>void*</code></p><ul><li>このパラメータがどのように使用されるかによります。まず、これを意図されたポインタ型に翻訳し、その後、このリストの残りのルールを使用してJuliaの同等物を決定します。</li><li>この引数は、実際に未知のポインタである場合、<code>Ptr{Cvoid}</code>として宣言することができます。</li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><code>任意</code></li><li>引数の値は有効なJuliaオブジェクトでなければなりません。</li></ul></li><li><p><code>jl_value_t* const*</code></p><ul><li><code>Ref{Any}</code></li><li>引数リストは有効なJuliaオブジェクト（または<code>C_NULL</code>）でなければなりません。</li><li>出力パラメータとして使用することはできません。ユーザーがオブジェクトをGCで保持するように別途手配できる場合を除きます。</li></ul></li><li><p><code>T*</code></p><ul><li><code>Ref{T}</code>は、<code>T</code>に対応するJuliaの型です。</li><li>引数の値は、<code>inlinealloc</code> タイプの場合にコピーされます（<code>isbits</code> を含む）。それ以外の場合、値は有効な Julia オブジェクトでなければなりません。</li></ul></li><li><p><code>T (*)(...)</code>（例：関数へのポインタ）</p><ul><li><code>Ptr{Cvoid}</code>（このポインタを作成するには、明示的に <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> を使用する必要があるかもしれません）</li></ul></li><li><p><code>...</code> (例: 可変引数)</p><ul><li>[for <code>ccall</code>]: <code>T...</code>, ここで <code>T</code> は残りのすべての引数の単一のJulia型です</li><li>[for <code>@ccall</code>]: <code>; va_arg1::T, va_arg2::S, etc</code>、ここで <code>T</code> と <code>S</code> はJuliaの型です（すなわち、通常の引数と可変引数を <code>;</code> で区切ります）。</li><li>現在 <code>@cfunction</code> によってサポートされていません</li></ul></li><li><p><code>va_arg</code></p><ul><li><code>ccall</code> または <code>@cfunction</code> によってサポートされていません。</li></ul></li></ul><h3 id="@ccall-/-@cfunction-return-type-translation-guide"><a class="docs-heading-anchor" href="#@ccall-/-@cfunction-return-type-translation-guide"><code>@ccall</code> / <code>@cfunction</code> return type translation guide</a><a id="@ccall-/-@cfunction-return-type-translation-guide-1"></a><a class="docs-heading-anchor-permalink" href="#@ccall-/-@cfunction-return-type-translation-guide" title="Permalink"></a></h3><p>Cの戻り値の型をJuliaに翻訳するには：</p><ul><li><p><code>void</code></p><ul><li><code>Cvoid</code>（これはシングルトンインスタンス <code>nothing::Cvoid</code> を返します）</li></ul></li><li><p><code>T</code>は、原始型のいずれかである：<code>char</code>、<code>int</code>、<code>long</code>、<code>short</code>、<code>float</code>、<code>double</code>、<code>complex</code>、<code>enum</code>またはそれらの<code>typedef</code>の同等物。</p><ul><li>Cの引数リストと同じ</li><li>引数の値はコピーされます（値渡しで返されます）</li></ul></li><li><p><code>struct T</code>（構造体へのtypedefを含む）</p><ul><li>Cの引数リストと同じ</li><li>引数の値はコピーされます（値渡しで返されます）</li></ul></li><li><p><code>ベクトル T</code></p><ul><li>Cの引数リストと同じ</li></ul></li><li><p><code>void*</code></p><ul><li>このパラメータがどのように使用されるかによります。まず、これを意図されたポインタ型に翻訳し、その後、このリストの残りのルールを使用してJuliaの同等のものを決定します。</li><li>この引数は、実際に未知のポインタである場合、<code>Ptr{Cvoid}</code>として宣言される可能性があります。</li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><code>任意</code></li><li>引数の値は有効なJuliaオブジェクトでなければなりません。</li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><code>Ptr{Any}</code>（<code>Ref{Any}</code>は戻り値の型として無効です）</li></ul></li><li><p><code>T*</code></p><ul><li><p>もしメモリがすでにJuliaによって所有されているか、<code>isbits</code>型であり、非nullであることが知られている場合：</p><ul><li><code>Ref{T}</code>は、<code>T</code>に対応するJuliaの型です。</li><li><code>Ref{Any}</code>の戻り値の型は無効です。<code>Any</code>（<code>jl_value_t*</code>に対応）または<code>Ptr{Any}</code>（<code>jl_value_t**</code>に対応）である必要があります。</li><li>C <strong>は絶対に</strong> <code>T</code> が <code>isbits</code> 型である場合、<code>Ref{T}</code> を介して返されたメモリを変更してはいけません。</li></ul></li><li><p>Cがメモリを所有している場合:</p><ul><li><code>Ptr{T}</code>は、<code>T</code>に対応するJulia型の<code>T</code>です。</li></ul></li></ul></li><li><p><code>T (*)(...)</code>（例：関数へのポインタ）</p><ul><li><code>Ptr{Cvoid}</code>を直接Juliaから呼び出すには、これを<code>@ccall</code>の最初の引数として渡す必要があります。<a href="calling-c-and-fortran-code.html#Indirect-Calls">Indirect Calls</a>を参照してください。</li></ul></li></ul><h3 id="Passing-Pointers-for-Modifying-Inputs"><a class="docs-heading-anchor" href="#Passing-Pointers-for-Modifying-Inputs">Passing Pointers for Modifying Inputs</a><a id="Passing-Pointers-for-Modifying-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-Pointers-for-Modifying-Inputs" title="Permalink"></a></h3><p>Cは複数の戻り値をサポートしていないため、C関数はしばしば関数が修正するデータへのポインタを受け取ります。これを<code>@ccall</code>内で実現するには、まず適切な型の<a href="../base/c.html#Core.Ref"><code>Ref{T}</code></a>の中に値をカプセル化する必要があります。この<code>Ref</code>オブジェクトを引数として渡すと、Juliaは自動的にカプセル化されたデータへのCポインタを渡します：</p><pre><code class="language-julia hljs">width = Ref{Cint}(0)
range = Ref{Cfloat}(0)
@ccall foo(width::Ref{Cint}, range::Ref{Cfloat})::Cvoid</code></pre><p>戻ると、<code>width</code> と <code>range</code> の内容は（<code>foo</code> によって変更された場合） <code>width[]</code> と <code>range[]</code> で取得できます。つまり、それらはゼロ次元配列のように動作します。</p><h2 id="C-Wrapper-Examples"><a class="docs-heading-anchor" href="#C-Wrapper-Examples">C Wrapper Examples</a><a id="C-Wrapper-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#C-Wrapper-Examples" title="Permalink"></a></h2><p>Cラッパーの簡単な例を始めましょう。これは<code>Ptr</code>型を返します：</p><pre><code class="language-julia hljs">mutable struct gsl_permutation
end

# The corresponding C signature is
#     gsl_permutation * gsl_permutation_alloc (size_t n);
function permutation_alloc(n::Integer)
    output_ptr = @ccall &quot;libgsl&quot;.gsl_permutation_alloc(n::Csize_t)::Ptr{gsl_permutation}
    if output_ptr == C_NULL # Could not allocate memory
        throw(OutOfMemoryError())
    end
    return output_ptr
end</code></pre><p><a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a>（ここでは<code>:libgsl</code>を通じてアクセス可能であると仮定）では、C関数<code>gsl_permutation_alloc</code>の戻り値の型として不透明ポインタ<code>gsl_permutation *</code>が定義されています。ユーザーコードは<code>gsl_permutation</code>構造体の内部を見なくてよいため、対応するJuliaラッパーは内部フィールドを持たない新しい型宣言<code>gsl_permutation</code>を必要とし、その唯一の目的は<code>Ptr</code>型の型パラメータに配置されることです。<a href="../base/c.html#ccall"><code>ccall</code></a>の戻り値の型は<code>Ptr{gsl_permutation}</code>として宣言されており、<code>output_ptr</code>によって指されるメモリはCによって制御されています。</p><p>入力 <code>n</code> は値渡しされるため、関数の入力シグネチャは単に <code>::Csize_t</code> と宣言され、<code>Ref</code> や <code>Ptr</code> は必要ありません。（ラッパーが Fortran 関数を呼び出している場合、対応する関数の入力シグネチャは <code>::Ref{Csize_t}</code> になります。なぜなら、Fortran の変数はポインタで渡されるからです。）さらに、<code>n</code> は <code>Csize_t</code> 整数に変換可能な任意の型であることができます；<a href="../base/c.html#ccall"><code>ccall</code></a> は暗黙的に <a href="../base/c.html#Base.cconvert"><code>Base.cconvert(Csize_t, n)</code></a> を呼び出します。</p><p>ここに対応するデストラクタをラップする第二の例があります：</p><pre><code class="language-julia hljs"># The corresponding C signature is
#     void gsl_permutation_free (gsl_permutation * p);
function permutation_free(p::Ptr{gsl_permutation})
    @ccall &quot;libgsl&quot;.gsl_permutation_free(p::Ptr{gsl_permutation})::Cvoid
end</code></pre><p>ここにジュリア配列を渡す第三の例があります：</p><pre><code class="language-julia hljs"># The corresponding C signature is
#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,
#                                double result_array[])
function sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)
    if nmax &lt; nmin
        throw(DomainError())
    end
    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)
    errorcode = @ccall &quot;libgsl&quot;.gsl_sf_bessel_Jn_array(
                    nmin::Cint, nmax::Cint, x::Cdouble, result_array::Ref{Cdouble})::Cint
    if errorcode != 0
        error(&quot;GSL error code $errorcode&quot;)
    end
    return result_array
end</code></pre><p>C関数wrappedは整数エラーコードを返します。Bessel J関数の実際の評価の結果は、Julia配列<code>result_array</code>に格納されます。この変数は<code>Ref{Cdouble}</code>として宣言されており、そのメモリはJuliaによって割り当てられ、管理されています。暗黙の呼び出し<a href="../base/c.html#Base.cconvert"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a>は、JuliaポインタをCが理解できる形式のJulia配列データ構造に展開します。</p><h2 id="Fortran-Wrapper-Example"><a class="docs-heading-anchor" href="#Fortran-Wrapper-Example">Fortran Wrapper Example</a><a id="Fortran-Wrapper-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran-Wrapper-Example" title="Permalink"></a></h2><p>以下の例では、<code>ccall</code>を使用して一般的なFortranライブラリ（libBLAS）の関数を呼び出し、ドット積を計算します。引数のマッピングが上記とは少し異なることに注意してください。JuliaからFortranへのマッピングが必要です。すべての引数タイプに対して、<code>Ref</code>または<code>Ptr</code>を指定します。このマングリング規則は、使用しているFortranコンパイラやオペレーティングシステムに特有であり、文書化されていない可能性があります。ただし、各引数を<code>Ref</code>（または同等の<code>Ptr</code>）でラップすることは、Fortranコンパイラの実装において一般的な要件です。</p><pre><code class="language-julia hljs">function compute_dot(DX::Vector{Float64}, DY::Vector{Float64})
    @assert length(DX) == length(DY)
    n = length(DX)
    incx = incy = 1
    product = @ccall &quot;libLAPACK&quot;.ddot(
        n::Ref{Int32}, DX::Ptr{Float64}, incx::Ref{Int32}, DY::Ptr{Float64}, incy::Ref{Int32})::Float64
    return product
end</code></pre><h2 id="Garbage-Collection-Safety"><a class="docs-heading-anchor" href="#Garbage-Collection-Safety">Garbage Collection Safety</a><a id="Garbage-Collection-Safety-1"></a><a class="docs-heading-anchor-permalink" href="#Garbage-Collection-Safety" title="Permalink"></a></h2><p>データを <code>@ccall</code> に渡す際は、<a href="../base/c.html#Base.pointer"><code>pointer</code></a> 関数の使用を避けるのが最善です。代わりに、<a href="../base/c.html#Base.cconvert"><code>Base.cconvert</code></a> メソッドを定義し、変数を直接 <code>@ccall</code> に渡してください。<code>@ccall</code> は、すべての引数が呼び出しが返るまでガーベジコレクションから保護されるよう自動的に手配します。C API が Julia によって割り当てられたメモリへの参照を保存する場合、<code>@ccall</code> が返った後にオブジェクトがガーベジコレクタに見える状態を保つ必要があります。これを行うための推奨方法は、C ライブラリがそれらの値を使い終わったことを通知するまで、これらの値を保持するために <code>Array{Ref,1}</code> 型のグローバル変数を作成することです。</p><p>ポインタをJuliaデータに作成した場合、ポインタの使用が終了するまで元のデータが存在することを確認する必要があります。<a href="../base/c.html#Base.unsafe_load"><code>unsafe_load</code></a>や<a href="../base/strings.html#Core.String-Tuple{AbstractString}"><code>String</code></a>など、Juliaの多くのメソッドはバッファの所有権を取得するのではなくデータのコピーを作成するため、元のデータを解放（または変更）してもJuliaに影響を与えずに安全です。注目すべき例外は<a href="../base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}"><code>unsafe_wrap</code></a>で、パフォーマンスの理由から、基盤となるバッファを共有（または所有権を取得するように指示することができる）します。</p><p>ガーベジコレクタはファイナライズの順序を保証しません。つまり、<code>a</code> が <code>b</code> への参照を含んでいて、<code>a</code> と <code>b</code> の両方がガーベジコレクションの対象である場合、<code>b</code> が <code>a</code> の後にファイナライズされる保証はありません。<code>a</code> の適切なファイナライズが <code>b</code> の有効性に依存する場合は、他の方法で処理する必要があります。</p><h2 id="Non-constant-Function-Specifications"><a class="docs-heading-anchor" href="#Non-constant-Function-Specifications">Non-constant Function Specifications</a><a id="Non-constant-Function-Specifications-1"></a><a class="docs-heading-anchor-permalink" href="#Non-constant-Function-Specifications" title="Permalink"></a></h2><p>場合によっては、必要なライブラリの正確な名前やパスが事前にわからず、実行時に計算する必要があります。そのような場合に対処するために、ライブラリコンポーネントの仕様は関数呼び出しであることができます。例えば、<code>find_blas().dgemm</code>のようにです。この呼び出し式は、<code>ccall</code>自体が実行されるときに実行されます。ただし、一度決定されたライブラリの場所は変更されないと仮定されているため、呼び出しの結果はキャッシュされ再利用されることができます。したがって、式が実行される回数は不明であり、複数回の呼び出しで異なる値を返すことは未定義の動作を引き起こします。</p><p>さらに柔軟性が必要な場合は、次のように <a href="../base/base.html#eval"><code>eval</code></a> を通じて計算された値を関数名として使用することが可能です。</p><pre><code class="language-julia hljs">@eval @ccall &quot;lib&quot;.$(string(&quot;a&quot;, &quot;b&quot;))()::Cint</code></pre><p>この式は <code>string</code> を使用して名前を構築し、その後この名前を新しい <code>@ccall</code> 式に置き換え、それが評価されます。<code>eval</code> はトップレベルでのみ動作するため、この式内ではローカル変数は利用できません（その値が <code>$</code> で置き換えられない限り）。このため、<code>eval</code> は通常、ライブラリをラップする際のように、多くの類似関数を含むトップレベルの定義を形成するためにのみ使用されます。<a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> に対しても同様の例を構築できます。</p><p>しかし、これを行うと非常に遅くなり、メモリが漏れる可能性があるため、通常はこれを避け、代わりに読み続けるべきです。次のセクションでは、間接呼び出しを使用して効率的に同様の効果を達成する方法について説明します。</p><h2 id="Indirect-Calls"><a class="docs-heading-anchor" href="#Indirect-Calls">Indirect Calls</a><a id="Indirect-Calls-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-Calls" title="Permalink"></a></h2><p><code>@ccall</code> の最初の引数は、実行時に評価される式でも構いません。この場合、式は <code>Ptr</code> に評価される必要があり、呼び出すネイティブ関数のアドレスとして使用されます。この動作は、最初の <code>@ccall</code> 引数がローカル変数、関数引数、または非定数のグローバル変数などの非定数への参照を含む場合に発生します。</p><p>例えば、<code>dlsym</code>を介して関数を検索し、そのセッションのために共有参照にキャッシュすることができます。例えば：</p><pre><code class="language-julia hljs">macro dlsym(lib, func)
    z = Ref{Ptr{Cvoid}}(C_NULL)
    quote
        let zlocal = $z[]
            if zlocal == C_NULL
                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}
                $z[] = zlocal
            end
            zlocal
        end
    end
end

mylibvar = Libdl.dlopen(&quot;mylib&quot;)
@ccall $(@dlsym(mylibvar, &quot;myfunc&quot;))()::Cvoid</code></pre><h2 id="Closure-cfunctions"><a class="docs-heading-anchor" href="#Closure-cfunctions">Closure cfunctions</a><a id="Closure-cfunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Closure-cfunctions" title="Permalink"></a></h2><p>最初の引数 <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> は <code>$</code> でマークすることができ、その場合、戻り値は引数を閉じ込める <code>struct CFunction</code> になります。この戻り値オブジェクトは、すべての使用が完了するまで生存させる必要があります。cfunction ポインタの内容とコードは、この参照がドロップされ、atexit で <a href="../base/base.html#Base.finalizer"><code>finalizer</code></a> によって消去されます。これは通常必要ありませんが、この機能は C には存在しないため、別のクロージャ環境パラメータを提供しない不適切に設計された API を扱う際に便利です。</p><pre><code class="language-julia hljs">function qsort(a::Vector{T}, cmp) where T
    isbits(T) || throw(ArgumentError(&quot;this method can only qsort isbits arrays&quot;))
    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})
    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}
    # (and protected against finalization) by the ccall
    @ccall qsort(a::Ptr{T}, length(a)::Csize_t, Base.elsize(a)::Csize_t, callback::Ptr{Cvoid})
    # We could instead use:
    #    GC.@preserve callback begin
    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))
    #    end
    # if we needed to use it outside of a `ccall`
    return a
end</code></pre><div class="admonition is-info" id="Note-2360c1a378be5324"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2360c1a378be5324" title="Permalink"></a></header><div class="admonition-body"><p>Closure <a href="../base/c.html#Base.@cfunction"><code>@cfunction</code></a> は、すべてのプラットフォームで利用できるわけではない LLVM トランポリンに依存しています（例えば、ARMやPowerPCなど）。</p></div></div><h2 id="Closing-a-Library"><a class="docs-heading-anchor" href="#Closing-a-Library">Closing a Library</a><a id="Closing-a-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Closing-a-Library" title="Permalink"></a></h2><p>ライブラリを閉じて（アンロード）再ロードできるようにすることは、時には便利です。たとえば、Juliaで使用するCコードを開発しているとき、Cコードをコンパイルし、JuliaからCコードを呼び出し、その後ライブラリを閉じて、編集を行い、再コンパイルし、新しい変更をロードする必要があるかもしれません。Juliaを再起動するか、<code>Libdl</code>関数を使用してライブラリを明示的に管理することができます。</p><pre><code class="language-julia hljs">lib = Libdl.dlopen(&quot;./my_lib.so&quot;) # Open the library explicitly.
sym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.
@ccall $sym(...) # Use the pointer `sym` instead of the library.symbol tuple.
Libdl.dlclose(lib) # Close the library explicitly.</code></pre><p><code>@ccall</code>を使用する際は、入力（例：<code>@ccall &quot;./my_lib.so&quot;.my_fcn(...)::Cvoid</code>）に注意してください。ライブラリは暗黙的にオープンされ、明示的にクローズされない場合があります。</p><h2 id="Variadic-function-calls"><a class="docs-heading-anchor" href="#Variadic-function-calls">Variadic function calls</a><a id="Variadic-function-calls-1"></a><a class="docs-heading-anchor-permalink" href="#Variadic-function-calls" title="Permalink"></a></h2><p>可変引数のC関数を呼び出すには、引数リスト内で <code>;</code> を使用して必須引数と可変引数を区切ることができます。以下に <code>printf</code> 関数の例を示します:</p><pre><code class="language-julia-repl hljs">julia&gt; @ccall printf(&quot;%s = %d\n&quot;::Cstring ; &quot;foo&quot;::Cstring, foo::Cint)::Cint
foo = 3
8</code></pre><h2 id="ccall-interface"><a class="docs-heading-anchor" href="#ccall-interface"><code>ccall</code> interface</a><a id="ccall-interface-1"></a><a class="docs-heading-anchor-permalink" href="#ccall-interface" title="Permalink"></a></h2><p><code>@ccall</code>には別の代替インターフェースがあります。このインターフェースは少し便利さに欠けますが、<a href="calling-c-and-fortran-code.html#calling-convention">calling convention</a>を指定することができます。</p><p><a href="../base/c.html#ccall"><code>ccall</code></a>への引数は次のとおりです：</p><ol><li><p><code>(:function, &quot;library&quot;)</code> ペア（最も一般的な）、</p><p>または</p><p><code>:function</code> 名のシンボルまたは <code>&quot;function&quot;</code> 名の文字列（現在のプロセスまたは libc のシンボル用）、</p><p>または</p><p>関数ポインタ（例えば、<code>dlsym</code>から）。</p></li><li><p>関数の戻り値の型</p></li><li><p>関数シグネチャに対応する入力タイプのタプル。一般的な間違いの一つは、引数タイプの1タプルは末尾にカンマを付けて書かなければならないことを忘れることです。</p></li><li><p>関数に渡される実際の引数の値（ある場合）；それぞれが別々のパラメータです。</p></li></ol><div class="admonition is-info" id="Note-f62ce5b09dca9dd1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f62ce5b09dca9dd1" title="Permalink"></a></header><div class="admonition-body"><p><code>(:function, &quot;library&quot;)</code> ペア、戻り値の型、および入力型はリテラル定数でなければなりません（つまり、変数ではなく、ただし <a href="calling-c-and-fortran-code.html#Non-constant-Function-Specifications">Non-constant Function Specifications</a> を参照してください）。</p><p>残りのパラメータは、含まれているメソッドが定義されるときにコンパイル時に評価されます。</p></div></div><p>マクロと関数インターフェース間の翻訳の表は以下に示されています。</p><table><tr><th style="text-align: right"><code>@ccall</code></th><th style="text-align: right"><code>ccall</code></th></tr><tr><td style="text-align: right"><code>@ccall clock()::Int32</code></td><td style="text-align: right"><code>ccall(:clock, Int32, ())</code></td></tr><tr><td style="text-align: right"><code>@ccall f(a::Cint)::Cint</code></td><td style="text-align: right"><code>ccall(:a, Cint, (Cint,), a)</code></td></tr><tr><td style="text-align: right"><code>@ccall &quot;mylib&quot;.f(a::Cint, b::Cdouble)::Cvoid</code></td><td style="text-align: right"><code>ccall((:f, &quot;mylib&quot;), Cvoid, (Cint, Cdouble), (a, b))</code></td></tr><tr><td style="text-align: right"><code>@ccall $fptr.f()::Cvoid</code></td><td style="text-align: right"><code>ccall(fptr, f, Cvoid, ())</code></td></tr><tr><td style="text-align: right"><code>@ccall printf(&quot;%s = %d\n&quot;::Cstring ; &quot;foo&quot;::Cstring, foo::Cint)::Cint</code></td><td style="text-align: right"><code>&lt;unavailable&gt;</code></td></tr><tr><td style="text-align: right"><code>@ccall printf(&quot;%s = %s\n&quot;::Cstring ; &quot;2 + 2&quot;::Cstring, &quot;5&quot;::Cstring)::Cint</code></td><td style="text-align: right"><code>ccall(:printf, Cint, (Cstring, Cstring...), &quot;%s = %s\n&quot;, &quot;2 + 2&quot;, &quot;5&quot;)</code></td></tr><tr><td style="text-align: right"><code>&lt;unavailable&gt;</code></td><td style="text-align: right"><code>ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></td></tr></table><h2 id="calling-convention"><a class="docs-heading-anchor" href="#calling-convention">Calling Convention</a><a id="calling-convention-1"></a><a class="docs-heading-anchor-permalink" href="#calling-convention" title="Permalink"></a></h2><p><code>ccall</code>の第二引数（戻り値の型の直前）は、オプションで呼び出し規約の指定子を指定できます（現在、<code>@ccall</code>マクロは呼び出し規約を指定することをサポートしていません）。指定子がない場合、プラットフォームのデフォルトのC呼び出し規約が使用されます。他にサポートされている規約は、<code>stdcall</code>、<code>cdecl</code>、<code>fastcall</code>、および<code>thiscall</code>（64ビットWindowsでは無操作）です。例えば（<code>base/libc.jl</code>から）、上記と同じ<code>gethostname</code><code>ccall</code>が見られますが、Windows用の正しいシグネチャが付いています：</p><pre><code class="language-julia hljs">hn = Vector{UInt8}(undef, 256)
err = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))</code></pre><p>詳細については、<a href="https://llvm.org/docs/LangRef.html#calling-conventions">LLVM Language Reference</a>をご覧ください。</p><p>特別な呼び出し規約 <a href="../base/c.html#Core.Intrinsics.llvmcall"><code>llvmcall</code></a> があり、これによりLLVMのインストリンシックを直接呼び出すことができます。これは、GPGPUのような珍しいプラットフォームをターゲットにする際に特に便利です。例えば、<a href="https://llvm.org/docs/NVPTXUsage.html">CUDA</a> の場合、スレッドインデックスを読み取る必要があります。</p><pre><code class="language-julia hljs">ccall(&quot;llvm.nvvm.read.ptx.sreg.tid.x&quot;, llvmcall, Int32, ())</code></pre><p><code>ccall</code>と同様に、引数のシグネチャを正確に取得することが重要です。また、<code>Core.Intrinsics</code>によって公開される同等のJulia関数とは異なり、内蔵関数が現在のターゲットで意味を持ち、機能することを保証する互換性レイヤーは存在しないことに注意してください。</p><h2 id="Accessing-Global-Variables"><a class="docs-heading-anchor" href="#Accessing-Global-Variables">Accessing Global Variables</a><a id="Accessing-Global-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Global-Variables" title="Permalink"></a></h2><p>ネイティブライブラリによってエクスポートされたグローバル変数は、<a href="../base/c.html#Core.Intrinsics.cglobal"><code>cglobal</code></a> 関数を使用して名前でアクセスできます。<code>4d61726b646f776e2e436f64652822222c202263676c6f62616c2229_40726566</code> への引数は、<a href="../base/c.html#ccall"><code>ccall</code></a> で使用されるのと同じシンボル仕様と、変数に格納されている値を説明する型です：</p><pre><code class="language-julia-repl hljs">julia&gt; cglobal((:errno, :libc), Int32)
Ptr{Int32} @0x00007f418d0816b8</code></pre><p>結果は、値のアドレスを示すポインタです。このポインタを使用して、<a href="../base/c.html#Base.unsafe_load"><code>unsafe_load</code></a> と <a href="../base/c.html#Base.unsafe_store!"><code>unsafe_store!</code></a> を介して値を操作できます。</p><div class="admonition is-info" id="Note-9beeae98df2c336b"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9beeae98df2c336b" title="Permalink"></a></header><div class="admonition-body"><p>この <code>errno</code> シンボルは、「libc」というライブラリには見つからないかもしれません。これは、システムコンパイラの実装の詳細です。通常、標準ライブラリのシンボルは名前だけでアクセスされ、コンパイラが正しいものを補完します。しかし、この例に示されている <code>errno</code> シンボルはほとんどのコンパイラで特別なものであり、ここで見られる値はおそらくあなたが期待するものや望むものではありません。マルチスレッド対応のシステムで同等のコードをCでコンパイルすると、通常は異なる関数（マクロプリプロセッサのオーバーロードを介して）を実際に呼び出し、ここに表示されているレガシー値とは異なる結果を返す可能性があります。</p></div></div><h2 id="Accessing-Data-through-a-Pointer"><a class="docs-heading-anchor" href="#Accessing-Data-through-a-Pointer">Accessing Data through a Pointer</a><a id="Accessing-Data-through-a-Pointer-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Data-through-a-Pointer" title="Permalink"></a></h2><p>以下のメソッドは「安全でない」として説明されています。なぜなら、悪いポインタや型宣言が原因でJuliaが突然終了する可能性があるからです。</p><p>与えられた <code>Ptr{T}</code> に対して、型 <code>T</code> の内容は一般的に <code>unsafe_load(ptr, [index])</code> を使用して参照されたメモリからJuliaオブジェクトにコピーできます。インデックス引数はオプションであり（デフォルトは1）、Juliaの1ベースのインデックス付けの規則に従います。この関数は、<a href="../base/collections.html#Base.getindex"><code>getindex</code></a> および <a href="../base/collections.html#Base.setindex!"><code>setindex!</code></a> の動作に意図的に似ています（例：<code>[]</code> アクセス構文）。</p><p>戻り値は、参照されたメモリの内容のコピーを含むように初期化された新しいオブジェクトになります。参照されたメモリは安全に解放またはリリースできます。</p><p>もし <code>T</code> が <code>Any</code> であれば、メモリには Julia オブジェクトへの参照（<code>jl_value_t*</code>）が含まれていると仮定され、結果はこのオブジェクトへの参照となり、オブジェクトはコピーされません。この場合、オブジェクトが常にガーベジコレクタに見えるように注意する必要があります（ポインタはカウントされませんが、新しい参照はカウントされます）ので、メモリが早期に解放されないようにしてください。オブジェクトが元々 Julia によって割り当てられていなかった場合、新しいオブジェクトは決して Julia のガーベジコレクタによって最終化されることはありません。もし <code>Ptr</code> 自体が実際に <code>jl_value_t*</code> であれば、<a href="../base/c.html#Base.unsafe_pointer_to_objref"><code>unsafe_pointer_to_objref(ptr)</code></a> を使用して再び Julia オブジェクト参照に変換できます。（Julia 値 <code>v</code> は、<a href="../base/c.html#Base.pointer_from_objref"><code>pointer_from_objref(v)</code></a> を呼び出すことで <code>Ptr{Cvoid}</code> ポインタに変換できます。）</p><p>逆操作（<code>Ptr{T}</code> にデータを書き込むこと）は、<a href="../base/c.html#Base.unsafe_store!"><code>unsafe_store!(ptr, value, [index])</code></a> を使用して実行できます。現在、これはプリミティブ型または他のポインタフリー（<code>isbits</code>）の不変構造体型にのみ対応しています。</p><p>エラーをスローする操作は、おそらく現在未実装であり、解決できるようにバグとして投稿されるべきです。</p><p>もし関心のあるポインタがプレーンデータ配列（プリミティブ型または不変構造体）の場合、関数 <a href="../base/c.html#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T}}, Type{Array{T, N}}}, Ptr{T}, NTuple{N, Int64}}} where {T, N}"><code>unsafe_wrap(Array, ptr,dims, own = false)</code></a> がより便利かもしれません。最終パラメータは、Juliaが基盤となるバッファの「所有権を取得」し、返された <code>Array</code> オブジェクトが最終化されるときに <code>free(ptr)</code> を呼び出すべきであれば true であるべきです。<code>own</code> パラメータが省略されるか false の場合、呼び出し元はすべてのアクセスが完了するまでバッファが存在し続けることを保証しなければなりません。</p><p><code>Ptr</code> 型における算術演算は、Julia では C のポインタ算術演算とは異なります。<code>Ptr</code> に整数を加えると、Julia では常にポインタが <em>バイト</em> 単位で移動し、要素単位では移動しません。このため、ポインタ算術演算から得られるアドレス値は、ポインタの要素型に依存しません。</p><h2 id="Thread-safety"><a class="docs-heading-anchor" href="#Thread-safety">Thread-safety</a><a id="Thread-safety-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-safety" title="Permalink"></a></h2><p>いくつかのCライブラリは、異なるスレッドからコールバックを実行します。Juliaはスレッドセーフではないため、いくつかの追加の注意が必要です。特に、2層のシステムを設定する必要があります：Cコールバックは、あなたの「実際の」コールバックの実行を<em>スケジュール</em>するだけであるべきです。これを行うには、<a href="../base/base.html#Base.AsyncCondition"><code>AsyncCondition</code></a>オブジェクトを作成し、それに対して<a href="../base/parallel.html#Base.wait"><code>wait</code></a>を呼び出します：</p><pre><code class="language-julia hljs">cond = Base.AsyncCondition()
wait(cond)</code></pre><p>Cに渡すコールバックは、<a href="../base/c.html#ccall"><code>ccall</code></a>を<code>:uv_async_send</code>に実行するだけで、<code>cond.handle</code>を引数として渡し、Juliaランタイムとの割り当てやその他の相互作用を避けるようにしてください。</p><p>イベントは統合される可能性があるため、<code>uv_async_send</code>への複数の呼び出しが条件への単一のウェイクアップ通知につながることがあります。</p><h2 id="More-About-Callbacks"><a class="docs-heading-anchor" href="#More-About-Callbacks">More About Callbacks</a><a id="More-About-Callbacks-1"></a><a class="docs-heading-anchor-permalink" href="#More-About-Callbacks" title="Permalink"></a></h2><p>Cライブラリにコールバックを渡す方法の詳細については、次のリンクを参照してください <a href="https://julialang.org/blog/2013/05/callback">blog post</a>。</p><h2 id="C"><a class="docs-heading-anchor" href="#C">C++</a><a id="C-1"></a><a class="docs-heading-anchor-permalink" href="#C" title="Permalink"></a></h2><p>C++ バインディングを作成するためのツールについては、<a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap</a> パッケージを参照してください。</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. The point above is that the cost of actually doing foreign function call is about the same as doing a call in either native language.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The <a href="https://github.com/ihnorton/Clang.jl">Clang package</a> can be used to auto-generate Julia code from a C header file.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="running-external-programs.html">« Running External Programs</a><a class="docs-footer-nextpage" href="handling-operating-system-variation.html">Handling Operating System Variation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 20 May 2025 07:07">Tuesday 20 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
