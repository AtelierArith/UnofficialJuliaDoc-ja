<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse Arrays · The Julia Language</title><meta name="title" content="Sparse Arrays · The Julia Language"/><meta property="og:title" content="Sparse Arrays · The Julia Language"/><meta property="twitter:title" content="Sparse Arrays · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="Base64.html">Base64</a></li><li><a class="tocitem" href="CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="Dates.html">Dates</a></li><li><a class="tocitem" href="DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="Downloads.html">Downloads</a></li><li><a class="tocitem" href="FileWatching.html">File Events</a></li><li><a class="tocitem" href="Future.html">Future</a></li><li><a class="tocitem" href="InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="Logging.html">Logging</a></li><li><a class="tocitem" href="Markdown.html">Markdown</a></li><li><a class="tocitem" href="Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="Pkg.html">Pkg</a></li><li><a class="tocitem" href="Printf.html">Printf</a></li><li><a class="tocitem" href="Profile.html">Profiling</a></li><li><a class="tocitem" href="REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="Random.html">Random Numbers</a></li><li><a class="tocitem" href="SHA.html">SHA</a></li><li><a class="tocitem" href="Serialization.html">Serialization</a></li><li><a class="tocitem" href="SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="Sockets.html">Sockets</a></li><li class="is-active"><a class="tocitem" href="SparseArrays.html">Sparse Arrays</a><ul class="internal"><li><a class="tocitem" href="#man-csc"><span>Compressed Sparse Column (CSC) Sparse Matrix Storage</span></a></li><li><a class="tocitem" href="#Sparse-Vector-Storage"><span>Sparse Vector Storage</span></a></li><li><a class="tocitem" href="#Sparse-Vector-and-Matrix-Constructors"><span>Sparse Vector and Matrix Constructors</span></a></li><li><a class="tocitem" href="#Sparse-matrix-operations"><span>Sparse matrix operations</span></a></li><li><a class="tocitem" href="#Correspondence-of-dense-and-sparse-methods"><span>Correspondence of dense and sparse methods</span></a></li><li><a class="tocitem" href="#stdlib-sparse-linalg"><span>Sparse Linear Algebra</span></a></li><li class="toplevel"><a class="tocitem" href="#stdlib-sparse-arrays"><span>SparseArrays API</span></a></li><li class="toplevel"><a class="tocitem" href="#stdlib-sparse-linalg-api"><span>Sparse Linear Algebra API</span></a></li><li class="toplevel"><a class="tocitem" href="#Noteworthy-External-Sparse-Packages"><span>Noteworthy External Sparse Packages</span></a></li></ul></li><li><a class="tocitem" href="Statistics.html">Statistics</a></li><li><a class="tocitem" href="StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="TOML.html">TOML</a></li><li><a class="tocitem" href="Tar.html">Tar</a></li><li><a class="tocitem" href="Test.html">Unit Testing</a></li><li><a class="tocitem" href="UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href="SparseArrays.html">Sparse Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="SparseArrays.html">Sparse Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/master/docs/src/index.md" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Arrays"><a class="docs-heading-anchor" href="#Sparse-Arrays">Sparse Arrays</a><a id="Sparse-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Arrays" title="Permalink"></a></h1><p>Juliaは、<code>SparseArrays</code>標準ライブラリモジュールでスパースベクトルと<a href="https://en.wikipedia.org/wiki/Sparse_matrix">sparse matrices</a>をサポートしています。スパース配列は、ゼロが十分に含まれている配列であり、特別なデータ構造に格納することで、密な配列と比較して、スペースと実行時間の節約が可能になります。</p><p>異なるスパースストレージタイプ、マルチディメンショナルスパース配列などを実装する外部パッケージは、<a href="SparseArrays.html#Noteworthy-External-Sparse-Packages">Noteworthy External Sparse Packages</a> で見つけることができます。</p><h2 id="man-csc"><a class="docs-heading-anchor" href="#man-csc">Compressed Sparse Column (CSC) Sparse Matrix Storage</a><a id="man-csc-1"></a><a class="docs-heading-anchor-permalink" href="#man-csc" title="Permalink"></a></h2><p>Juliaでは、スパース行列は<a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">Compressed Sparse Column (CSC) format</a>に格納されます。Juliaのスパース行列は<a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC{Tv,Ti}</code></a>という型を持ち、ここで<code>Tv</code>は格納される値の型、<code>Ti</code>は列ポインタと行インデックスを格納するための整数型です。<code>SparseMatrixCSC</code>の内部表現は次のようになります：</p><pre><code class="language-julia hljs">struct SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end</code></pre><p>圧縮スパース列ストレージは、スパース行列の列内の要素に簡単かつ迅速にアクセスできるようにしますが、行によるスパース行列へのアクセスはかなり遅くなります。CSC構造内で、以前に保存されていなかったエントリを1つずつ挿入するような操作は遅くなる傾向があります。これは、挿入ポイントを超えるスパース行列のすべての要素を1つずつ移動させる必要があるためです。</p><p>すべてのスパース行列に関する操作は、パフォーマンスを向上させるためにCSCデータ構造を活用し、高コストの操作を回避するように慎重に実装されています。</p><p>CSC形式のデータが他のアプリケーションやライブラリからある場合、Juliaにインポートする際は1ベースのインデックスを使用することを確認してください。各列の行インデックスはソートされている必要があり、そうでない場合、行列は正しく表示されません。<code>SparseMatrixCSC</code>オブジェクトにソートされていない行インデックスが含まれている場合、ソートする簡単な方法はダブルトランスポーズを行うことです。トランスポーズ操作は遅延されるため、各トランスポーズを具現化するためにコピーを作成してください。</p><p>一部のアプリケーションでは、<code>SparseMatrixCSC</code>に明示的なゼロ値を格納することが便利です。これらは<code>Base</code>の関数によって受け入れられます（ただし、変更操作で保持される保証はありません）。このように明示的に格納されたゼロは、多くのルーチンによって構造的な非ゼロとして扱われます。<a href="SparseArrays.html#SparseArrays.nnz"><code>nnz</code></a>関数は、構造的でないゼロを含むスパースデータ構造に明示的に格納された要素の数を返します。正確な数の数値非ゼロをカウントするには、<a href="../base/collections.html#Base.count"><code>count(!iszero, x)</code></a>を使用してください。これはスパース行列のすべての格納された要素を検査します。<a href="SparseArrays.html#SparseArrays.dropzeros"><code>dropzeros</code></a>およびインプレースの<a href="SparseArrays.html#SparseArrays.dropzeros!"><code>dropzeros!</code></a>は、スパース行列から格納されたゼロを削除するために使用できます。</p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0])
3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 0  ⋅  1
 ⋅  2  ⋅
 ⋅  ⋅  0

julia&gt; dropzeros(A)
3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:
 ⋅  ⋅  1
 ⋅  2  ⋅
 ⋅  ⋅  ⋅</code></pre><h2 id="Sparse-Vector-Storage"><a class="docs-heading-anchor" href="#Sparse-Vector-Storage">Sparse Vector Storage</a><a id="Sparse-Vector-Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Vector-Storage" title="Permalink"></a></h2><p>スパースベクトルは、スパース行列の圧縮スパース列形式に近い形で保存されます。Juliaでは、スパースベクトルは型 <a href="SparseArrays.html#SparseArrays.SparseVector"><code>SparseVector{Tv,Ti}</code></a> を持ち、ここで <code>Tv</code> は保存される値の型、<code>Ti</code> はインデックスの整数型です。内部表現は次のようになります：</p><pre><code class="language-julia hljs">struct SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end</code></pre><p><a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>について、<code>SparseVector</code>型は明示的に保存されたゼロも含むことができます。（参照：<a href="SparseArrays.html#man-csc">Sparse Matrix Storage</a>。）</p><h2 id="Sparse-Vector-and-Matrix-Constructors"><a class="docs-heading-anchor" href="#Sparse-Vector-and-Matrix-Constructors">Sparse Vector and Matrix Constructors</a><a id="Sparse-Vector-and-Matrix-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Vector-and-Matrix-Constructors" title="Permalink"></a></h2><p>スパース配列を作成する最も簡単な方法は、Juliaが密な配列を扱うために提供する<a href="../base/arrays.html#Base.zeros"><code>zeros</code></a>関数に相当する関数を使用することです。代わりにスパース配列を生成するには、同じ名前に<code>sp</code>プレフィックスを付けて使用できます：</p><pre><code class="language-julia-repl hljs">julia&gt; spzeros(3)
3-element SparseVector{Float64, Int64} with 0 stored entries</code></pre><p><a href="SparseArrays.html#SparseArrays.sparse"><code>sparse</code></a> 関数は、スパース配列を構築する便利な方法です。たとえば、スパース行列を構築するために、行インデックスのベクトル <code>I</code>、列インデックスのベクトル <code>J</code>、および保存された値のベクトル <code>V</code> を入力できます（これは <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">COO (coordinate) format</a> とも呼ばれます）。<code>sparse(I,J,V)</code> は、<code>S[I[k], J[k]] = V[k]</code> となるスパース行列を構築します。等価なスパースベクトルコンストラクタは <a href="SparseArrays.html#SparseArrays.sparsevec"><code>sparsevec</code></a> で、（行）インデックスベクトル <code>I</code> と保存された値のベクトル <code>V</code> を取り、<code>R[I[k]] = V[k]</code> となるスパースベクトル <code>R</code> を構築します。</p><pre><code class="language-julia-repl hljs">julia&gt; I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia&gt; S = sparse(I,J,V)
5×18 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
⎡⠀⠈⠀⠀⠀⠀⠀⠀⢀⎤
⎣⠀⠀⠀⠂⡀⠀⠀⠀⠀⎦

julia&gt; R = sparsevec(I,V)
5-element SparseVector{Int64, Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3</code></pre><p><a href="SparseArrays.html#SparseArrays.sparse"><code>sparse</code></a> および <a href="SparseArrays.html#SparseArrays.sparsevec"><code>sparsevec</code></a> 関数の逆は <a href="SparseArrays.html#SparseArrays.findnz"><code>findnz</code></a> であり、これはスパース配列を作成するために使用された入力（ゼロに等しい保存されたエントリを含む）を取得します。 <a href="../base/arrays.html#Base.findall-Tuple{Any}"><code>findall(!iszero, x)</code></a> は、<code>x</code> の非ゼロエントリのカーテシアンインデックスを返します（ゼロに等しい保存されたエントリは含まれません）。</p><pre><code class="language-julia-repl hljs">julia&gt; findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia&gt; findall(!iszero, S)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 4)
 CartesianIndex(4, 7)
 CartesianIndex(5, 9)
 CartesianIndex(3, 18)

julia&gt; findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia&gt; findall(!iszero, R)
4-element Vector{Int64}:
 1
 3
 4
 5</code></pre><p>別の方法として、<a href="SparseArrays.html#SparseArrays.sparse"><code>sparse</code></a> 関数を使用して、密な配列を疎な配列に変換することができます：</p><pre><code class="language-julia-repl hljs">julia&gt; sparse(Matrix(1.0I, 5, 5))
5×5 SparseMatrixCSC{Float64, Int64} with 5 stored entries:
 1.0   ⋅    ⋅    ⋅    ⋅
  ⋅   1.0   ⋅    ⋅    ⋅
  ⋅    ⋅   1.0   ⋅    ⋅
  ⋅    ⋅    ⋅   1.0   ⋅
  ⋅    ⋅    ⋅    ⋅   1.0

julia&gt; sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre><p>他の方向に進むには、<a href="../base/arrays.html#Core.Array"><code>Array</code></a> コンストラクタを使用できます。<a href="SparseArrays.html#SparseArrays.issparse"><code>issparse</code></a> 関数は、行列がスパースであるかどうかを照会するために使用できます。</p><pre><code class="language-julia-repl hljs">julia&gt; issparse(spzeros(5))
true</code></pre><h2 id="Sparse-matrix-operations"><a class="docs-heading-anchor" href="#Sparse-matrix-operations">Sparse matrix operations</a><a id="Sparse-matrix-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-matrix-operations" title="Permalink"></a></h2><p>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into <code>(I,J,V)</code> format using <a href="SparseArrays.html#SparseArrays.findnz"><code>findnz</code></a>, manipulate the values or the structure in the dense vectors <code>(I,J,V)</code>, and then reconstruct the sparse matrix.</p><h2 id="Correspondence-of-dense-and-sparse-methods"><a class="docs-heading-anchor" href="#Correspondence-of-dense-and-sparse-methods">Correspondence of dense and sparse methods</a><a id="Correspondence-of-dense-and-sparse-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Correspondence-of-dense-and-sparse-methods" title="Permalink"></a></h2><p>次の表は、スパース行列の組み込みメソッドと、それに対応する密行列タイプのメソッドとの対応関係を示しています。一般に、スパース行列を生成するメソッドは、密行列の対応するメソッドとは異なり、結果として得られる行列が指定されたスパース行列 <code>S</code> と同じスパースパターンに従うか、または結果として得られるスパース行列が密度 <code>d</code> を持つこと、すなわち各行列要素が非ゼロである確率が <code>d</code> であることを意味します。</p><p>詳細は、標準ライブラリリファレンスの <a href="SparseArrays.html#stdlib-sparse-arrays">Sparse Vectors and Matrices</a> セクションにあります。</p><table><tr><th style="text-align: left">Sparse</th><th style="text-align: left">Dense</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="SparseArrays.html#SparseArrays.spzeros"><code>spzeros(m,n)</code></a></td><td style="text-align: left"><a href="../base/arrays.html#Base.zeros"><code>zeros(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> matrix of zeros. (<a href="SparseArrays.html#SparseArrays.spzeros"><code>spzeros(m,n)</code></a> is empty.)</td></tr><tr><td style="text-align: left"><a href="SparseArrays.html#SparseArrays.sparse"><code>sparse(I,n,n)</code></a></td><td style="text-align: left"><a href="../base/arrays.html#Base.Matrix"><code>Matrix(I,n,n)</code></a></td><td style="text-align: left">Creates a <em>n</em>-by-<em>n</em> identity matrix.</td></tr><tr><td style="text-align: left"><a href="SparseArrays.html#SparseArrays.sparse"><code>sparse(A)</code></a></td><td style="text-align: left"><a href="../base/arrays.html#Core.Array"><code>Array(S)</code></a></td><td style="text-align: left">Interconverts between dense and sparse formats.</td></tr><tr><td style="text-align: left"><a href="SparseArrays.html#SparseArrays.sprand"><code>sprand(m,n,d)</code></a></td><td style="text-align: left"><a href="Random.html#Base.rand"><code>rand(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed uniformly on the half-open interval <span>$[0, 1)$</span>.</td></tr><tr><td style="text-align: left"><a href="SparseArrays.html#SparseArrays.sprandn"><code>sprandn(m,n,d)</code></a></td><td style="text-align: left"><a href="Random.html#Base.randn"><code>randn(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</td></tr><tr><td style="text-align: left"><a href="SparseArrays.html#SparseArrays.sprandn"><code>sprandn(rng,m,n,d)</code></a></td><td style="text-align: left"><a href="Random.html#Base.randn"><code>randn(rng,m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements generated with the <code>rng</code> random number generator</td></tr></table><h2 id="stdlib-sparse-linalg"><a class="docs-heading-anchor" href="#stdlib-sparse-linalg">Sparse Linear Algebra</a><a id="stdlib-sparse-linalg-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-sparse-linalg" title="Permalink"></a></h2><p>スパース行列ソルバーは、<a href="http://suitesparse.com">SuiteSparse</a> から関数を呼び出します。以下の因子分解が利用可能です：</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>CHOLMOD.Factor</code></td><td style="text-align: left">Cholesky and LDLt factorizations</td></tr><tr><td style="text-align: left"><code>UMFPACK.UmfpackLU</code></td><td style="text-align: left">LU factorization</td></tr><tr><td style="text-align: left"><code>SPQR.QRSparse</code></td><td style="text-align: left">QR factorization</td></tr></table><p>これらの因数分解は、<a href="SparseArrays.html#stdlib-sparse-linalg-api">Sparse Linear Algebra API section</a>でより詳細に説明されています。</p><ol><li><a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a></li><li><a href="LinearAlgebra.html#LinearAlgebra.ldlt"><code>ldlt</code></a></li><li><a href="LinearAlgebra.html#LinearAlgebra.lu"><code>lu</code></a></li><li><a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a></li></ol><h1 id="stdlib-sparse-arrays"><a class="docs-heading-anchor" href="#stdlib-sparse-arrays">SparseArrays API</a><a id="stdlib-sparse-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-sparse-arrays" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.AbstractSparseArray" href="#SparseArrays.AbstractSparseArray"><code>SparseArrays.AbstractSparseArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSparseArray{Tv,Ti,N}</code></pre><p><code>Tv</code>型の要素と<code>Ti</code>型のインデックスを持つ<code>N</code>次元スパース配列（または配列のような型）のスーパタイプです。 <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>、<a href="SparseArrays.html#SparseArrays.SparseVector"><code>SparseVector</code></a>および<code>SuiteSparse.CHOLMOD.Sparse</code>はこのサブタイプです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/abstractsparse.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.AbstractSparseVector" href="#SparseArrays.AbstractSparseVector"><code>SparseArrays.AbstractSparseVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSparseVector{Tv,Ti}</code></pre><p>要素の型が <code>Tv</code> でインデックス型が <code>Ti</code> の一次元スパース配列（または配列のような型）のスーパークラス。 <code>AbstractSparseArray{Tv,Ti,1}</code> のエイリアスです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/abstractsparse.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.AbstractSparseMatrix" href="#SparseArrays.AbstractSparseMatrix"><code>SparseArrays.AbstractSparseMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSparseMatrix{Tv,Ti}</code></pre><p>要素の型 <code>Tv</code> とインデックス型 <code>Ti</code> を持つ二次元スパース配列（または配列のような型）のスーパタイプ。<code>AbstractSparseArray{Tv,Ti,2}</code> のエイリアス。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/abstractsparse.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.SparseVector" href="#SparseArrays.SparseVector"><code>SparseArrays.SparseVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}</code></pre><p>スパースベクトルを格納するためのベクトル型です。ベクトルの長さ、<em>ソートされた</em> 非ゼロインデックスのベクトル、および非ゼロ値のベクトルを渡すことで作成できます。</p><p>例えば、ベクトル <code>[5, 6, 0, 7]</code> は次のように表現できます。</p><pre><code class="language-julia hljs">SparseVector(4, [1, 2, 4], [5, 6, 7])</code></pre><p>これは、インデックス 1 の要素が 5、インデックス 2 の要素が 6、インデックス 3 の要素が <code>zero(Int)</code>、インデックス 4 の要素が 7 であることを示しています。</p><p><code>dense</code> ベクトルから直接スパースベクトルを作成するには、<code>sparse</code> を使用する方が便利な場合があります。</p><pre><code class="language-julia hljs">sparse([5, 6, 0, 7])</code></pre><p>は同じスパースベクトルを生成します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L13-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.SparseMatrixCSC" href="#SparseArrays.SparseMatrixCSC"><code>SparseArrays.SparseMatrixCSC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}</code></pre><p>疎行列を<a href="SparseArrays.html#man-csc">圧縮スパース列</a>形式で格納するための行列タイプ。SparseMatrixCSCを構築する標準的な方法は、<a href="SparseArrays.html#SparseArrays.sparse"><code>sparse</code></a>関数を通じてです。<a href="SparseArrays.html#SparseArrays.spzeros"><code>spzeros</code></a>、<a href="SparseArrays.html#SparseArrays.spdiagm"><code>spdiagm</code></a>、および<a href="SparseArrays.html#SparseArrays.sprand"><code>sprand</code></a>も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse(A)</code></pre><p>抽象行列 <code>A</code> を疎行列に変換します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Matrix(1.0I, 3, 3)
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; sparse(A)
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 1.0   ⋅    ⋅
  ⋅   1.0   ⋅
  ⋅    ⋅   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L996-L1015">source</a></section><section><div><pre><code class="language-julia hljs">sparse(I, J, V,[ m, n, combine])</code></pre><p>次のように、<code>S[I[k], J[k]] = V[k]</code> となる <code>m x n</code> のスパース行列 <code>S</code> を作成します。<code>combine</code> 関数は重複を結合するために使用されます。<code>m</code> と <code>n</code> が指定されていない場合、それぞれ <code>maximum(I)</code> と <code>maximum(J)</code> に設定されます。<code>combine</code> 関数が指定されていない場合、<code>combine</code> はデフォルトで <code>+</code> になりますが、<code>V</code> の要素がブール値の場合は <code>combine</code> はデフォルトで <code>|</code> になります。<code>I</code> のすべての要素は <code>1 &lt;= I[k] &lt;= m</code> を満たさなければならず、<code>J</code> のすべての要素は <code>1 &lt;= J[k] &lt;= n</code> を満たさなければなりません。<code>(I, J, V)</code> の数値ゼロは構造的な非ゼロとして保持されます。数値ゼロを削除するには、<a href="SparseArrays.html#SparseArrays.dropzeros!"><code>dropzeros!</code></a> を使用してください。</p><p>追加のドキュメントと専門的なドライバーについては、<code>SparseArrays.sparse!</code> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Is = [1; 2; 3];

julia&gt; Js = [1; 2; 3];

julia&gt; Vs = [1; 2; 3];

julia&gt; sparse(Is, Js, Vs)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 1  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1030-L1057">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse!" href="#SparseArrays.sparse!"><code>SparseArrays.sparse!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse!(I::AbstractVector{Ti}, J::AbstractVector{Ti}, V::AbstractVector{Tv},
        m::Integer, n::Integer, combine, klasttouch::Vector{Ti},
        csrrowptr::Vector{Ti}, csrcolval::Vector{Ti}, csrnzval::Vector{Tv},
        [csccolptr::Vector{Ti}], [cscrowval::Vector{Ti}, cscnzval::Vector{Tv}] ) where {Tv,Ti&lt;:Integer}</code></pre><p><a href="SparseArrays.html#SparseArrays.sparse"><code>sparse</code></a>の親および専門的なドライバー; 基本的な使用法については<a href="SparseArrays.html#SparseArrays.sparse"><code>sparse</code></a>を参照してください。このメソッドは、ユーザーが<code>sparse</code>の中間オブジェクトと結果のために事前に割り当てられたストレージを提供できるようにします。これにより、座標表現からの<a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>の効率的な連続構築が可能になり、結果の転置の非ソート列表現を追加コストなしで抽出することも可能になります。</p><p>このメソッドは、主に3つのステップで構成されています: (1) 提供された座標表現を、重複エントリを含む非ソート行CSR形式にカウントソートします。 (2) CSR形式をスイープしながら、目的のCSC形式の列ポインタ配列を同時に計算し、重複エントリを検出し、重複エントリを結合してCSR形式を再パッキングします。この段階では、重複エントリのない非ソート行CSR形式が得られます。 (3) 前のCSR形式を、重複エントリのない完全にソートされたCSC形式にカウントソートします。</p><p>入力配列<code>csrrowptr</code>、<code>csrcolval</code>、および<code>csrnzval</code>は、中間CSR形式のストレージを構成し、<code>length(csrrowptr) &gt;= m + 1</code>、<code>length(csrcolval) &gt;= length(I)</code>、および<code>length(csrnzval &gt;= length(I))</code>を必要とします。入力配列<code>klasttouch</code>は、第二段階の作業領域であり、<code>length(klasttouch) &gt;= n</code>を必要とします。オプションの入力配列<code>csccolptr</code>、<code>cscrowval</code>、および<code>cscnzval</code>は、返されるCSC形式<code>S</code>のストレージを構成します。必要に応じて、これらは自動的にサイズ変更され、<code>length(csccolptr) = n + 1</code>、<code>length(cscrowval) = nnz(S)</code>、および<code>length(cscnzval) = nnz(S)</code>を満たします。したがって、<code>nnz(S)</code>が最初から不明な場合は、適切な型の空のベクター（<code>Vector{Ti}()</code>および<code>Vector{Tv}()</code>）を渡すか、<code>cscrowval</code>および<code>cscnzval</code>を無視して<code>sparse!</code>メソッドを呼び出すだけで済みます。</p><p>戻り値として、<code>csrrowptr</code>、<code>csrcolval</code>、および<code>csrnzval</code>は、結果の転置の非ソート列表現を含みます。</p><p>入力配列のストレージ（<code>I</code>、<code>J</code>、<code>V</code>）を出力配列（<code>csccolptr</code>、<code>cscrowval</code>、<code>cscnzval</code>）に再利用することができます。たとえば、<code>sparse!(I, J, V, csrrowptr, csrcolval, csrnzval, I, J, V)</code>と呼び出すことができます。これらは上記の条件を満たすようにサイズ変更されます。</p><p>効率のために、このメソッドは<code>1 &lt;= I[k] &lt;= m</code>および<code>1 &lt;= J[k] &lt;= n</code>を超える引数チェックを行いません。注意して使用してください。<code>--check-bounds=yes</code>でのテストは賢明です。</p><p>このメソッドは<code>O(m, n, length(I))</code>の時間で実行されます。F. Gustavsonによって記述されたHALFPERMアルゴリズム、「スパース行列のための2つの高速アルゴリズム：乗算と順序付けられた転置」、ACM TOMS 4(3)、250-269 (1978)が、このメソッドのカウントソートのペアの使用にインスピレーションを与えました。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1102-L1149">source</a></section><section><div><pre><code class="language-julia hljs">SparseArrays.sparse!(I, J, V, [m, n, combine]) -&gt; SparseMatrixCSC</code></pre><p>入力ベクトル（<code>I</code>、<code>J</code>、<code>V</code>）を最終的な行列ストレージに再利用する<code>sparse!</code>のバリアントです。構築後、入力ベクトルは行列バッファをエイリアスします。<code>S.colptr === I</code>、<code>S.rowval === J</code>、および<code>S.nzval === V</code>が成り立ち、必要に応じて<code>resize!</code>されます。</p><p>いくつかの作業バッファはまだ割り当てられることに注意してください。具体的には、このメソッドは<code>sparse!(I, J, V, m, n, combine, klasttouch, csrrowptr, csrcolval, csrnzval, csccolptr, cscrowval, cscnzval)</code>の便利なラッパーであり、このメソッドは適切なサイズの<code>klasttouch</code>、<code>csrrowptr</code>、<code>csrcolval</code>、および<code>csrnzval</code>を割り当てますが、<code>csccolptr</code>、<code>cscrowval</code>、および<code>cscnzval</code>には<code>I</code>、<code>J</code>、および<code>V</code>を再利用します。</p><p>引数<code>m</code>、<code>n</code>、および<code>combine</code>はそれぞれ<code>maximum(I)</code>、<code>maximum(J)</code>、および<code>+</code>にデフォルト設定されています。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.10</header><div class="admonition-body"><p>このメソッドはJuliaバージョン1.10以降を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1292-L1310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparsevec" href="#SparseArrays.sparsevec"><code>SparseArrays.sparsevec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparsevec(I, V, [m, combine])</code></pre><p>長さ <code>m</code> のスパースベクトル <code>S</code> を作成し、<code>S[I[k]] = V[k]</code> となるようにします。重複は <code>combine</code> 関数を使用して結合され、<code>combine</code> 引数が提供されていない場合はデフォルトで <code>+</code> になります。ただし、<code>V</code> の要素がブール値の場合は、<code>combine</code> のデフォルトは <code>|</code> になります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia&gt; sparsevec(II, V)
5-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia&gt; sparsevec(II, V, 8, -)
8-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia&gt; sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool, Int64} with 3 stored entries:
  [1]  =  1
  [2]  =  0
  [3]  =  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L296-L326">source</a></section><section><div><pre><code class="language-julia hljs">sparsevec(d::Dict, [m])</code></pre><p>辞書のキーから非ゼロインデックスを持ち、辞書の値から非ゼロ値を持つ長さ <code>m</code> のスパースベクトルを作成します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sparsevec(Dict(1 =&gt; 3, 2 =&gt; 2))
2-element SparseVector{Int64, Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L374-L387">source</a></section><section><div><pre><code class="language-julia hljs">sparsevec(A)</code></pre><p>ベクトル <code>A</code> を長さ <code>m</code> のスパースベクトルに変換します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L510-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Tuple{SparseArrays.AbstractSparseMatrixCSC, Type}" href="#Base.similar-Tuple{SparseArrays.AbstractSparseMatrixCSC, Type}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar(A::AbstractSparseMatrixCSC{Tv,Ti}, [::Type{TvNew}, ::Type{TiNew}, m::Integer, n::Integer]) where {Tv,Ti}</code></pre><p>与えられた要素型、インデックス型、およびサイズに基づいて、指定されたソース <code>SparseMatrixCSC</code> に基づいて初期化されていない可変配列を作成します。新しいスパース行列は、出力行列の次元が異なる場合を除いて、元のスパース行列の構造を維持します。</p><p>出力行列は、入力と同じ位置にゼロを持ちますが、非ゼロの位置には初期化されていない値を持ちます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L708-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.issparse" href="#SparseArrays.issparse"><code>SparseArrays.issparse</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issparse(S)</code></pre><p><code>S</code>がスパースであれば<code>true</code>を返し、そうでなければ<code>false</code>を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sv = sparsevec([1, 4], [2.3, 2.2], 10)
10-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  2.3
  [4]  =  2.2

julia&gt; issparse(sv)
true

julia&gt; issparse(Array(sv))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/abstractsparse.jl#L45-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.nnz" href="#SparseArrays.nnz"><code>SparseArrays.nnz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nnz(A)</code></pre><p>スパース配列に格納されている（埋められた）要素の数を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  2

julia&gt; nnz(A)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L203-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.findnz" href="#SparseArrays.findnz"><code>SparseArrays.findnz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnz(A::SparseMatrixCSC)</code></pre><p>スパース行列 <code>A</code> における保存された（「構造的に非ゼロ」）値の行と列のインデックスを含むタプル <code>(I, J, V)</code> を返します。ここで、<code>I</code> と <code>J</code> はインデックス、<code>V</code> は値のベクトルです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1 2 0; 0 0 3; 0 4 0])
3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 1  2  ⋅
 ⋅  ⋅  3
 ⋅  4  ⋅

julia&gt; findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/abstractsparse.jl#L112-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.spzeros" href="#SparseArrays.spzeros"><code>SparseArrays.spzeros</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spzeros([type,]m[,n])</code></pre><p>長さ <code>m</code> のスパースベクトルまたはサイズ <code>m x n</code> のスパース行列を作成します。このスパース配列には非ゼロ値は含まれません。構築中に非ゼロ値のためのストレージは割り当てられません。タイプは指定されていない場合、デフォルトで <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> になります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spzeros(3, 3)
3×3 SparseMatrixCSC{Float64, Int64} with 0 stored entries:
  ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅
  ⋅    ⋅    ⋅

julia&gt; spzeros(Float32, 4)
4-element SparseVector{Float32, Int64} with 0 stored entries</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L2081-L2100">source</a></section><section><div><pre><code class="language-julia hljs">spzeros([type], I::AbstractVector, J::AbstractVector, [m, n])</code></pre><p>構造的ゼロが <code>S[I[k], J[k]]</code> にある <code>m x n</code> のスパース行列 <code>S</code> を作成します。</p><p>このメソッドは行列のスパースパターンを構築するために使用でき、例えば <code>sparse(I, J, zeros(length(I)))</code> を使用するよりも効率的です。</p><p>追加のドキュメントと専門的なドライバーについては、<code>SparseArrays.spzeros!</code> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.10</header><div class="admonition-body"><p>このメソッドは Julia バージョン 1.10 以降を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L2114-L2126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.spzeros!" href="#SparseArrays.spzeros!"><code>SparseArrays.spzeros!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spzeros!(::Type{Tv}, I::AbstractVector{Ti}, J::AbstractVector{Ti}, m::Integer, n::Integer,
         klasttouch::Vector{Ti}, csrrowptr::Vector{Ti}, csrcolval::Vector{Ti},
         [csccolptr::Vector{Ti}], [cscrowval::Vector{Ti}, cscnzval::Vector{Tv}]) where {Tv,Ti&lt;:Integer}</code></pre><p><code>spzeros(I, J)</code>の親および専門ドライバーであり、ユーザーが中間オブジェクトのための事前に割り当てられたストレージを提供できるようにします。このメソッドは、<code>spzeros</code>に対して<code>SparseArrays.sparse!</code>が<code>sparse</code>に対して行うことと同じです。詳細および必要なバッファの長さについては、<code>SparseArrays.sparse!</code>のドキュメントを参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.10</header><div class="admonition-body"><p>このメソッドは、Juliaバージョン1.10以降を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L2143-L2155">source</a></section><section><div><pre><code class="language-julia hljs">SparseArrays.spzeros!(::Type{Tv}, I, J, [m, n]) -&gt; SparseMatrixCSC{Tv}</code></pre><p>入力ベクトル <code>I</code> と <code>J</code> を最終的な行列ストレージに再利用する <code>spzeros!</code> のバリアント。構築後、入力ベクトルは行列バッファをエイリアスします；<code>S.colptr === I</code> および <code>S.rowval === J</code> が成り立ち、必要に応じて <code>resize!</code> されます。</p><p>いくつかの作業バッファはまだ割り当てられることに注意してください。具体的には、このメソッドは <code>spzeros!(Tv, I, J, m, n, klasttouch, csrrowptr, csrcolval, csccolptr, cscrowval)</code> の便利なラッパーであり、このメソッドは適切なサイズの <code>klasttouch</code>、<code>csrrowptr</code>、および <code>csrcolval</code> を割り当てますが、<code>csccolptr</code> と <code>cscrowval</code> に <code>I</code> と <code>J</code> を再利用します。</p><p>引数 <code>m</code> と <code>n</code> はそれぞれ <code>maximum(I)</code> と <code>maximum(J)</code> にデフォルト設定されています。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.10</header><div class="admonition-body"><p>このメソッドは Julia バージョン 1.10 以降を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L2166-L2182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.spdiagm" href="#SparseArrays.spdiagm"><code>SparseArrays.spdiagm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spdiagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)
spdiagm(m::Integer, n::Integer, kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</code></pre><p><code>Pair</code>のベクトルと対角線からスパース対角行列を構築します。各ベクトル<code>kv.second</code>は<code>kv.first</code>対角線に配置されます。デフォルトでは、行列は正方形であり、そのサイズは<code>kv</code>から推測されますが、必要に応じてゼロでパディングされた非正方形のサイズ<code>m</code>×<code>n</code>を最初の引数として渡すことで指定できます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spdiagm(-1 =&gt; [1,2,3,4], 1 =&gt; [4,3,2,1])
5×5 SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 ⋅  4  ⋅  ⋅  ⋅
 1  ⋅  3  ⋅  ⋅
 ⋅  2  ⋅  2  ⋅
 ⋅  ⋅  3  ⋅  1
 ⋅  ⋅  ⋅  4  ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L4203-L4223">source</a></section><section><div><pre><code class="language-julia hljs">spdiagm(v::AbstractVector)
spdiagm(m::Integer, n::Integer, v::AbstractVector)</code></pre><p>ベクトルの要素を対角要素とする疎行列を構築します。デフォルトでは（<code>m</code>と<code>n</code>が指定されていない場合）、行列は正方形で、そのサイズは<code>length(v)</code>によって決まりますが、最初の引数として<code>m</code>と<code>n</code>を渡すことで非正方形のサイズ<code>m</code>×<code>n</code>を指定することができます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>これらの関数は少なくともJulia 1.6を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spdiagm([1,2,3])
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 1  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  3

julia&gt; spdiagm(sparse([1,0,3]))
3×3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:
 1  ⋅  ⋅
 ⋅  ⋅  ⋅
 ⋅  ⋅  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L4227-L4253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse_hcat" href="#SparseArrays.sparse_hcat"><code>SparseArrays.sparse_hcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse_hcat(A...)</code></pre><p>次元2に沿って連結します。SparseMatrixCSCオブジェクトを返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>このメソッドはJulia 1.8で追加されました。これは、LinearAlgebra.jlからの特化された「スパース」行列型との連結が、SparseArray引数がない場合でも自動的にスパース出力を生成する以前の連結動作を模倣しています。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L1317-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse_vcat" href="#SparseArrays.sparse_vcat"><code>SparseArrays.sparse_vcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse_vcat(A...)</code></pre><p>次元1に沿って連結します。SparseMatrixCSCオブジェクトを返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>このメソッドはJulia 1.8で追加されました。これは、LinearAlgebra.jlからの特化された「スパース」行列タイプとの連結が、SparseArray引数がない場合でも自動的にスパース出力を生成する以前の連結動作を模倣します。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L1332-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse_hvcat" href="#SparseArrays.sparse_hvcat"><code>SparseArrays.sparse_hvcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sparse_hvcat(rows::Tuple{Vararg{Int}}, values...)</code></pre><p>スパースの水平および垂直の連結を1回の呼び出しで行います。この関数はブロック行列構文のために呼び出されます。最初の引数は、各ブロック行に連結する引数の数を指定します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>このメソッドはJulia 1.8で追加されました。これは、LinearAlgebra.jlからの特化された「スパース」行列型との連結が、SparseArray引数がない場合でも自動的にスパース出力を生成する以前の連結動作を模倣しています。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L1347-L1358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.blockdiag" href="#SparseArrays.blockdiag"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blockdiag(A...)</code></pre><p>行列をブロック対角に連結します。現在、スパース行列のみが実装されています。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))
5×5 SparseMatrixCSC{Int64, Int64} with 5 stored entries:
 2  ⋅  ⋅  ⋅  ⋅
 ⋅  2  ⋅  ⋅  ⋅
 ⋅  ⋅  2  ⋅  ⋅
 ⋅  ⋅  ⋅  4  ⋅
 ⋅  ⋅  ⋅  ⋅  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L3976-L3991">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sprand" href="#SparseArrays.sprand"><code>SparseArrays.sprand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sprand([rng],[T::Type],m,[n],p::AbstractFloat)
sprand([rng],m,[n],p::AbstractFloat,[rfn=rand])</code></pre><p>ランダムな長さ <code>m</code> のスパースベクトルまたは <code>m</code> x <code>n</code> のスパース行列を作成します。この行列では、任意の要素が非ゼロである確率は独立して <code>p</code> によって与えられ（したがって、非ゼロの平均密度も正確に <code>p</code> になります）。オプションの <code>rng</code> 引数は乱数生成器を指定し、<a href="Random.html#Random-Numbers">Random Numbers</a>を参照してください。オプションの <code>T</code> 引数は要素の型を指定し、デフォルトは <code>Float64</code> です。</p><p>デフォルトでは、非ゼロの値は一様分布からサンプリングされ、<a href="Random.html#Base.rand"><code>rand</code></a> 関数を使用します。つまり、<code>rand(T)</code> または <code>rng</code> が指定されている場合は <code>rand(rng, T)</code> になります。デフォルトの <code>T=Float64</code> の場合、これは <code>[0,1)</code> の範囲で一様にサンプリングされた非ゼロの値に対応します。</p><p>異なる分布から非ゼロの値をサンプリングするには、<code>rand</code> の代わりにカスタム <code>rfn</code> 関数を渡します。この関数は <code>rfn(k)</code> という形式で、希望する分布からサンプリングされた <code>k</code> 個の乱数の配列を返す必要があります。あるいは、<code>rng</code> が指定されている場合は、<code>rfn(rng, k)</code> という形式の関数である必要があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sprand(Bool, 2, 2, 0.5)
2×2 SparseMatrixCSC{Bool, Int64} with 2 stored entries:
 1  1
 ⋅  ⋅

julia&gt; sprand(Float64, 3, 0.75)
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  0.795547
  [2]  =  0.49425</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1994-L2026">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sprandn" href="#SparseArrays.sprandn"><code>SparseArrays.sprandn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sprandn([rng][,Type],m[,n],p::AbstractFloat)</code></pre><p>長さ <code>m</code> のランダムスパースベクトルまたはサイズ <code>m</code> x <code>n</code> のスパース行列を作成し、任意のエントリが非ゼロである確率 <code>p</code> を指定します。非ゼロの値は正規分布からサンプリングされます。オプションの <code>rng</code> 引数は乱数生成器を指定し、<a href="Random.html#Random-Numbers">Random Numbers</a>を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>出力要素型 <code>Type</code> を指定するには、少なくとも Julia 1.1 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sprandn(2, 2, 0.75)
2×2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 -1.20577     ⋅
  0.311817  -0.234641</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L2051-L2069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.nonzeros" href="#SparseArrays.nonzeros"><code>SparseArrays.nonzeros</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nonzeros(A)</code></pre><p>スパース配列 <code>A</code> の構造的な非ゼロ値のベクトルを返します。これには、スパース配列に明示的に格納されているゼロも含まれます。返されるベクトルは <code>A</code> の内部非ゼロストレージに直接ポイントしており、返されたベクトルへの変更は <code>A</code> も変化させます。<a href="SparseArrays.html#SparseArrays.rowvals"><code>rowvals</code></a> と <a href="SparseArrays.html#SparseArrays.nzrange"><code>nzrange</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  2

julia&gt; nonzeros(A)
3-element Vector{Int64}:
 2
 2
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L232-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.rowvals" href="#SparseArrays.rowvals"><code>SparseArrays.rowvals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rowvals(A::AbstractSparseMatrixCSC)</code></pre><p><code>A</code>の行インデックスのベクトルを返します。返されたベクトルに対する変更は、<code>A</code>も変更します。行インデックスが内部でどのように格納されているかにアクセスすることは、構造的な非ゼロ値を反復処理する際に便利です。<a href="SparseArrays.html#SparseArrays.nonzeros"><code>nonzeros</code></a>および<a href="SparseArrays.html#SparseArrays.nzrange"><code>nzrange</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(2I, 3, 3)
3×3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  ⋅  ⋅
 ⋅  2  ⋅
 ⋅  ⋅  2

julia&gt; rowvals(A)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L261-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.nzrange" href="#SparseArrays.nzrange"><code>SparseArrays.nzrange</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nzrange(A::AbstractSparseMatrixCSC, col::Integer)</code></pre><p>スパース行列の列の構造的非ゼロ値のインデックスの範囲を返します。<a href="SparseArrays.html#SparseArrays.nonzeros"><code>nonzeros</code></a>および<a href="SparseArrays.html#SparseArrays.rowvals"><code>rowvals</code></a>と組み合わせることで、スパース行列を便利に反復処理できます：</p><pre><code class="nohighlight hljs">A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for j = 1:n
   for i in nzrange(A, j)
      row = rows[i]
      val = vals[i]
      # スパースの魔法を実行...
   end
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>行列に非ゼロ要素を追加または削除すると、<code>nzrange</code>が無効になる可能性があるため、反復処理中に行列を変更しないでください。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L289-L310">source</a></section><section><div><pre><code class="language-julia hljs">nzrange(x::SparseVectorUnion, col)</code></pre><p>スパースベクトルの構造的非ゼロ値のインデックスの範囲を返します。列インデックス <code>col</code> は無視されます（<code>1</code> と仮定されます）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L123-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.droptol!" href="#SparseArrays.droptol!"><code>SparseArrays.droptol!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">droptol!(A::AbstractSparseMatrixCSC, tol)</code></pre><p><code>A</code>の絶対値が<code>tol</code>以下の格納された値を削除します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1858-L1862">source</a></section><section><div><pre><code class="language-julia hljs">droptol!(x::AbstractCompressedVector, tol)</code></pre><p><code>x</code>から絶対値が<code>tol</code>以下の格納された値を削除します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L2298-L2302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.dropzeros!" href="#SparseArrays.dropzeros!"><code>SparseArrays.dropzeros!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dropzeros!(x::AbstractCompressedVector)</code></pre><p><code>x</code>から保存された数値のゼロを削除します。</p><p>アウトオブプレースバージョンについては、<a href="SparseArrays.html#SparseArrays.dropzeros"><code>dropzeros</code></a>を参照してください。アルゴリズムに関する情報については、<code>fkeep!</code>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L2305-L2312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.dropzeros" href="#SparseArrays.dropzeros"><code>SparseArrays.dropzeros</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dropzeros(A::AbstractSparseMatrixCSC;)</code></pre><p><code>A</code>のコピーを生成し、そのコピーから保存された数値のゼロを削除します。</p><p>インプレースバージョンとアルゴリズム情報については、<a href="SparseArrays.html#SparseArrays.dropzeros!"><code>dropzeros!</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 1.0   ⋅    ⋅
  ⋅   0.0   ⋅
  ⋅    ⋅   1.0

julia&gt; dropzeros(A)
3×3 SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   ⋅    ⋅
  ⋅    ⋅    ⋅
  ⋅    ⋅   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1877-L1898">source</a></section><section><div><pre><code class="language-julia hljs">dropzeros(x::AbstractCompressedVector)</code></pre><p><code>x</code>のコピーを生成し、そのコピーから数値のゼロを削除します。</p><p>インプレースバージョンおよびアルゴリズム情報については、<a href="SparseArrays.html#SparseArrays.dropzeros!"><code>dropzeros!</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia&gt; dropzeros(A)
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsevector.jl#L2316-L2336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.permute" href="#SparseArrays.permute"><code>SparseArrays.permute</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
        q::AbstractVector{&lt;:Integer}) where {Tv,Ti}</code></pre><p>行列 <code>A</code> を双方向に置換し、<code>PAQ</code>（<code>A[p,q]</code>）を返します。列置換 <code>q</code> の長さは <code>A</code> の列数と一致する必要があります（<code>length(q) == size(A, 2)</code>）。行置換 <code>p</code> の長さは <code>A</code> の行数と一致する必要があります（<code>length(p) == size(A, 1)</code>）。</p><p>詳細情報と専門的なドライバーについては、<a href="../base/arrays.html#Base.permute!-Tuple{Any, AbstractVector}"><code>permute!</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = spdiagm(0 =&gt; [1, 2, 3, 4], 1 =&gt; [5, 6, 7])
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 1  5  ⋅  ⋅
 ⋅  2  6  ⋅
 ⋅  ⋅  3  7
 ⋅  ⋅  ⋅  4

julia&gt; permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 ⋅  ⋅  ⋅  4
 ⋅  ⋅  3  7
 ⋅  2  6  ⋅
 1  5  ⋅  ⋅

julia&gt; permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4×4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 ⋅  ⋅  5  1
 ⋅  6  2  ⋅
 7  3  ⋅  ⋅
 4  ⋅  ⋅  ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1717-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp&lt;:Integer, Tq&lt;:Integer}" href="#Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp&lt;:Integer, Tq&lt;:Integer}"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},
         p::AbstractVector{&lt;:Integer}, q::AbstractVector{&lt;:Integer},
         [C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}</code></pre><p>行列 <code>A</code> を双方向に置換し、結果 <code>PAQ</code> (<code>A[p,q]</code>) を <code>X</code> に格納します。オプション引数 <code>C</code> が存在する場合、中間結果 <code>(AQ)^T</code> (<code>transpose(A[:,q])</code>) を <code>C</code> に格納します。<code>X</code>、<code>A</code>、および、存在する場合は <code>C</code> が互いにエイリアスしないことが必要です。結果 <code>PAQ</code> を <code>A</code> に戻すには、<code>X</code> を欠いた以下のメソッドを使用します：</p><pre><code class="nohighlight hljs">permute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
         q::AbstractVector{&lt;:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},
         [workcolptr::Vector{Ti}]]) where {Tv,Ti}</code></pre><p><code>X</code> の次元は <code>A</code> の次元と一致しなければなりません（<code>size(X, 1) == size(A, 1)</code> および <code>size(X, 2) == size(A, 2)</code>）、また <code>X</code> は <code>A</code> のすべての割り当てられたエントリを収容するのに十分なストレージを持っていなければなりません（<code>length(rowvals(X)) &gt;= nnz(A)</code> および <code>length(nonzeros(X)) &gt;= nnz(A)</code>）。列置換 <code>q</code> の長さは <code>A</code> の列数と一致しなければなりません（<code>length(q) == size(A, 2)</code>）。行置換 <code>p</code> の長さは <code>A</code> の行数と一致しなければなりません（<code>length(p) == size(A, 1)</code>）。</p><p><code>C</code> の次元は <code>transpose(A)</code> の次元と一致しなければなりません（<code>size(C, 1) == size(A, 2)</code> および <code>size(C, 2) == size(A, 1)</code>）、また <code>C</code> は <code>A</code> のすべての割り当てられたエントリを収容するのに十分なストレージを持っていなければなりません（<code>length(rowvals(C)) &gt;= nnz(A)</code> および <code>length(nonzeros(C)) &gt;= nnz(A)</code>）。</p><p>追加の（アルゴリズム的な）情報や、引数チェックを省略したこれらのメソッドのバージョンについては、（エクスポートされていない）親メソッド <code>unchecked_noalias_permute!</code> および <code>unchecked_aliasing_permute!</code> を参照してください。</p><p>また、<a href="SparseArrays.html#SparseArrays.permute"><code>permute</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1639-L1668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.halfperm!" href="#SparseArrays.halfperm!"><code>SparseArrays.halfperm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">halfperm!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{TvA,Ti},
          q::AbstractVector{&lt;:Integer}, f::Function = identity) where {Tv,TvA,Ti}</code></pre><p>列を入れ替え、<code>A</code>を転置し、同時に<code>A</code>の各エントリに<code>f</code>を適用し、その結果<code>(f(A)Q)^T</code>（<code>map(f, transpose(A[:,q]))</code>）を<code>X</code>に格納します。</p><p><code>X</code>の要素型<code>Tv</code>は<code>f(::TvA)</code>と一致しなければなりません。ここで、<code>TvA</code>は<code>A</code>の要素型です。<code>X</code>の次元は<code>transpose(A)</code>の次元と一致しなければならず（<code>size(X, 1) == size(A, 2}</code>および<code>size(X, 2) == size(A, 1)</code>）、<code>X</code>は<code>A</code>のすべての割り当てられたエントリを収容できるだけのストレージを持っていなければなりません（<code>length(rowvals(X)) &gt;= nnz(A}</code>および<code>length(nonzeros(X)) &gt;= nnz(A)</code>）。列の入れ替え<code>q</code>の長さは<code>A</code>の列数と一致しなければなりません（<code>length(q) == size(A, 2)</code>）。</p><p>このメソッドは、<a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>に対する転置および入れ替え操作を実行するいくつかのメソッドの親です。このメソッドは引数のチェックを行わないため、直接使用するのではなく、安全な子メソッド（<code>[c]transpose[!]</code>、<code>permute[!]</code>）を使用することをお勧めします。</p><p>このメソッドは、F. Gustavsonによって記述された<code>HALFPERM</code>アルゴリズムを実装しています。「スパース行列のための2つの高速アルゴリズム：乗算と入れ替え転置」、ACM TOMS 4(3)、250-269 (1978)。このアルゴリズムは<code>O(size(A, 1), size(A, 2), nnz(A))</code>の時間で実行され、渡されたもの以外のスペースは必要ありません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1336-L1357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.ftranspose!" href="#SparseArrays.ftranspose!"><code>SparseArrays.ftranspose!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ftranspose!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti}, f::Function) where {Tv,Ti}</code></pre><p>行列 <code>A</code> を転置し、非ゼロ要素に関数 <code>f</code> を適用しながら <code>X</code> に格納します。<code>f</code> によって生成されたゼロは削除されません。<code>size(X)</code> は <code>size(transpose(A))</code> と等しくなければなりません。必要に応じて <code>X</code> の rowval と nzval のサイズ変更以外に追加のメモリは割り当てられません。</p><p><code>halfperm!</code> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1405-L1413">source</a></section></article><h1 id="stdlib-sparse-linalg-api"><a class="docs-heading-anchor" href="#stdlib-sparse-linalg-api">Sparse Linear Algebra API</a><a id="stdlib-sparse-linalg-api-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-sparse-linalg-api" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky-stdlib-SparseArrays" href="#LinearAlgebra.cholesky-stdlib-SparseArrays"><code>LinearAlgebra.cholesky</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cholesky(A, NoPivot(); check = true) -&gt; Cholesky</code></pre><p>密な対称正定値行列 <code>A</code> のコレスキー分解を計算し、<a href="LinearAlgebra.html#LinearAlgebra.Cholesky"><code>Cholesky</code></a> 分解を返します。行列 <code>A</code> は、<a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <a href="../base/arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> であるか、<em>完全に</em> 対称またはエルミートな <code>AbstractMatrix</code> である必要があります。</p><p>三角形のコレスキー因子は、分解 <code>F</code> から <code>F.L</code> および <code>F.U</code> を介して取得でき、<code>A ≈ F.U&#39; * F.U ≈ F.L * F.L&#39;</code> となります。</p><p><code>Cholesky</code> オブジェクトに対して利用可能な関数は、<a href="../base/arrays.html#Base.size"><code>size</code></a>、<a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>、<a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a> および <a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a> です。</p><p>構築時の丸め誤差により行列 <code>A</code> がわずかに非エルミートである場合は、<code>cholesky</code> に渡す前に <code>Hermitian(A)</code> でラップして、完全にエルミートとして扱います。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Matrix{Float64}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64, Matrix{Float64}}
U因子:
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.U
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.L
3×3 LowerTriangular{Float64, Matrix{Float64}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L349-L400">source</a></section><section><div><pre><code class="language-julia hljs">cholesky(A, RowMaximum(); tol = 0.0, check = true) -&gt; CholeskyPivoted</code></pre><p>密な対称半正定値行列 <code>A</code> のピボット付きコレスキー分解を計算し、<a href="LinearAlgebra.html#LinearAlgebra.CholeskyPivoted"><code>CholeskyPivoted</code></a> 分解を返します。行列 <code>A</code> は、<a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <a href="../base/arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> であるか、<em>完全に</em> 対称またはエルミートな <code>AbstractMatrix</code> である必要があります。</p><p>三角形のコレスキー因子は、分解 <code>F</code> から <code>F.L</code> と <code>F.U</code> を介して取得でき、置換は <code>F.p</code> を介して取得できます。ここで、<code>A[F.p, F.p] ≈ Ur&#39; * Ur ≈ Lr * Lr&#39;</code> であり、<code>Ur = F.U[1:F.rank, :]</code> および <code>Lr = F.L[:, 1:F.rank]</code> です。または、<code>A ≈ Up&#39; * Up ≈ Lp * Lp&#39;</code> であり、<code>Up = F.U[1:F.rank, invperm(F.p)]</code> および <code>Lp = F.L[invperm(F.p), 1:F.rank]</code> です。</p><p><code>CholeskyPivoted</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/arrays.html#Base.size"><code>size</code></a>, <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>, <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, および <a href="LinearAlgebra.html#LinearAlgebra.rank"><code>rank</code></a>。</p><p>引数 <code>tol</code> は、ランクを決定するための許容誤差を決定します。負の値の場合、許容誤差は機械精度です。</p><p>構築時の丸め誤差により、行列 <code>A</code> がわずかに非エルミートである場合は、<code>cholesky</code> に渡す前に <code>Hermitian(A)</code> でラップして、完全にエルミートとして扱います。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = [1.0, 2.0, 3.0, 4.0];

julia&gt; A = X * X&#39;;

julia&gt; C = cholesky(A, RowMaximum(), check = false)
CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}
U因子のランクは1:
4×4 UpperTriangular{Float64, Matrix{Float64}}:
 4.0  2.0  3.0  1.0
  ⋅   0.0  6.0  2.0
  ⋅    ⋅   9.0  3.0
  ⋅    ⋅    ⋅   1.0
置換:
4要素のベクトル{Int64}:
 4
 2
 3
 1

julia&gt; C.U[1:C.rank, :]&#39; * C.U[1:C.rank, :] ≈ A[C.p, C.p]
true

julia&gt; l, u = C; # 繰り返しによる分解

julia&gt; l == C.L &amp;&amp; u == C.U
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L414-L468">source</a></section><section><div><pre><code class="language-julia hljs">cholesky(A::SparseMatrixCSC; shift = 0.0, check = true, perm = nothing) -&gt; CHOLMOD.Factor</code></pre><p>スパースの正定値行列 <code>A</code> のコレスキー分解を計算します。<code>A</code> は <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> または <code>SparseMatrixCSC</code> の <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> ビューでなければなりません。<code>A</code> に型タグがなくても、対称またはエルミートである必要があります。<code>perm</code> が指定されていない場合、フィル削減置換が使用されます。<code>F = cholesky(A)</code> は、<code>F\b</code> を使用して方程式系を解くために最も頻繁に使用されますが、<a href="LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、および <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a> のメソッドも <code>F</code> に対して定義されています。<code>F</code> から個々の因子を抽出することもでき、<code>F.L</code> を使用します。ただし、ピボットがデフォルトでオンになっているため、分解は内部的に <code>A == P&#39;*L*L&#39;*P</code> として表現され、置換行列 <code>P</code> が含まれます。<code>P</code> を考慮せずに <code>L</code> のみを使用すると、誤った結果が得られます。置換の効果を含めるためには、通常、<code>PtL = F.PtL</code>（<code>P&#39;*L</code> の同等物）や <code>LtP = F.UP</code>（<code>L&#39;*P</code> の同等物）などの「結合」因子を抽出する方が好ましいです。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p>オプションの <code>shift</code> キーワード引数を設定すると、<code>A</code> の代わりに <code>A+shift*I</code> の分解が計算されます。<code>perm</code> 引数が提供される場合、それは <code>1:size(A,1)</code> の置換であり、使用する順序を指定します（CHOLMOD のデフォルトの AMD 順序の代わりに）。</p><p><strong>例</strong></p><p>次の例では、使用されるフィル削減置換は <code>[3, 2, 1]</code> です。<code>perm</code> が <code>1:3</code> に設定されて置換が行われない場合、因子内の非ゼロ要素の数は 6 になります。</p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 1 1; 1 2 0; 1 0 2]
3×3 Matrix{Int64}:
 2  1  1
 1  2  0
 1  0  2

julia&gt; C = cholesky(sparse(A))
SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  5
nnz:     5
success: true

julia&gt; C.p
3-element Vector{Int64}:
 3
 2
 1

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Matrix{Float64}:
 1.41421   0.0       0.0
 0.0       1.41421   0.0
 0.707107  0.707107  1.0

julia&gt; L * L&#39; ≈ A[C.p, C.p]
true

julia&gt; P = sparse(1:3, C.p, ones(3))
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
  ⋅    ⋅   1.0
  ⋅   1.0   ⋅
 1.0   ⋅    ⋅

julia&gt; P&#39; * L * L&#39; * P ≈ A
true

julia&gt; C = cholesky(sparse(A), perm=1:3)
SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  6
nnz:     6
success: true

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Matrix{Float64}:
 1.41421    0.0       0.0
 0.707107   1.22474   0.0
 0.707107  -0.408248  1.1547

julia&gt; L * L&#39; ≈ A
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の CHOLMOD<sup class="footnote-reference"><a id="citeref-ACM887" href="#footnote-ACM887">[ACM887]</a></sup><sup class="footnote-reference"><a id="citeref-DavisHager2009" href="#footnote-DavisHager2009">[DavisHager2009]</a></sup> ライブラリを使用しています。CHOLMOD は、単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p><p>CHOLMOD からの他の多くの関数はラップされていますが、<code>Base.SparseArrays.CHOLMOD</code> モジュールからはエクスポートされていません。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1502-L1608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky!-stdlib-SparseArrays" href="#LinearAlgebra.cholesky!-stdlib-SparseArrays"><code>LinearAlgebra.cholesky!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cholesky!(A::AbstractMatrix, NoPivot(); check = true) -&gt; Cholesky</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> と同じですが、入力 <code>A</code> を上書きすることでスペースを節約します。コピーを作成するのではありません。因子分解が <code>A</code> の要素型で表現できない数を生成した場合、例えば整数型の場合、<a href="../base/base.html#Core.InexactError"><code>InexactError</code></a> 例外がスローされます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 2 50]
2×2 Matrix{Int64}:
 1   2
 2  50

julia&gt; cholesky!(A)
ERROR: InexactError: Int64(6.782329983125268)
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L274-L294">source</a></section><section><div><pre><code class="language-julia hljs">cholesky!(A::AbstractMatrix, RowMaximum(); tol = 0.0, check = true) -&gt; CholeskyPivoted</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> と同様ですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。因子分解が <code>A</code> の要素型で表現できない数を生成した場合、例えば整数型の場合、<a href="../base/base.html#Core.InexactError"><code>InexactError</code></a> 例外がスローされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L325-L332">source</a></section><section><div><pre><code class="language-julia hljs">cholesky!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -&gt; CHOLMOD.Factor</code></pre><p>行列 <code>A</code> のコレスキー (<span>$LL&#39;$</span>) 分解を計算し、シンボリック分解 <code>F</code> を再利用します。<code>A</code> は <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/ <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> の <code>SparseMatrixCSC</code> のビューでなければなりません。<code>A</code> が型タグを持っていなくても、対称またはエルミートである必要があります。</p><p>詳細は <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> を参照してください。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、SuiteSparse の CHOLMOD ライブラリを使用しており、これは単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1466-L1481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankupdate-stdlib-SparseArrays" href="#LinearAlgebra.lowrankupdate-stdlib-SparseArrays"><code>LinearAlgebra.lowrankupdate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankupdate(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> を更新します。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U + v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の演算のみを使用します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L821-L827">source</a></section><section><div><pre><code class="language-julia hljs">lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -&gt; FF::CHOLMOD.Factor</code></pre><p><code>A + C*C&#39;</code>の<code>LDLt</code>因子分解を、<code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を与えて取得します。</p><p>返される因子は常に<code>LDLt</code>因子分解です。</p><p>他にも<a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate!"><code>lowrankupdate!</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate"><code>lowrankdowndate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate!"><code>lowrankdowndate!</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1767-L1775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankupdate!-stdlib-SparseArrays" href="#LinearAlgebra.lowrankupdate!-stdlib-SparseArrays"><code>LinearAlgebra.lowrankupdate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankupdate!(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> を更新します。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U + v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の演算のみを使用します。入力の分解 <code>C</code> はインプレースで更新され、終了時には <code>C == CC</code> となります。ベクトル <code>v</code> は計算中に破棄されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L722-L729">source</a></section><section><div><pre><code class="language-julia hljs">lowrankupdate!(F::CHOLMOD.Factor, C::AbstractArray)</code></pre><p><code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を<code>A + C*C&#39;</code>の因子分解に更新します。</p><p><code>LLt</code>因子分解は<code>LDLt</code>に変換されます。</p><p><a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate"><code>lowrankupdate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate"><code>lowrankdowndate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate!"><code>lowrankdowndate!</code></a>も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1737-L1745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate-stdlib-SparseArrays" href="#LinearAlgebra.lowrankdowndate-stdlib-SparseArrays"><code>LinearAlgebra.lowrankdowndate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankdowndate(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> をダウンドデートします。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U - v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の演算のみを使用します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L830-L836">source</a></section><section><div><pre><code class="language-julia hljs">lowrankdowndate(F::CHOLMOD.Factor, C::AbstractArray) -&gt; FF::CHOLMOD.Factor</code></pre><p><code>A + C*C&#39;</code> の <code>LDLt</code> 因子分解を、<code>A</code> の <code>LDLt</code> または <code>LLt</code> 因子分解 <code>F</code> に基づいて取得します。</p><p>返される因子は常に <code>LDLt</code> 因子分解です。</p><p>他にも <a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate!"><code>lowrankdowndate!</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate"><code>lowrankupdate</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate!"><code>lowrankupdate!</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1782-L1790">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate!-stdlib-SparseArrays" href="#LinearAlgebra.lowrankdowndate!-stdlib-SparseArrays"><code>LinearAlgebra.lowrankdowndate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankdowndate!(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> をダウンドデートします。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U - v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の操作のみを使用します。入力の分解 <code>C</code> はインプレースで更新され、終了時には <code>C == CC</code> となります。ベクトル <code>v</code> は計算中に破棄されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L768-L775">source</a></section><section><div><pre><code class="language-julia hljs">lowrankdowndate!(F::CHOLMOD.Factor, C::AbstractArray)</code></pre><p><code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を<code>A - C*C&#39;</code>の因子分解に更新します。</p><p><code>LLt</code>因子分解は<code>LDLt</code>に変換されます。</p><p><a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate"><code>lowrankdowndate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate"><code>lowrankupdate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate!"><code>lowrankupdate!</code></a>も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1752-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.CHOLMOD.lowrankupdowndate!-stdlib-SparseArrays" href="#SparseArrays.CHOLMOD.lowrankupdowndate!-stdlib-SparseArrays"><code>SparseArrays.CHOLMOD.lowrankupdowndate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankupdowndate!(F::CHOLMOD.Factor, C::Sparse, update::Cint)</code></pre><p><code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を<code>A ± C*C&#39;</code>の因子分解に更新します。</p><p>スパース性を保持する因子分解が使用されている場合、すなわち<code>L*L&#39; == P*A*P&#39;</code>であれば、新しい因子は<code>L*L&#39; == P*A*P&#39; + C&#39;*C</code>になります。</p><p><code>update</code>: <code>Cint(1)</code>は<code>A + CC&#39;</code>、<code>Cint(0)</code>は<code>A - CC&#39;</code>です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1721-L1730">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldlt-stdlib-SparseArrays" href="#LinearAlgebra.ldlt-stdlib-SparseArrays"><code>LinearAlgebra.ldlt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldlt(S::SymTridiagonal) -&gt; LDLt</code></pre><p>実数対称三重対角行列 <code>S</code> の <code>LDLt</code>（すなわち、<span>$LDL^T$</span>）因子分解を計算します。ここで、<code>S = L*Diagonal(d)*L&#39;</code> となり、<code>L</code> は単位下三角行列、<code>d</code> はベクトルです。<code>LDLt</code> 因子分解 <code>F = ldlt(S)</code> の主な用途は、線形方程式系 <code>Sx = b</code> を <code>F\b</code> で解くことです。</p><p>類似の、しかしピボットされた任意の対称またはエルミート行列の因子分解については、<a href="LinearAlgebra.html#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt(S);

julia&gt; b = [6., 7., 8.];

julia&gt; ldltS \ b
3-element Vector{Float64}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia&gt; S \ b
3-element Vector{Float64}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/ldlt.jl#L129-L162">source</a></section><section><div><pre><code class="language-julia hljs">ldlt(A::SparseMatrixCSC; shift = 0.0, check = true, perm=nothing) -&gt; CHOLMOD.Factor</code></pre><p>スパース行列 <code>A</code> の <span>$LDL&#39;$</span> 分解を計算します。<code>A</code> は <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> または <code>SparseMatrixCSC</code> の <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> ビューでなければなりません。<code>A</code> が型タグを持っていなくても、対称またはエルミートである必要があります。フィル削減置換が使用されます。<code>F = ldlt(A)</code> は、方程式系 <code>A*x = b</code> を <code>F\b</code> で解くために最も頻繁に使用されます。返される分解オブジェクト <code>F</code> は、<a href="LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a>、および <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a> メソッドもサポートしています。<code>F</code> から個々の因子を <code>F.L</code> を使用して抽出できます。ただし、ピボッティングがデフォルトでオンになっているため、分解は内部的に <code>A == P&#39;*L*D*L&#39;*P</code> として表現され、置換行列 <code>P</code> が含まれます。<code>P</code> を考慮せずに単に <code>L</code> を使用すると、誤った結果が得られます。置換の影響を含めるためには、通常、<code>PtL = F.PtL</code>（<code>P&#39;*L</code> の同等物）や <code>LtP = F.UP</code>（<code>L&#39;*P</code> の同等物）などの「結合」因子を抽出する方が好ましいです。サポートされている因子の完全なリストは <code>:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP</code> です。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p>オプションの <code>shift</code> キーワード引数を設定すると、<code>A</code> の代わりに <code>A+shift*I</code> の分解が計算されます。<code>perm</code> 引数が提供される場合、それは <code>1:size(A,1)</code> の置換であり、使用する順序を指定します（CHOLMOD のデフォルトの AMD 順序の代わりに）。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の CHOLMOD<sup class="footnote-reference"><a id="citeref-ACM887" href="#footnote-ACM887">[ACM887]</a></sup><sup class="footnote-reference"><a id="citeref-DavisHager2009" href="#footnote-DavisHager2009">[DavisHager2009]</a></sup> ライブラリを使用しています。CHOLMOD は、単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p><p>CHOLMOD の他の多くの関数はラップされていますが、<code>Base.SparseArrays.CHOLMOD</code> モジュールからはエクスポートされていません。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1675-L1712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lu-stdlib-SparseArrays" href="#LinearAlgebra.lu-stdlib-SparseArrays"><code>LinearAlgebra.lu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lu(A::AbstractSparseMatrixCSC; check = true, q = nothing, control = get_umfpack_control()) -&gt; F::UmfpackLU</code></pre><p>スパース行列 <code>A</code> のLU因子分解を計算します。</p><p>実数または複素数要素型のスパース <code>A</code> の場合、<code>F</code> の戻り値の型は <code>UmfpackLU{Tv, Ti}</code> であり、<code>Tv</code> は <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> でそれぞれ、<code>Ti</code> は整数型（<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a> または <a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>）です。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p>置換 <code>q</code> は置換ベクトルまたは <code>nothing</code> である可能性があります。置換ベクトルが提供されない場合や <code>q</code> が <code>nothing</code> の場合、UMFPACKのデフォルトが使用されます。置換がゼロベースでない場合、ゼロベースのコピーが作成されます。</p><p><code>control</code> ベクトルは、UMFPACKのためのJulia SparseArraysパッケージのデフォルト設定にデフォルトで設定されます（注：これは反復精度を無効にするためにUMFPACKのデフォルトから修正されています）が、<code>UMFPACK_CONTROL</code> の長さのベクトルを渡すことで変更できます。可能な設定についてはUMFPACKマニュアルを参照してください。たとえば、反復精度を再有効にするには：</p><pre><code class="nohighlight hljs">umfpack_control = SparseArrays.UMFPACK.get_umfpack_control(Float64, Int64) # Float64スパース行列のためのJuliaデフォルト設定を読み取る
SparseArrays.UMFPACK.show_umf_ctrl(umfpack_control) # オプション - 値を表示
umfpack_control[SparseArrays.UMFPACK.JL_UMFPACK_IRSTEP] = 2.0 # 反復精度を再有効にする（2はUMFPACKのデフォルトの最大反復精度ステップ）

Alu = lu(A; control = umfpack_control)
x = Alu \ b   # Ax = bを解く、UMFPACKの反復精度を含む</code></pre><p>因子分解 <code>F</code> の個々のコンポーネントにはインデックスを使用してアクセスできます：</p><table><tr><th style="text-align: left">コンポーネント</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>L</code></td><td style="text-align: left"><code>LU</code> の下三角部分 <code>L</code></td></tr><tr><td style="text-align: left"><code>U</code></td><td style="text-align: left"><code>LU</code> の上三角部分 <code>U</code></td></tr><tr><td style="text-align: left"><code>p</code></td><td style="text-align: left">右置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>q</code></td><td style="text-align: left">左置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>Rs</code></td><td style="text-align: left">スケーリングファクターの <code>Vector</code></td></tr><tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>(L,U,p,q,Rs)</code> コンポーネント</td></tr></table><p><code>F</code> と <code>A</code> の関係は次の通りです。</p><p><code>F.L*F.U == (F.Rs .* A)[F.p, F.q]</code></p><p><code>F</code> はさらに以下の関数をサポートしています：</p><ul><li><a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a></li><li><a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a></li></ul><p>また <a href="LinearAlgebra.html#LinearAlgebra.lu!"><code>lu!</code></a> も参照してください。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>lu(A::AbstractSparseMatrixCSC)</code> は、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の一部であるUMFPACK<sup class="footnote-reference"><a id="citeref-ACM832" href="#footnote-ACM832">[ACM832]</a></sup>ライブラリを使用します。このライブラリは、<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> 要素を持つスパース行列のみをサポートしているため、<code>lu</code> は <code>A</code> を <code>SparseMatrixCSC{Float64}</code> または <code>SparseMatrixCSC{ComplexF64}</code> 型のコピーに変換します。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/umfpack.jl#L325-L383">source</a></section><section><div><pre><code class="language-julia hljs">lu(A, pivot = RowMaximum(); check = true, allowsingular = false) -&gt; F::LU</code></pre><p>行列 <code>A</code> の LU 分解を計算します。</p><p><code>check = true</code> の場合、分解が失敗した場合にエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任はユーザーにあります（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）。</p><p>デフォルトでは、<code>check = true</code> の場合、分解が有効な因子を生成しても、上三角因子 <code>U</code> がランク欠損の場合にもエラーがスローされます。これは <code>allowsingular = true</code> を渡すことで変更できます。</p><p>ほとんどの場合、<code>A</code> が要素型 <code>T</code> を持ち、<code>+</code>、<code>-</code>、<code>*</code> および <code>/</code> をサポートする <code>AbstractMatrix{T}</code> のサブタイプ <code>S</code> である場合、戻り値の型は <code>LU{T,S{T}}</code> です。</p><p>一般に、LU 分解は行列の行の順序を入れ替えることを含みます（以下に説明する <code>F.p</code> 出力に対応）、これは「ピボット」と呼ばれます（これは「ピボット」を含む行を選択することに対応し、<code>F.U</code> の対角成分です）。次のいずれかのピボット戦略をオプションの <code>pivot</code> 引数を介して選択できます：</p><ul><li><code>RowMaximum()</code>（デフォルト）：標準のピボット戦略；ピボットは、残りの因子化される行の中で最大絶対値を持つ要素に対応します。このピボット戦略は、要素型が <a href="../base/math.html#Base.abs"><code>abs</code></a> および <a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a> をサポートすることを要求します。（これは一般に浮動小数点行列に対して唯一の数値的に安定したオプションです。）</li><li><code>RowNonZero()</code>: ピボットは、残りの因子化される行の中で最初の非ゼロ要素に対応します。（これは手計算での典型的な選択に対応し、<code>abs</code> や <code>&lt;</code> をサポートしないより一般的な代数数型にも便利です。）</li><li><code>NoPivot()</code>: ピボットをオフにします（<code>allowsingular = true</code> の場合でも、ピボット位置でゼロエントリに遭遇すると失敗します）。</li></ul><p>分解 <code>F</code> の個々のコンポーネントには <a href="../base/base.html#Base.getproperty"><code>getproperty</code></a> を介してアクセスできます：</p><table><tr><th style="text-align: left">コンポーネント</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>F.L</code></td><td style="text-align: left"><code>LU</code> の <code>L</code>（下三角）部分</td></tr><tr><td style="text-align: left"><code>F.U</code></td><td style="text-align: left"><code>LU</code> の <code>U</code>（上三角）部分</td></tr><tr><td style="text-align: left"><code>F.p</code></td><td style="text-align: left">（右）置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>F.P</code></td><td style="text-align: left">（右）置換 <code>Matrix</code></td></tr></table><p>分解を反復すると、コンポーネント <code>F.L</code>、<code>F.U</code>、および <code>F.p</code> が得られます。</p><p><code>F</code> と <code>A</code> の関係は次の通りです。</p><p><code>F.L*F.U == A[F.p, :]</code></p><p><code>F</code> はさらに次の関数をサポートします：</p><table><tr><th style="text-align: left">サポートされる関数</th><th style="text-align: left"><code>LU</code></th><th style="text-align: left"><code>LU{T,Tridiagonal{T}}</code></th></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:/"><code>/</code></a></td><td style="text-align: left">✓</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.logabsdet"><code>logabsdet</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="../base/arrays.html#Base.size"><code>size</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr></table><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>allowsingular</code> キーワード引数は Julia 1.11 で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4 3; 6 3]
2×2 Matrix{Int64}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L factor:
2×2 Matrix{Float64}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Matrix{Float64}:
 6.0  3.0
 0.0  1.0

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # 反復を介した分解

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true

julia&gt; lu([1 2; 1 2], allowsingular = true)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L factor:
2×2 Matrix{Float64}:
 1.0  0.0
 1.0  1.0
U factor (rank-deficient):
2×2 Matrix{Float64}:
 1.0  2.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lu.jl#L240-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.qr-stdlib-SparseArrays" href="#LinearAlgebra.qr-stdlib-SparseArrays"><code>LinearAlgebra.qr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr(A::SparseMatrixCSC; tol=_default_tol(A), ordering=ORDERING_DEFAULT) -&gt; QRSparse</code></pre><p>スパース行列 <code>A</code> の <code>QR</code> 分解を計算します。フィル削減行と列の置換が使用され、<code>F.R = F.Q&#39;*A[F.prow,F.pcol]</code> となります。このタイプの主な用途は、<a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a> を使用して最小二乗または過剰決定問題を解決することです。この関数は C ライブラリ SPQR<sup class="footnote-reference"><a id="citeref-ACM933" href="#footnote-ACM933">[ACM933]</a></sup> を呼び出します。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>qr(A::SparseMatrixCSC)</code> は <a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の一部である SPQR ライブラリを使用します。このライブラリは <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> 要素を持つスパース行列のみをサポートしているため、Julia v1.4 以降、<code>qr</code> は <code>A</code> を <code>SparseMatrixCSC{Float64}</code> または <code>SparseMatrixCSC{ComplexF64}</code> 型のコピーに変換します。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1,2,3,4], [1,1,2,2], [1.0,1.0,1.0,1.0])
4×2 SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0   ⋅
 1.0   ⋅
  ⋅   1.0
  ⋅   1.0

julia&gt; qr(A)
SparseArrays.SPQR.QRSparse{Float64, Int64}
Q 因子:
4×4 SparseArrays.SPQR.QRSparseQ{Float64, Int64}
R 因子:
2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 -1.41421    ⋅
   ⋅       -1.41421
行の置換:
4-element Vector{Int64}:
 1
 3
 4
 2
列の置換:
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/spqr.jl#L151-L194">source</a></section><section><div><pre><code class="language-julia hljs">qr(A, pivot = NoPivot(); blocksize) -&gt; F</code></pre><p>行列 <code>A</code> の QR 分解を計算します：直交行列（または <code>A</code> が複素数の場合はユニタリ行列）<code>Q</code> と上三角行列 <code>R</code> で、次のようになります。</p><p class="math-container">\[A = Q R\]</p><p>返されるオブジェクト <code>F</code> は、パック形式で分解を格納します：</p><ul><li><code>pivot == ColumnNorm()</code> の場合、<code>F</code> は <a href="LinearAlgebra.html#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> オブジェクトです。</li><li>それ以外の場合、<code>A</code> の要素型が BLAS 型（<a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>、<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>、<code>ComplexF32</code> または <code>ComplexF64</code>）である場合、<code>F</code> は <a href="LinearAlgebra.html#LinearAlgebra.QRCompactWY"><code>QRCompactWY</code></a> オブジェクトです。</li><li>それ以外の場合、<code>F</code> は <a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a> オブジェクトです。</li></ul><p>分解 <code>F</code> の個々のコンポーネントはプロパティアクセサを介して取得できます：</p><ul><li><code>F.Q</code>: 直交/ユニタリ行列 <code>Q</code></li><li><code>F.R</code>: 上三角行列 <code>R</code></li><li><code>F.p</code>: ピボットの置換ベクトル（<a href="LinearAlgebra.html#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> のみ）</li><li><code>F.P</code>: ピボットの置換行列（<a href="LinearAlgebra.html#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> のみ）</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>F.R</code> を介して上三角因子に各参照を行うと、新しい配列が割り当てられます。したがって、その配列をキャッシュすることをお勧めします。たとえば、<code>R = F.R</code> として、<code>R</code> で作業を続けます。</p></div></div><p>分解を反復することで、コンポーネント <code>Q</code>、<code>R</code>、および存在する場合は <code>p</code> を生成します。</p><p><code>QR</code> オブジェクトに対しては、次の関数が利用可能です：<a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>、<a href="../base/arrays.html#Base.size"><code>size</code></a>、および <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>。<code>A</code> が長方形の場合、<code>\</code> は最小二乗解を返し、解が一意でない場合は、最小ノルムのものが返されます。<code>A</code> がフルランクでない場合、最小ノルム解を得るためには（列）ピボッティングを伴う分解が必要です。</p><p>フル/正方行列または非フル/正方行列 <code>Q</code> に関しての乗算が許可されています。つまり、<code>F.Q*F.R</code> と <code>F.Q*A</code> の両方がサポートされています。<code>Q</code> 行列は <a href="../base/arrays.html#Base.Matrix"><code>Matrix</code></a> を使用して通常の行列に変換できます。この操作は「薄い」Q 因子を返します。すなわち、<code>A</code> が <code>m</code>×<code>n</code> で <code>m&gt;=n</code> の場合、<code>Matrix(F.Q)</code> は直交正規列を持つ <code>m</code>×<code>n</code> 行列を生成します。「フル」Q 因子を取得するには、<code>F.Q*I</code> または <code>collect(F.Q)</code> を使用します。<code>m&lt;=n</code> の場合、<code>Matrix(F.Q)</code> は <code>m</code>×<code>m</code> の直交行列を生成します。</p><p>QR 分解のブロックサイズは、<code>pivot == NoPivot()</code> かつ <code>A isa StridedMatrix{&lt;:BlasFloat}</code> の場合にキーワード引数 <code>blocksize :: Integer</code> で指定できます。<code>blocksize &gt; minimum(size(A))</code> の場合は無視されます。<a href="LinearAlgebra.html#LinearAlgebra.QRCompactWY"><code>QRCompactWY</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p><code>blocksize</code> キーワード引数は Julia 1.4 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Matrix{Float64}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qr(A)
LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}
Q 因子: 3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}
R 因子:
2×2 Matrix{Float64}:
 -5.0  10.0
  0.0  -1.0

julia&gt; F.Q * F.R == A
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>qr</code> は複数の型を返します。なぜなら、LAPACK はハウスホルダー基本反射の積のメモリストレージ要件を最小限に抑えるためにいくつかの表現を使用するため、<code>Q</code> と <code>R</code> 行列を2つの別々の密行列としてではなく、コンパクトに格納できるからです。</p></div></div><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/qr.jl#L343-L421">source</a></section></article><h1 id="Noteworthy-External-Sparse-Packages"><a class="docs-heading-anchor" href="#Noteworthy-External-Sparse-Packages">Noteworthy External Sparse Packages</a><a id="Noteworthy-External-Sparse-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Noteworthy-External-Sparse-Packages" title="Permalink"></a></h1><p>いくつかの他のJuliaパッケージは、言及すべきスパース行列の実装を提供しています：</p><ol><li><a href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl">SuiteSparseGraphBLAS.jl</a> は、高速でマルチスレッド対応の SuiteSparse:GraphBLAS C ライブラリのラッパーです。CPU上では、通常これが最も高速なオプションであり、しばしば MKLSparse を大幅に上回ります。</li><li><a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> は、GPU スパース行列操作のための <a href="https://docs.nvidia.com/cuda/cusparse/index.html">CUSPARSE</a> ライブラリを公開しています。</li><li><a href="https://github.com/gridap/SparseMatricesCSR.jl">SparseMatricesCSR.jl</a> は、圧縮スパース行（CSR）フォーマットのJuliaネイティブ実装を提供します。</li><li><a href="https://github.com/JuliaSparse/MKLSparse.jl">MKLSparse.jl</a> は、IntelのMKLライブラリを使用してスパースアレイのスパース-密行列演算を加速します。</li><li><a href="https://github.com/Jutho/SparseArrayKit.jl">SparseArrayKit.jl</a> は多次元スパース配列に利用可能です。</li><li><a href="https://github.com/QuantumBFS/LuxurySparse.jl">LuxurySparse.jl</a> は、静的スパース配列フォーマットと座標フォーマットを提供します。</li><li><a href="https://github.com/j-fu/ExtendableSparse.jl">ExtendableSparse.jl</a> は、新しい保存されたインデックスへの遅延アプローチを使用して、スパース行列への高速挿入を可能にします。</li><li><a href="https://github.com/willow-ahrens/Finch.jl">Finch.jl</a> は、ネイティブのJuliaを使用して、ミニテンソル言語とコンパイラを通じて、広範な多次元スパース配列フォーマットと操作をサポートします。COO、CSF、CSR、CSCなどのサポートに加え、ブロードキャスト、リデュースなどの操作やカスタム操作も可能です。</li></ol><p>外部パッケージによるスパース直接ソルバー：</p><ol><li><a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a></li><li><a href="https://github.com/JuliaSparse/Pardiso.jl/">Pardiso.jl</a></li></ol><p>外部パッケージは、固有システムおよび特異値分解の反復解法のためのソルバーを提供しています：</p><ol><li><a href="https://github.com/JuliaLinearAlgebra/ArnoldiMethod.jl">ArnoldiMethods.jl</a></li><li><a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a></li><li><a href="https://github.com/JuliaLinearAlgebra/Arpack.jl">Arpack.jl</a></li></ol><p>グラフを扱うための外部パッケージ:</p><ol><li><a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a></li></ol><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ACM887"><a class="tag is-link" href="#citeref-ACM887">ACM887</a>Chen, Y., Davis, T. A., Hager, W. W., &amp; Rajamanickam, S. (2008). Algorithm 887: CHOLMOD, Supernodal Sparse Cholesky Factorization and Update/Downdate. ACM Trans. Math. Softw., 35(3). <a href="https://doi.org/10.1145/1391989.1391995">doi:10.1145/1391989.1391995</a></li><li class="footnote" id="footnote-DavisHager2009"><a class="tag is-link" href="#citeref-DavisHager2009">DavisHager2009</a>Davis, Timothy A., &amp; Hager, W. W. (2009). Dynamic Supernodes in Sparse Cholesky Update/Downdate and Triangular Solves. ACM Trans. Math. Softw., 35(4). <a href="https://doi.org/10.1145/1462173.1462176">doi:10.1145/1462173.1462176</a></li><li class="footnote" id="footnote-ACM832"><a class="tag is-link" href="#citeref-ACM832">ACM832</a>Davis, Timothy A. (2004b). Algorithm 832: UMFPACK V4.3–-an Unsymmetric-Pattern Multifrontal Method. ACM Trans. Math. Softw., 30(2), 196–199. <a href="https://doi.org/10.1145/992200.992206">doi:10.1145/992200.992206</a></li><li class="footnote" id="footnote-ACM933"><a class="tag is-link" href="#citeref-ACM933">ACM933</a>Foster, L. V., &amp; Davis, T. A. (2013). Algorithm 933: Reliable Calculation of Numerical Rank, Null Space Bases, Pseudoinverse Solutions, and Basic Solutions Using SuitesparseQR. ACM Trans. Math. Softw., 40(1). <a href="https://doi.org/10.1145/2513109.2513116">doi:10.1145/2513109.2513116</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Sockets.html">« Sockets</a><a class="docs-footer-nextpage" href="Statistics.html">Statistics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 27 May 2025 09:22">Tuesday 27 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
