<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Algebra · The Julia Language</title><meta name="title" content="Linear Algebra · The Julia Language"/><meta property="og:title" content="Linear Algebra · The Julia Language"/><meta property="twitter:title" content="Linear Algebra · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/base.html">Essentials</a></li><li><a class="tocitem" href="../base/collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="../base/math.html">Mathematics</a></li><li><a class="tocitem" href="../base/numbers.html">Numbers</a></li><li><a class="tocitem" href="../base/strings.html">Strings</a></li><li><a class="tocitem" href="../base/arrays.html">Arrays</a></li><li><a class="tocitem" href="../base/parallel.html">Tasks</a></li><li><a class="tocitem" href="../base/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../base/scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="../base/constants.html">Constants</a></li><li><a class="tocitem" href="../base/file.html">Filesystem</a></li><li><a class="tocitem" href="../base/io-network.html">I/O and Network</a></li><li><a class="tocitem" href="../base/punctuation.html">Punctuation</a></li><li><a class="tocitem" href="../base/sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="../base/iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="../base/reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="../base/c.html">C Interface</a></li><li><a class="tocitem" href="../base/libc.html">C Standard Library</a></li><li><a class="tocitem" href="../base/stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="../base/simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="Base64.html">Base64</a></li><li><a class="tocitem" href="CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="Dates.html">Dates</a></li><li><a class="tocitem" href="DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="Downloads.html">Downloads</a></li><li><a class="tocitem" href="FileWatching.html">File Events</a></li><li><a class="tocitem" href="Future.html">Future</a></li><li><a class="tocitem" href="InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="Libdl.html">Dynamic Linker</a></li><li class="is-active"><a class="tocitem" href="LinearAlgebra.html">Linear Algebra</a><ul class="internal"><li><a class="tocitem" href="#Special-matrices"><span>Special matrices</span></a></li><li><a class="tocitem" href="#man-linalg-factorizations"><span>Matrix factorizations</span></a></li><li><a class="tocitem" href="#man-linalg-abstractq"><span>Orthogonal matrices (<code>AbstractQ</code>)</span></a></li><li><a class="tocitem" href="#man-linalg-pivoting-strategies"><span>Pivoting Strategies</span></a></li><li><a class="tocitem" href="#Standard-functions"><span>Standard functions</span></a></li><li><a class="tocitem" href="#Low-level-matrix-operations"><span>Low-level matrix operations</span></a></li><li><a class="tocitem" href="#BLAS-functions"><span>BLAS functions</span></a></li><li><a class="tocitem" href="#man-linalg-lapack-functions"><span>LAPACK functions</span></a></li></ul></li><li><a class="tocitem" href="Logging.html">Logging</a></li><li><a class="tocitem" href="Markdown.html">Markdown</a></li><li><a class="tocitem" href="Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="Pkg.html">Pkg</a></li><li><a class="tocitem" href="Printf.html">Printf</a></li><li><a class="tocitem" href="Profile.html">Profiling</a></li><li><a class="tocitem" href="REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="Random.html">Random Numbers</a></li><li><a class="tocitem" href="SHA.html">SHA</a></li><li><a class="tocitem" href="Serialization.html">Serialization</a></li><li><a class="tocitem" href="SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="Sockets.html">Sockets</a></li><li><a class="tocitem" href="SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="Statistics.html">Statistics</a></li><li><a class="tocitem" href="StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="TOML.html">TOML</a></li><li><a class="tocitem" href="Tar.html">Tar</a></li><li><a class="tocitem" href="Test.html">Unit Testing</a></li><li><a class="tocitem" href="UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href="LinearAlgebra.html">Linear Algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="LinearAlgebra.html">Linear Algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/stdlib/LinearAlgebra/docs/src/index.md" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man-linalg"><a class="docs-heading-anchor" href="#man-linalg">Linear Algebra</a><a id="man-linalg-1"></a><a class="docs-heading-anchor-permalink" href="#man-linalg" title="Permalink"></a></h1><p>多次元配列のサポートに加えて、Juliaは多くの一般的で便利な線形代数操作のネイティブ実装を提供しており、<code>using LinearAlgebra</code>で読み込むことができます。<a href="LinearAlgebra.html#LinearAlgebra.tr"><code>tr</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、および<a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>などの基本操作がすべてサポートされています。</p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3; 4 1 6; 7 8 1]
3×3 Matrix{Int64}:
 1  2  3
 4  1  6
 7  8  1

julia&gt; tr(A)
3

julia&gt; det(A)
104.0

julia&gt; inv(A)
3×3 Matrix{Float64}:
 -0.451923   0.211538    0.0865385
  0.365385  -0.192308    0.0576923
  0.240385   0.0576923  -0.0673077</code></pre><p>固有値や固有ベクトルを見つけるなど、他の便利な操作もあります：</p><pre><code class="language-julia-repl hljs">julia&gt; A = [-4. -17.; 2. 2.]
2×2 Matrix{Float64}:
 -4.0  -17.0
  2.0    2.0

julia&gt; eigvals(A)
2-element Vector{ComplexF64}:
 -1.0 - 5.0im
 -1.0 + 5.0im

julia&gt; eigvecs(A)
2×2 Matrix{ComplexF64}:
  0.945905-0.0im        0.945905+0.0im
 -0.166924+0.278207im  -0.166924-0.278207im</code></pre><p>さらに、Juliaは多くの <a href="LinearAlgebra.html#man-linalg-factorizations">factorizations</a> を提供しており、これを使用することで線形方程式の解法や行列の指数計算などの問題を、パフォーマンスやメモリの理由からより適した形に前因子分解することで高速化できます。詳細については、<a href="LinearAlgebra.html#LinearAlgebra.factorize"><code>factorize</code></a> のドキュメントを参照してください。例として：</p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.5 2 -4; 3 -1 -6; -10 2.3 4]
3×3 Matrix{Float64}:
   1.5   2.0  -4.0
   3.0  -1.0  -6.0
 -10.0   2.3   4.0

julia&gt; factorize(A)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L factor:
3×3 Matrix{Float64}:
  1.0    0.0       0.0
 -0.15   1.0       0.0
 -0.3   -0.132196  1.0
U factor:
3×3 Matrix{Float64}:
 -10.0  2.3     4.0
   0.0  2.345  -3.4
   0.0  0.0    -5.24947</code></pre><p><code>A</code>がエルミートでなく、対称でも三角行列でもトリディアゴナルでもバイダイゴナルでもないため、LU因子分解が私たちができる最善の方法かもしれません。次と比較してください：</p><pre><code class="language-julia-repl hljs">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Matrix{Float64}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; factorize(B)
BunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}
D factor:
3×3 Tridiagonal{Float64, Vector{Float64}}:
 -1.64286   0.0   ⋅
  0.0      -2.8  0.0
   ⋅        0.0  5.0
U factor:
3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:
 1.0  0.142857  -0.8
  ⋅   1.0       -0.6
  ⋅    ⋅         1.0
permutation:
3-element Vector{Int64}:
 1
 2
 3</code></pre><p>ここで、Juliaは<code>B</code>が実際に対称であることを検出し、より適切な因子分解を使用しました。特定の性質を持つことが知られている行列に対して、より効率的なコードを書くことが可能な場合がよくあります。例えば、それが対称であるか、または三重対角である場合です。Juliaは、これらの特性を持つ行列に「タグ」を付けるための特別な型を提供しています。例えば：</p><pre><code class="language-julia-repl hljs">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Matrix{Float64}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64, Matrix{Float64}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0</code></pre><p><code>sB</code> は (実数) 対称行列としてタグ付けされているため、固有因子分解や行列ベクトル積の計算など、後で行う可能性のある操作において、半分だけを参照することで効率を見出すことができます。例えば：</p><pre><code class="language-julia-repl hljs">julia&gt; B = [1.5 2 -4; 2 -1 -3; -4 -3 5]
3×3 Matrix{Float64}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; sB = Symmetric(B)
3×3 Symmetric{Float64, Matrix{Float64}}:
  1.5   2.0  -4.0
  2.0  -1.0  -3.0
 -4.0  -3.0   5.0

julia&gt; x = [1; 2; 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; sB\x
3-element Vector{Float64}:
 -1.7391304347826084
 -1.1086956521739126
 -1.4565217391304346</code></pre><p><code>\</code> 演算子はここで線形解を実行します。左除算演算子は非常に強力で、あらゆる種類の線形方程式系を解決するのに十分柔軟で、コンパクトで読みやすいコードを書くのが簡単です。</p><h2 id="Special-matrices"><a class="docs-heading-anchor" href="#Special-matrices">Special matrices</a><a id="Special-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Special-matrices" title="Permalink"></a></h2><p><a href="https://www2.imm.dtu.dk/pubdb/views/publication_details.php?id=3274">Matrices with special symmetries and structures</a> は線形代数でよく見られ、さまざまな行列因子分解に頻繁に関連しています。Juliaは、特定の行列タイプに特化したルーチンを使用して高速計算を可能にする特別な行列タイプの豊富なコレクションを特徴としています。</p><p>以下の表は、Juliaで実装されている特別な行列の種類と、それらに対するLAPACKのさまざまな最適化されたメソッドへのフックが利用可能かどうかをまとめたものです。</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Symmetric_matrix">Symmetric matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td><td style="text-align: left">Upper <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UnitUpperTriangular"><code>UnitUpperTriangular</code></a></td><td style="text-align: left">Upper <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a> with unit diagonal</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td><td style="text-align: left">Lower <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UnitLowerTriangular"><code>UnitLowerTriangular</code></a></td><td style="text-align: left">Lower <a href="https://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a> with unit diagonal</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UpperHessenberg"><code>UpperHessenberg</code></a></td><td style="text-align: left">Upper <a href="https://en.wikipedia.org/wiki/Hessenberg_matrix">Hessenberg matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Tridiagonal_matrix">Tridiagonal matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td><td style="text-align: left">Symmetric tridiagonal matrix</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td><td style="text-align: left">Upper/lower <a href="https://en.wikipedia.org/wiki/Bidiagonal_matrix">bidiagonal matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Diagonal_matrix">Diagonal matrix</a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Uniform_scaling">Uniform scaling operator</a></td></tr></table><h3 id="Elementary-operations"><a class="docs-heading-anchor" href="#Elementary-operations">Elementary operations</a><a id="Elementary-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Elementary-operations" title="Permalink"></a></h3><table><tr><th style="text-align: left">Matrix type</th><th style="text-align: left"><code>+</code></th><th style="text-align: left"><code>-</code></th><th style="text-align: left"><code>*</code></th><th style="text-align: left"><code>\</code></th><th style="text-align: left">Other functions with optimized methods</th></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="../base/math.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>, <a href="../base/math.html#Base.Math.cbrt-Tuple{AbstractFloat}"><code>cbrt</code></a>, <a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="../base/math.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a>, <a href="../base/math.html#Base.Math.cbrt-Tuple{AbstractFloat}"><code>cbrt</code></a>, <a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MV</td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UnitUpperTriangular"><code>UnitUpperTriangular</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MV</td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MV</td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UnitLowerTriangular"><code>UnitLowerTriangular</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MV</td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UpperHessenberg"><code>UpperHessenberg</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">MM</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td><td style="text-align: left">M</td><td style="text-align: left">M</td><td style="text-align: left">MS</td><td style="text-align: left">MV</td><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.eigmax"><code>eigmax</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.eigmin"><code>eigmin</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td><td style="text-align: left">M</td><td style="text-align: left">M</td><td style="text-align: left">MS</td><td style="text-align: left">MV</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td><td style="text-align: left">M</td><td style="text-align: left">M</td><td style="text-align: left">MS</td><td style="text-align: left">MV</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td><td style="text-align: left">M</td><td style="text-align: left">M</td><td style="text-align: left">MV</td><td style="text-align: left">MV</td><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a>, <a href="../base/math.html#Base.:/"><code>/</code></a></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a></td><td style="text-align: left">M</td><td style="text-align: left">M</td><td style="text-align: left">MVS</td><td style="text-align: left">MVS</td><td style="text-align: left"><a href="../base/math.html#Base.:/"><code>/</code></a></td></tr></table><p>伝説:</p><table><tr><th style="text-align: left">Key</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">M (matrix)</td><td style="text-align: left">An optimized method for matrix-matrix operations is available</td></tr><tr><td style="text-align: left">V (vector)</td><td style="text-align: left">An optimized method for matrix-vector operations is available</td></tr><tr><td style="text-align: left">S (scalar)</td><td style="text-align: left">An optimized method for matrix-scalar operations is available</td></tr></table><h3 id="Matrix-factorizations"><a class="docs-heading-anchor" href="#Matrix-factorizations">Matrix factorizations</a><a id="Matrix-factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-factorizations" title="Permalink"></a></h3><table><tr><th style="text-align: left">Matrix type</th><th style="text-align: left">LAPACK</th><th style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a></th><th style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.eigvals"><code>eigvals</code></a></th><th style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.eigvecs"><code>eigvecs</code></a></th><th style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a></th><th style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.svdvals"><code>svdvals</code></a></th></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a></td><td style="text-align: left">SY</td><td style="text-align: left"></td><td style="text-align: left">ARI</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a></td><td style="text-align: left">HE</td><td style="text-align: left"></td><td style="text-align: left">ARI</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a></td><td style="text-align: left">TR</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UnitUpperTriangular"><code>UnitUpperTriangular</code></a></td><td style="text-align: left">TR</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a></td><td style="text-align: left">TR</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.UnitLowerTriangular"><code>UnitLowerTriangular</code></a></td><td style="text-align: left">TR</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left">A</td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a></td><td style="text-align: left">ST</td><td style="text-align: left">A</td><td style="text-align: left">ARI</td><td style="text-align: left">AV</td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Tridiagonal"><code>Tridiagonal</code></a></td><td style="text-align: left">GT</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Bidiagonal"><code>Bidiagonal</code></a></td><td style="text-align: left">BD</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">A</td><td style="text-align: left">A</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a></td><td style="text-align: left">DI</td><td style="text-align: left"></td><td style="text-align: left">A</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><p>伝説:</p><table><tr><th style="text-align: left">Key</th><th style="text-align: left">Description</th><th style="text-align: left">Example</th></tr><tr><td style="text-align: left">A (all)</td><td style="text-align: left">An optimized method to find all the characteristic values and/or vectors is available</td><td style="text-align: left">e.g. <code>eigvals(M)</code></td></tr><tr><td style="text-align: left">R (range)</td><td style="text-align: left">An optimized method to find the <code>il</code>th through the <code>ih</code>th characteristic values are available</td><td style="text-align: left"><code>eigvals(M, il, ih)</code></td></tr><tr><td style="text-align: left">I (interval)</td><td style="text-align: left">An optimized method to find the characteristic values in the interval [<code>vl</code>, <code>vh</code>] is available</td><td style="text-align: left"><code>eigvals(M, vl, vh)</code></td></tr><tr><td style="text-align: left">V (vectors)</td><td style="text-align: left">An optimized method to find the characteristic vectors corresponding to the characteristic values <code>x=[x1, x2,...]</code> is available</td><td style="text-align: left"><code>eigvecs(M, x)</code></td></tr></table><h3 id="The-uniform-scaling-operator"><a class="docs-heading-anchor" href="#The-uniform-scaling-operator">The uniform scaling operator</a><a id="The-uniform-scaling-operator-1"></a><a class="docs-heading-anchor-permalink" href="#The-uniform-scaling-operator" title="Permalink"></a></h3><p><a href="LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a> 演算子はスカラーと単位演算子 <code>λ*I</code> を表します。単位演算子 <code>I</code> は定数として定義され、<code>UniformScaling</code> のインスタンスです。これらの演算子のサイズは一般的であり、バイナリ演算 <a href="../base/math.html#Base.:+"><code>+</code></a>、<a href="../base/math.html#Base.:--Tuple{Any}"><code>-</code></a>、<a href="../base/math.html#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a>、および <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a> の他の行列と一致します。<code>A+I</code> および <code>A-I</code> の場合、<code>A</code> は正方行列でなければなりません。単位演算子 <code>I</code> との乗算はノーオップであり（スケーリング係数が1であることを確認することを除いて）、したがってほとんどオーバーヘッドがありません。</p><p><code>UniformScaling</code> 演算子の動作を確認するには：</p><pre><code class="language-julia-repl hljs">julia&gt; U = UniformScaling(2);

julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; a + U
2×2 Matrix{Int64}:
 3  2
 3  6

julia&gt; a * U
2×2 Matrix{Int64}:
 2  4
 6  8

julia&gt; [a U]
2×4 Matrix{Int64}:
 1  2  2  0
 3  4  0  2

julia&gt; b = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; b - U
ERROR: DimensionMismatch: matrix is not square: dimensions are (2, 3)
Stacktrace:
[...]</code></pre><p>同じ <code>A</code> に対して異なる <code>μ</code> の形 <code>(A+μI)x = b</code> の多くのシステムを解く必要がある場合、最初に <a href="LinearAlgebra.html#LinearAlgebra.hessenberg"><code>hessenberg</code></a> 関数を介して <code>A</code> のヘッセンバーグ因子分解 <code>F</code> を計算することが有益かもしれません。 <code>F</code> が得られたら、Julia は <code>(F+μ*I) \ b</code> （これは <code>(A+μ*I)x \ b</code> と同等）や行列式のような関連操作のための効率的なアルゴリズムを使用します。</p><h2 id="man-linalg-factorizations"><a class="docs-heading-anchor" href="#man-linalg-factorizations">Matrix factorizations</a><a id="man-linalg-factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#man-linalg-factorizations" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Matrix_decomposition">Matrix factorizations (a.k.a. matrix decompositions)</a> 行列の因子分解は、行列を行列の積に分解することであり、（数値的）線形代数の中心的な概念の一つです。</p><p>以下の表は、Juliaで実装されている行列因子分解の種類をまとめたものです。それらに関連するメソッドの詳細は、線形代数ドキュメントの <a href="LinearAlgebra.html#Standard-functions">Standard functions</a> セクションで確認できます。</p><table><tr><th style="text-align: left">Type</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>BunchKaufman</code></td><td style="text-align: left">Bunch-Kaufman factorization</td></tr><tr><td style="text-align: left"><code>Cholesky</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky factorization</a></td></tr><tr><td style="text-align: left"><code>CholeskyPivoted</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Pivot_element">Pivoted</a> Cholesky factorization</td></tr><tr><td style="text-align: left"><code>LDLt</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition">LDL(T) factorization</a></td></tr><tr><td style="text-align: left"><code>LU</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/LU_decomposition">LU factorization</a></td></tr><tr><td style="text-align: left"><code>QR</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a></td></tr><tr><td style="text-align: left"><code>QRCompactWY</code></td><td style="text-align: left">Compact WY form of the QR factorization</td></tr><tr><td style="text-align: left"><code>QRPivoted</code></td><td style="text-align: left">Pivoted <a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a></td></tr><tr><td style="text-align: left"><code>LQ</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/QR_decomposition">QR factorization</a> of <code>transpose(A)</code></td></tr><tr><td style="text-align: left"><code>Hessenberg</code></td><td style="text-align: left"><a href="https://mathworld.wolfram.com/HessenbergDecomposition.html">Hessenberg decomposition</a></td></tr><tr><td style="text-align: left"><code>Eigen</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">Spectral decomposition</a></td></tr><tr><td style="text-align: left"><code>GeneralizedEigen</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Generalized_eigenvalue_problem">Generalized spectral decomposition</a></td></tr><tr><td style="text-align: left"><code>SVD</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular value decomposition</a></td></tr><tr><td style="text-align: left"><code>GeneralizedSVD</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Generalized_singular_value_decomposition#Higher_order_version">Generalized SVD</a></td></tr><tr><td style="text-align: left"><code>Schur</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Schur_decomposition">Schur decomposition</a></td></tr><tr><td style="text-align: left"><code>GeneralizedSchur</code></td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/Schur_decomposition#Generalized_Schur_decomposition">Generalized Schur decomposition</a></td></tr></table><p><a href="LinearAlgebra.html#LinearAlgebra.Factorization"><code>Factorization</code></a> オブジェクトの随伴と転置は、それぞれ <code>AdjointFactorization</code> および <code>TransposeFactorization</code> オブジェクトに遅延ラップされます。一般に、実数の <code>Factorization</code> の転置は <code>AdjointFactorization</code> としてラップされます。</p><h2 id="man-linalg-abstractq"><a class="docs-heading-anchor" href="#man-linalg-abstractq">Orthogonal matrices (<code>AbstractQ</code>)</a><a id="man-linalg-abstractq-1"></a><a class="docs-heading-anchor-permalink" href="#man-linalg-abstractq" title="Permalink"></a></h2><p>いくつかの行列因子分解は、直交行列またはユニタリ行列の「行列」因子を生成します。これらの因子分解には、<a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a>、すなわち <code>QR</code>、<code>QRCompactWY</code>、および <code>QRPivoted</code> から得られるQR関連の因子分解、<a href="LinearAlgebra.html#LinearAlgebra.hessenberg"><code>hessenberg</code></a> から得られるヘッセンベルグ因子分解、そして <a href="LinearAlgebra.html#LinearAlgebra.lq"><code>lq</code></a> から得られるLQ因子分解が含まれます。これらの直交行列/ユニタリ行列因子は行列表現を持ちますが、その内部表現はパフォーマンスとメモリの理由から異なります。したがって、これらはむしろ行列に基づいた関数ベースの線形演算子として見るべきです。特に、例えばその行列表現の列を読み取るには、「行列」-ベクトル乗算コードを実行する必要があり、単にメモリからデータを読み出すだけではありません（場合によってはベクトルの一部を構造的ゼロで埋めることになります）。他の非三角行列型との明確な違いは、基礎となる乗算コードが乗算中にインプレースでの修正を許可することです。さらに、<code>4d61726b646f776e2e436f64652822222c202271722229_40726566</code>、<code>4d61726b646f776e2e436f64652822222c202268657373656e626572672229_40726566</code>、および <code>4d61726b646f776e2e436f64652822222c20226c712229_40726566</code> を介して作成された特定の <code>AbstractQ</code> サブタイプのオブジェクトは、文脈に応じて正方行列または長方行列のように振る舞うことができます。</p><pre><code class="language-julia hljs">julia&gt; using LinearAlgebra

julia&gt; Q = qr(rand(3,2)).Q
3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}

julia&gt; Matrix(Q)
3×2 Matrix{Float64}:
 -0.320597   0.865734
 -0.765834  -0.475694
 -0.557419   0.155628

julia&gt; Q*I
3×3 Matrix{Float64}:
 -0.320597   0.865734  -0.384346
 -0.765834  -0.475694  -0.432683
 -0.557419   0.155628   0.815514

julia&gt; Q*ones(2)
3-element Vector{Float64}:
  0.5451367118802273
 -1.241527373086654
 -0.40179067589600226

julia&gt; Q*ones(3)
3-element Vector{Float64}:
  0.16079054743832022
 -1.674209978965636
  0.41372375588835797

julia&gt; ones(1,2) * Q&#39;
1×3 Matrix{Float64}:
 0.545137  -1.24153  -0.401791

julia&gt; ones(1,3) * Q&#39;
1×3 Matrix{Float64}:
 0.160791  -1.67421  0.413724</code></pre><p>この密なまたは構造化された行列との区別により、抽象型 <code>AbstractQ</code> は <code>AbstractMatrix</code> のサブタイプではなく、独自の型階層を持っています。 <code>AbstractQ</code> をサブタイプとするカスタム型は、次のインターフェースが満たされている場合、ジェネリックフォールバックに依存できます。例えば、</p><pre><code class="language-julia hljs">struct MyQ{T} &lt;: LinearAlgebra.AbstractQ{T}
    # required fields
end</code></pre><p>オーバーロードを提供する</p><pre><code class="language-julia hljs">Base.size(Q::MyQ) # size of corresponding square matrix representation
Base.convert(::Type{AbstractQ{T}}, Q::MyQ) # eltype promotion [optional]
LinearAlgebra.lmul!(Q::MyQ, x::AbstractVecOrMat) # left-multiplication
LinearAlgebra.rmul!(A::AbstractMatrix, Q::MyQ) # right-multiplication</code></pre><p><code>eltype</code> の昇格が興味の対象でない場合、<code>convert</code> メソッドは不要です。なぜなら、デフォルトで <code>convert(::Type{AbstractQ{T}}, Q::AbstractQ{T})</code> は <code>Q</code> 自体を返すからです。<code>AbstractQ</code> 型のオブジェクトの随伴は、<code>AdjointQ</code> ラッパー型で遅延ラップされ、独自の <code>LinearAlgebra.lmul!</code> および <code>LinearAlgebra.rmul!</code> メソッドが必要です。この一連のメソッドにより、任意の <code>Q::MyQ</code> は行列のように使用でき、特に乗算の文脈で好まれます：スカラー、ベクトル、行列との左および右からの <code>*</code> による乗算、<code>Matrix(Q)</code>（または <code>Q*I</code>）を介しての <code>Q</code> の行列表現の取得、行列表現へのインデックス付けがすべて機能します。対照的に、加算や減算、さらには行列表現の要素に対するブロードキャストは失敗します。なぜなら、それは非常に非効率的だからです。そのような使用ケースでは、事前に行列表現を計算し、将来の再利用のためにキャッシュすることを検討してください。</p><h2 id="man-linalg-pivoting-strategies"><a class="docs-heading-anchor" href="#man-linalg-pivoting-strategies">Pivoting Strategies</a><a id="man-linalg-pivoting-strategies-1"></a><a class="docs-heading-anchor-permalink" href="#man-linalg-pivoting-strategies" title="Permalink"></a></h2><p>ジュリアの <a href="LinearAlgebra.html#man-linalg-factorizations">matrix factorizations</a> のいくつかは <a href="https://en.wikipedia.org/wiki/Pivot_element">pivoting</a> をサポートしており、これを使用することで数値的安定性を向上させることができます。実際、LU因子分解などのいくつかの行列因子分解は、ピボットなしでは失敗する可能性があります。</p><p>In pivoting, first, a <a href="https://en.wikipedia.org/wiki/Pivot_element">pivot element</a> with good numerical properties is chosen based on a pivoting strategy. Next, the rows and columns of the original matrix are permuted to bring the chosen element in place for subsequent computation. Furthermore, the process is repeated for each stage of the factorization.</p><p>したがって、従来の行列因子に加えて、ピボット因子化スキームの出力には置換行列も含まれます。</p><p>以下に、Juliaで実装されているピボット戦略について簡単に説明します。すべての行列因子分解がこれらをサポートしているわけではないことに注意してください。サポートされているピボット戦略の詳細については、該当する <a href="LinearAlgebra.html#man-linalg-factorizations">matrix factorization</a> のドキュメントを参照してください。</p><p>関連情報は <a href="LinearAlgebra.html#LinearAlgebra.ZeroPivotException"><code>LinearAlgebra.ZeroPivotException</code></a> を参照してください。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.NoPivot" href="#LinearAlgebra.NoPivot"><code>LinearAlgebra.NoPivot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoPivot</code></pre><p>ピボットは実行されません。LU因子分解などの行列因子分解は、ピボットなしでは失敗する可能性があり、丸め誤差に対して浮動小数点行列に対して数値的に不安定である可能性もあります。このピボット戦略は主に教育的目的で役立ちます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.RowNonZero" href="#LinearAlgebra.RowNonZero"><code>LinearAlgebra.RowNonZero</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RowNonZero</code></pre><p>残りの行の最初の非ゼロ要素がピボット要素として選ばれます。</p><p>浮動小数点行列に対しては、結果として得られるLUアルゴリズムは数値的に不安定であるため注意が必要です。この戦略は、主に手計算（通常この戦略を使用する）との比較や、丸め誤差に影響されない他の代数型（例えば、有理数）に対して有用です。それ以外の場合、ガウス消去法ではデフォルトの<code>RowMaximum</code>ピボット戦略が一般的に推奨されます。</p><p>行列の<a href="../base/collections.html#Base.eltype">要素型</a>は、<a href="../base/numbers.html#Base.iszero"><code>iszero</code></a>メソッドを許容する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L206-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.RowMaximum" href="#LinearAlgebra.RowMaximum"><code>LinearAlgebra.RowMaximum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RowMaximum</code></pre><p>残りの行の中で最大の絶対値を持つ要素がピボット要素として選ばれます。これは浮動小数点行列のLU因子分解のデフォルト戦略であり、時には「部分ピボッティング」アルゴリズムと呼ばれます。</p><p>行列の<a href="../base/collections.html#Base.eltype">要素型</a>は、<a href="../base/math.html#Base.abs"><code>abs</code></a>メソッドを許容し、その結果の型は<a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a>メソッドを許容しなければなりません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L221-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ColumnNorm" href="#LinearAlgebra.ColumnNorm"><code>LinearAlgebra.ColumnNorm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ColumnNorm</code></pre><p>最大ノルムを持つ列がその後の計算に使用されます。これはピボットQR因子分解に使用されます。</p><p>行列の<a href="../base/collections.html#Base.eltype">要素型</a>は、<a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a>および<a href="../base/math.html#Base.abs"><code>abs</code></a>メソッドを許容する必要があり、それぞれの結果型は<a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a>メソッドを許容する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L233-L241">source</a></section></article><h2 id="Standard-functions"><a class="docs-heading-anchor" href="#Standard-functions">Standard functions</a><a id="Standard-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-functions" title="Permalink"></a></h2><p>ジュリアの線形代数関数は、主に <a href="https://www.netlib.org/lapack/">LAPACK</a> から関数を呼び出すことで実装されています。スパース行列の因子分解は、 <a href="http://suitesparse.com">SuiteSparse</a> から関数を呼び出します。他のスパースソルバーは、ジュリアパッケージとして利用可能です。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{AbstractMatrix, AbstractMatrix}" href="#Base.:*-Tuple{AbstractMatrix, AbstractMatrix}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>行列の乗算。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; [1 1; 0 1] * [1 0; 1 1]
2×2 Matrix{Int64}:
 2  1
 1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L99-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}" href="#Base.:*-Tuple{AbstractMatrix, AbstractMatrix, AbstractVector}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">*(A, B::AbstractMatrix, C)
A * B * C * D</code></pre><p>3つまたは4つの行列の連鎖乗算は、配列のサイズに基づいて最も効率的な順序で行われます。つまり、3つの密行列を用いた <code>(A * B) * C</code> に必要なスカラー乗算の数が、<code>A * (B * C)</code> のそれと比較され、どちらを実行するかが選ばれます。</p><p>最後の因子がベクトルであるか、最初の因子が転置ベクトルである場合、これらを最初に処理するのが効率的です。特に <code>x&#39; * B * y</code> は、通常の列優先の <code>B::Matrix</code> に対して <code>(x&#39; * B) * y</code> を意味します。<code>dot(x, B, y)</code> とは異なり、これは中間配列を割り当てます。</p><p>最初または最後の因子が数値である場合、これは行列乗算と融合され、5引数の <a href="LinearAlgebra.html#LinearAlgebra.mul!"><code>mul!</code></a> が使用されます。</p><p>他に <a href="../base/math.html#Base.muladd"><code>muladd</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.dot"><code>dot</code></a> も参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>これらの最適化は、少なくとも Julia 1.7 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L1094-L1115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:\\-Tuple{AbstractMatrix, AbstractVecOrMat}" href="#Base.:\\-Tuple{AbstractMatrix, AbstractVecOrMat}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">\(A, B)</code></pre><p>ポリアルゴリズムを使用した行列の除算。入力行列 <code>A</code> と <code>B</code> に対して、結果 <code>X</code> は <code>A*X == B</code> となるように、<code>A</code> が正方行列である場合に求められます。使用されるソルバーは <code>A</code> の構造に依存します。<code>A</code> が上三角または下三角（または対角）である場合、<code>A</code> の因数分解は必要なく、前方または後方代入によってシステムが解かれます。非三角形の正方行列の場合、LU因数分解が使用されます。</p><p>矩形の <code>A</code> に対して、結果は <code>A</code> のピボットQR因数分解と <code>R</code> 因子に基づく <code>A</code> のランク推定によって計算された最小ノルム最小二乗解です。</p><p><code>A</code> がスパースである場合、同様のポリアルゴリズムが使用されます。非定義行列の場合、<code>LDLt</code> 因数分解は数値因数分解中にピボティングを使用しないため、可逆行列であっても手続きが失敗する可能性があります。</p><p>参照: <a href="LinearAlgebra.html#LinearAlgebra.factorize"><code>factorize</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.pinv"><code>pinv</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 0; 1 -2]; B = [32; -4];

julia&gt; X = A \ B
2-element Vector{Float64}:
 32.0
 18.0

julia&gt; A * X == B
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1087-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:/-Tuple{AbstractVecOrMat, AbstractVecOrMat}" href="#Base.:/-Tuple{AbstractVecOrMat, AbstractVecOrMat}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A / B</code></pre><p>行列の右除算: <code>A / B</code> は <code>(B&#39; \ A&#39;)&#39;</code> に相当し、ここで <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a> は左除算演算子です。正方行列の場合、結果 <code>X</code> は <code>A == X*B</code> となります。</p><p>関連情報: <a href="LinearAlgebra.html#LinearAlgebra.rdiv!"><code>rdiv!</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Float64[1 4 5; 3 9 2]; B = Float64[1 4 2; 3 4 2; 8 7 1];

julia&gt; X = A / B
2×3 Matrix{Float64}:
 -0.65   3.75  -1.2
  3.25  -2.75   1.0

julia&gt; isapprox(A, X*B)
true

julia&gt; isapprox(X, A*pinv(B))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1138-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.SingularException" href="#LinearAlgebra.SingularException"><code>LinearAlgebra.SingularException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingularException</code></pre><p>入力行列に1つ以上のゼロ値の固有値があり、逆行列が存在しない場合にスローされる例外です。このような行列を含む線形方程式の解は計算できません。<code>info</code>フィールドは、特異値の位置を示します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/exceptions.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.PosDefException" href="#LinearAlgebra.PosDefException"><code>LinearAlgebra.PosDefException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PosDefException</code></pre><p>入力行列が<a href="https://en.wikipedia.org/wiki/Definiteness_of_a_matrix">正定値</a>でない場合にスローされる例外。一部の線形代数関数や因数分解は正定値行列にのみ適用可能です。<code>info</code>フィールドは、0以下の（いずれかの）固有値の位置を示します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/exceptions.jl#L31-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ZeroPivotException" href="#LinearAlgebra.ZeroPivotException"><code>LinearAlgebra.ZeroPivotException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroPivotException &lt;: Exception</code></pre><p>ピボット（対角）位置にゼロがある場合に行列の因子分解/解決が発生し、進行できないときにスローされる例外です。これは行列が特異であることを意味するわけではありません：偽のゼロピボットを排除するために変数を再配置できるピボットLUなどの別の因子分解に切り替えることが有益な場合があります。<code>info</code>フィールドはゼロピボットの位置を示します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/exceptions.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.RankDeficientException" href="#LinearAlgebra.RankDeficientException"><code>LinearAlgebra.RankDeficientException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RankDeficientException</code></pre><p>入力行列が<a href="https://en.wikipedia.org/wiki/Rank_(linear_algebra)">ランク欠損</a>であるときにスローされる例外です。コレスキー分解のような一部の線形代数関数は、ランク欠損でない行列にのみ適用可能です。<code>info</code>フィールドは、行列の計算されたランクを示します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/exceptions.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACKException" href="#LinearAlgebra.LAPACKException"><code>LinearAlgebra.LAPACKException</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK例外</code></pre><p>直接的に<a href="LinearAlgebra.html#man-linalg-lapack-functions">LAPACK関数</a>を呼び出す際、または内部でLAPACK関数を使用する他の関数を呼び出す際に、特別なエラーハンドリングがない場合にスローされる一般的なLAPACK例外です。<code>info</code>フィールドには、基礎となるエラーに関する追加情報が含まれており、呼び出されたLAPACK関数に依存します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/exceptions.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(x, y)
x ⋅ y</code></pre><p>2つのベクトル間のドット積を計算します。複素ベクトルの場合、最初のベクトルは共役されます。</p><p><code>dot</code>は、要素に対して<code>dot</code>が定義されている限り、任意の次元の配列を含む任意の反復可能なオブジェクトでも機能します。</p><p><code>dot</code>は、引数が等しい長さでなければならないという追加の制約を伴いながら、<code>sum(dot(vx,vy) for (vx,vy) in zip(x, y))</code>と意味的に同等です。</p><p><code>x ⋅ y</code>（ここで<code>⋅</code>はREPLで<code>\cdot</code>をタブ補完することで入力できます）は、<code>dot(x, y)</code>の同義語です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dot([1; 1], [2; 3])
5

julia&gt; dot([im; im], [1; 1])
0 - 2im

julia&gt; dot(1:5, 2:6)
70

julia&gt; x = fill(2., (5,5));

julia&gt; y = fill(3., (5,5));

julia&gt; dot(x, y)
150.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L816-L850">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Tuple{Any, Any, Any}" href="#LinearAlgebra.dot-Tuple{Any, Any, Any}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(x, A, y)</code></pre><p>ベクトル <code>x</code> と <code>y</code> の間で、<code>A*y</code> の中間結果を保存せずに一般化された内積 <code>dot(x, A*y)</code> を計算します。二引数の <a href="LinearAlgebra.html#LinearAlgebra.dot"><code>dot(_,_)</code></a> と同様に、再帰的に動作します。さらに、複素ベクトルの場合、最初のベクトルは共役されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>三引数の <code>dot</code> は少なくとも Julia 1.4 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dot([1; 1], [1 2; 3 4], [2; 3])
26

julia&gt; dot(1:5, reshape(1:25, 5, 5), 2:6)
4850

julia&gt; ⋅(1:5, reshape(1:25, 5, 5), 2:6) == dot(1:5, reshape(1:25, 5, 5), 2:6)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L906-L928">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cross" href="#LinearAlgebra.cross"><code>LinearAlgebra.cross</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cross(x, y)
×(x,y)</code></pre><p>2つの3ベクトルのクロス積を計算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [0;1;0]
3-element Vector{Int64}:
 0
 1
 0

julia&gt; b = [0;0;1]
3-element Vector{Int64}:
 0
 0
 1

julia&gt; cross(a,b)
3-element Vector{Int64}:
 1
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L289-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.axpy!" href="#LinearAlgebra.axpy!"><code>LinearAlgebra.axpy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axpy!(α, x::AbstractArray, y::AbstractArray)</code></pre><p><code>y</code>を<code>x * α + y</code>で上書きし、<code>y</code>を返します。<code>x</code>と<code>y</code>が同じ軸を持つ場合、これは<code>y .+= x .* a</code>と同等です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; axpy!(2, x, y)
3-element Vector{Int64}:
  6
  9
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1445-L1463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.axpby!" href="#LinearAlgebra.axpby!"><code>LinearAlgebra.axpby!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axpby!(α, x::AbstractArray, β, y::AbstractArray)</code></pre><p><code>y</code>を<code>x * α + y * β</code>で上書きし、<code>y</code>を返します。<code>x</code>と<code>y</code>が同じ軸を持つ場合、これは<code>y .= x .* a .+ y .* β</code>と同等です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; axpby!(2, x, 2, y)
3-element Vector{Int64}:
 10
 14
 18</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1491-L1509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rotate!" href="#LinearAlgebra.rotate!"><code>LinearAlgebra.rotate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotate!(x, y, c, s)</code></pre><p><code>x</code>を<code>c*x + s*y</code>で上書きし、<code>y</code>を<code>-conj(s)*x + c*y</code>で上書きします。<code>x</code>と<code>y</code>を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>rotate!</code>は少なくともJulia 1.5を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1539-L1547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.reflect!" href="#LinearAlgebra.reflect!"><code>LinearAlgebra.reflect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflect!(x, y, c, s)</code></pre><p><code>x</code>を<code>c*x + s*y</code>で上書きし、<code>y</code>を<code>conj(s)*x - c*y</code>で上書きします。<code>x</code>と<code>y</code>を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>reflect!</code>は少なくともJulia 1.5が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1562-L1570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.factorize" href="#LinearAlgebra.factorize"><code>LinearAlgebra.factorize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">factorize(A)</code></pre><p>入力行列のタイプに基づいて、<code>A</code>の便利な因数分解を計算します。<code>factorize</code>は、<code>A</code>が一般的な行列として渡された場合、対称/三角形/etc.であるかどうかを確認します。<code>factorize</code>は、<code>A</code>の各要素をチェックして、各特性を確認/除外します。対称性/三角形構造を除外できるとすぐに短絡します。返り値は、複数のシステムを効率的に解くために再利用できます。例えば：<code>A=factorize(A); x=A\b; y=A\C</code>。</p><table><tr><th style="text-align: left"><code>A</code>の特性</th><th style="text-align: left">因数分解のタイプ</th></tr><tr><td style="text-align: left">正定値</td><td style="text-align: left">コレスキー (see <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a>)</td></tr><tr><td style="text-align: left">密な対称/エルミート行列</td><td style="text-align: left">バンチ-カウフマン (see <a href="LinearAlgebra.html#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a>)</td></tr><tr><td style="text-align: left">スパース対称/エルミート行列</td><td style="text-align: left">LDLt (see <a href="LinearAlgebra.html#LinearAlgebra.ldlt"><code>ldlt</code></a>)</td></tr><tr><td style="text-align: left">三角行列</td><td style="text-align: left">三角行列</td></tr><tr><td style="text-align: left">対角行列</td><td style="text-align: left">対角行列</td></tr><tr><td style="text-align: left">双対角行列</td><td style="text-align: left">双対角行列</td></tr><tr><td style="text-align: left">三重対角行列</td><td style="text-align: left">LU (see <a href="LinearAlgebra.html#LinearAlgebra.lu"><code>lu</code></a>)</td></tr><tr><td style="text-align: left">対称実三重対角行列</td><td style="text-align: left">LDLt (see <a href="LinearAlgebra.html#LinearAlgebra.ldlt"><code>ldlt</code></a>)</td></tr><tr><td style="text-align: left">一般的な正方行列</td><td style="text-align: left">LU (see <a href="LinearAlgebra.html#LinearAlgebra.lu"><code>lu</code></a>)</td></tr><tr><td style="text-align: left">一般的な非正方行列</td><td style="text-align: left">QR (see <a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a>)</td></tr></table><p>例えば、<code>factorize</code>がエルミート正定値行列に対して呼び出されると、<code>factorize</code>はコレスキー因数分解を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))
5×5 Matrix{Float64}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia&gt; factorize(A) # factorizeはAがすでに因数分解されているかどうかを確認します
5×5 Bidiagonal{Float64, Vector{Float64}}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0</code></pre><p>これは<code>5×5 Bidiagonal{Float64}</code>を返し、他の線形代数関数（例えば、固有値ソルバー）に渡すことができ、<code>Bidiagonal</code>タイプのための特化したメソッドが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1372-L1418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Diagonal" href="#LinearAlgebra.Diagonal"><code>LinearAlgebra.Diagonal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Diagonal(V::AbstractVector)</code></pre><p><code>V</code>を対角成分とする遅延行列を構築します。</p><p>遅延単位行列<code>I</code>については<a href="LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a>を、密行列を作成するための<a href="LinearAlgebra.html#LinearAlgebra.diagm"><code>diagm</code></a>を、対角成分を抽出するための<a href="LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Diagonal([1, 10, 100])
3×3 Diagonal{Int64, Vector{Int64}}:
 1   ⋅    ⋅
 ⋅  10    ⋅
 ⋅   ⋅  100

julia&gt; diagm([7, 13])
2×2 Matrix{Int64}:
 7   0
 0  13

julia&gt; ans + I
2×2 Matrix{Int64}:
 8   0
 0  14

julia&gt; I(2)
2×2 Diagonal{Bool, Vector{Bool}}:
 1  ⋅
 ⋅  1</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>1列の行列はベクトルとして扱われず、代わりに1要素の<code>diag(A)</code>を抽出する<code>Diagonal(A::AbstractMatrix)</code>メソッドが呼び出されます:</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; A = transpose([7.0 13.0])
2×1 transpose(::Matrix{Float64}) with eltype Float64:
  7.0
 13.0

julia&gt; Diagonal(A)
1×1 Diagonal{Float64, Vector{Float64}}:
 7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/diagonal.jl#L23-L69">source</a></section><section><div><pre><code class="language-julia hljs">Diagonal(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の主対角線から行列を構築します。入力行列 <code>A</code> は長方形である可能性がありますが、出力は正方形になります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; D = Diagonal(A)
2×2 Diagonal{Int64, Vector{Int64}}:
 1  ⋅
 ⋅  4

julia&gt; A = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; Diagonal(A)
2×2 Diagonal{Int64, Vector{Int64}}:
 1  ⋅
 ⋅  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/diagonal.jl#L72-L101">source</a></section><section><div><pre><code class="language-julia hljs">Diagonal{T}(undef, n)</code></pre><p>初期化されていない長さ <code>n</code> の <code>Diagonal{T}</code> を構築します。<code>undef</code> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/diagonal.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Bidiagonal" href="#LinearAlgebra.Bidiagonal"><code>LinearAlgebra.Bidiagonal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bidiagonal(dv::V, ev::V, uplo::Symbol) where V &lt;: AbstractVector</code></pre><p>与えられた対角ベクトル（<code>dv</code>）とオフ対角ベクトル（<code>ev</code>）を使用して、上三角（<code>uplo=:U</code>）または下三角（<code>uplo=:L</code>）のバイダイアゴナル行列を構築します。結果は <code>Bidiagonal</code> 型であり、効率的な特化型線形ソルバーを提供しますが、<a href="../base/base.html#Base.convert"><code>convert(Array, _)</code></a>（または短縮形の <code>Array(_)</code>）を使用して通常の行列に変換することができます。<code>ev</code> の長さは <code>dv</code> の長さよりも1少なくなければなりません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dv = [1, 2, 3, 4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Vector{Int64}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, :U) # ev は最初のスーパー対角にあります
4×4 Bidiagonal{Int64, Vector{Int64}}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia&gt; Bl = Bidiagonal(dv, ev, :L) # ev は最初のサブ対角にあります
4×4 Bidiagonal{Int64, Vector{Int64}}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/bidiag.jl#L29-L67">source</a></section><section><div><pre><code class="language-julia hljs">Bidiagonal(A, uplo::Symbol)</code></pre><p>行列 <code>A</code> の主対角線とその最初の上部対角線（<code>uplo=:U</code> の場合）または下部対角線（<code>uplo=:L</code> の場合）から <code>Bidiagonal</code> 行列を構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Matrix{Int64}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia&gt; Bidiagonal(A, :U) # A の主対角線と最初の上部対角線を含む
4×4 Bidiagonal{Int64, Vector{Int64}}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia&gt; Bidiagonal(A, :L) # A の主対角線と最初の下部対角線を含む
4×4 Bidiagonal{Int64, Vector{Int64}}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/bidiag.jl#L82-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.SymTridiagonal" href="#LinearAlgebra.SymTridiagonal"><code>LinearAlgebra.SymTridiagonal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymTridiagonal(dv::V, ev::V) where V &lt;: AbstractVector</code></pre><p>対角成分（<code>dv</code>）と最初の下/上対角成分（<code>ev</code>）から対称トリジオナル行列を構築します。結果は <code>SymTridiagonal</code> 型であり、効率的な特化型固有値ソルバーを提供しますが、<a href="../base/base.html#Base.convert"><code>convert(Array, _)</code></a>（または短縮形の <code>Array(_)</code>）を使用して通常の行列に変換することができます。</p><p><code>SymTridiagonal</code> ブロック行列の場合、<code>dv</code> の要素は対称化されます。引数 <code>ev</code> は上対角成分として解釈されます。下対角成分のブロックは、対応する上対角成分のブロックの（具現化された）転置です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dv = [1, 2, 3, 4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Vector{Int64}:
 7
 8
 9

julia&gt; SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64, Vector{Int64}}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4

julia&gt; A = SymTridiagonal(fill([1 2; 3 4], 3), fill([1 2; 3 4], 2));

julia&gt; A[1,1]
2×2 Symmetric{Int64, Matrix{Int64}}:
 1  2
 2  4

julia&gt; A[1,2]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; A[2,1]
2×2 Matrix{Int64}:
 1  3
 2  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/tridiag.jl#L18-L69">source</a></section><section><div><pre><code class="language-julia hljs">SymTridiagonal(A::AbstractMatrix)</code></pre><p>対称行列 <code>A</code> の対角成分と最初の上対角成分から対称トリジオナル行列を構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3; 2 4 5; 3 5 6]
3×3 Matrix{Int64}:
 1  2  3
 2  4  5
 3  5  6

julia&gt; SymTridiagonal(A)
3×3 SymTridiagonal{Int64, Vector{Int64}}:
 1  2  ⋅
 2  4  5
 ⋅  5  6

julia&gt; B = reshape([[1 2; 2 3], [1 2; 3 4], [1 3; 2 4], [1 2; 2 3]], 2, 2);

julia&gt; SymTridiagonal(B)
2×2 SymTridiagonal{Matrix{Int64}, Vector{Matrix{Int64}}}:
 [1 2; 2 3]  [1 3; 2 4]
 [1 2; 3 4]  [1 2; 2 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/tridiag.jl#L82-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Tridiagonal" href="#LinearAlgebra.Tridiagonal"><code>LinearAlgebra.Tridiagonal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tridiagonal(dl::V, d::V, du::V) where V &lt;: AbstractVector</code></pre><p>それぞれ最初の下対角成分、対角成分、最初の上対角成分から三重対角行列を構築します。結果は <code>Tridiagonal</code> 型であり、効率的な特化型線形ソルバーを提供しますが、<a href="../base/base.html#Base.convert"><code>convert(Array, _)</code></a>（または短縮形の <code>Array(_)</code>）を使用して通常の行列に変換することができます。<code>dl</code> と <code>du</code> の長さは <code>d</code> の長さよりも1少なくなければなりません。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>下対角成分 <code>dl</code> と上対角成分 <code>du</code> は互いにエイリアスであってはなりません。エイリアスが検出された場合、コンストラクタは引数として <code>du</code> のコピーを使用します。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dl = [1, 2, 3];

julia&gt; du = [4, 5, 6];

julia&gt; d = [7, 8, 9, 0];

julia&gt; Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64, Vector{Int64}}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/tridiag.jl#L495-L523">source</a></section><section><div><pre><code class="language-julia hljs">Tridiagonal(A)</code></pre><p>行列 <code>A</code> の最初の下対角成分、対角成分、および最初の上対角成分から三重対角行列を構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Matrix{Int64}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia&gt; Tridiagonal(A)
4×4 Tridiagonal{Int64, Vector{Int64}}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/tridiag.jl#L543-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Symmetric" href="#LinearAlgebra.Symmetric"><code>LinearAlgebra.Symmetric</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Symmetric(A::AbstractMatrix, uplo::Symbol=:U)</code></pre><p>行列 <code>A</code> の上三角（<code>uplo = :U</code> の場合）または下三角（<code>uplo = :L</code> の場合）の <code>Symmetric</code> ビューを構築します。</p><p><code>Symmetric</code> ビューは主に実対称行列に対して有用であり、特化したアルゴリズム（例えば固有値問題用）が <code>Symmetric</code> 型に対して有効になります。より一般的には、実行列に対しては <code>Symmetric</code> と実質的に同等ですが、複素行列にも有用なエルミート行列 <code>A == A&#39;</code> のために <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian(A)</code></a> も参照してください。（複素 <code>Symmetric</code> 行列はサポートされていますが、特化したアルゴリズムはほとんどありません。）</p><p>実行列の対称部分、または一般的には実行列または複素行列 <code>A</code> のエルミート部分 <code>(A + A&#39;) / 2</code> を計算するには、<a href="LinearAlgebra.html#LinearAlgebra.hermitianpart"><code>hermitianpart</code></a> を使用してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; Supper = Symmetric(A)
3×3 Symmetric{Int64, Matrix{Int64}}:
 1  2  3
 2  5  6
 3  6  9

julia&gt; Slower = Symmetric(A, :L)
3×3 Symmetric{Int64, Matrix{Int64}}:
 1  4  7
 4  5  8
 7  8  9

julia&gt; hermitianpart(A)
3×3 Hermitian{Float64, Matrix{Float64}}:
 1.0  3.0  5.0
 3.0  5.0  7.0
 5.0  7.0  9.0</code></pre><p><code>Supper</code> は <code>A</code> 自体が対称でない限り（例えば <code>A == transpose(A)</code> の場合） <code>Slower</code> と等しくなりません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetric.jl#L14-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Hermitian" href="#LinearAlgebra.Hermitian"><code>LinearAlgebra.Hermitian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hermitian(A::AbstractMatrix, uplo::Symbol=:U)</code></pre><p>行列 <code>A</code> の上三角（<code>uplo = :U</code> の場合）または下三角（<code>uplo = :L</code> の場合）の <code>Hermitian</code> ビューを構築します。</p><p><code>A</code> の Hermitian 部分を計算するには、<a href="LinearAlgebra.html#LinearAlgebra.hermitianpart"><code>hermitianpart</code></a> を使用してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2+2im 3-3im; 4 5 6-6im; 7 8+8im 9]
3×3 Matrix{Complex{Int64}}:
 1+0im  2+2im  3-3im
 4+0im  5+0im  6-6im
 7+0im  8+8im  9+0im

julia&gt; Hupper = Hermitian(A)
3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:
 1+0im  2+2im  3-3im
 2-2im  5+0im  6-6im
 3+3im  6+6im  9+0im

julia&gt; Hlower = Hermitian(A, :L)
3×3 Hermitian{Complex{Int64}, Matrix{Complex{Int64}}}:
 1+0im  4+0im  7+0im
 4+0im  5+0im  8-8im
 7+0im  8+8im  9+0im

julia&gt; hermitianpart(A)
3×3 Hermitian{ComplexF64, Matrix{ComplexF64}}:
 1.0+0.0im  3.0+1.0im  5.0-1.5im
 3.0-1.0im  5.0+0.0im  7.0-7.0im
 5.0+1.5im  7.0+7.0im  9.0+0.0im</code></pre><p><code>Hupper</code> は <code>A</code> 自体が Hermitian でない限り（例えば <code>A == adjoint(A)</code> の場合） <code>Hlower</code> と等しくなりません。</p><p>対角線のすべての非実部は無視されます。</p><pre><code class="language-julia hljs">Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetric.jl#L107-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LowerTriangular" href="#LinearAlgebra.LowerTriangular"><code>LinearAlgebra.LowerTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LowerTriangular(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の <code>LowerTriangular</code> ビューを構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; LowerTriangular(A)
3×3 LowerTriangular{Float64, Matrix{Float64}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/triangular.jl#L63-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.UpperTriangular" href="#LinearAlgebra.UpperTriangular"><code>LinearAlgebra.UpperTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UpperTriangular(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の <code>UpperTriangular</code> ビューを構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UpperTriangular(A)
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/triangular.jl#L84-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.UnitLowerTriangular" href="#LinearAlgebra.UnitLowerTriangular"><code>LinearAlgebra.UnitLowerTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitLowerTriangular(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の <code>UnitLowerTriangular</code> ビューを構築します。このようなビューは、<code>A</code> の <a href="../base/collections.html#Base.eltype"><code>eltype</code></a> の <a href="../base/numbers.html#Base.oneunit"><code>oneunit</code></a> を対角線上に持ちます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UnitLowerTriangular(A)
3×3 UnitLowerTriangular{Float64, Matrix{Float64}}:
 1.0   ⋅    ⋅
 4.0  1.0   ⋅
 7.0  8.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/triangular.jl#L105-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.UnitUpperTriangular" href="#LinearAlgebra.UnitUpperTriangular"><code>LinearAlgebra.UnitUpperTriangular</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitUpperTriangular(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の <code>UnitUpperTriangular</code> ビューを構築します。このようなビューは、<code>A</code> の <a href="../base/collections.html#Base.eltype"><code>eltype</code></a> の <a href="../base/numbers.html#Base.oneunit"><code>oneunit</code></a> を対角線上に持ちます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Matrix{Float64}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UnitUpperTriangular(A)
3×3 UnitUpperTriangular{Float64, Matrix{Float64}}:
 1.0  2.0  3.0
  ⋅   1.0  6.0
  ⋅    ⋅   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/triangular.jl#L128-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.UpperHessenberg" href="#LinearAlgebra.UpperHessenberg"><code>LinearAlgebra.UpperHessenberg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UpperHessenberg(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の <code>UpperHessenberg</code> ビューを構築します。最初の副対角線の下にある <code>A</code> のエントリは無視されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>この型は Julia 1.3 で追加されました。</p></div></div><p><code>H \ b</code>、<code>det(H)</code>、および類似の効率的なアルゴリズムが実装されています。</p><p>任意の行列を類似の上部ヘッセンベルク行列に因数分解する <a href="LinearAlgebra.html#LinearAlgebra.hessenberg"><code>hessenberg</code></a> 関数も参照してください。</p><p><code>F::Hessenberg</code> が因数分解オブジェクトである場合、ユニタリ行列は <code>F.Q</code> でアクセスでき、ヘッセンベルク行列は <code>F.H</code> でアクセスできます。<code>Q</code> が抽出されると、結果の型は <code>HessenbergQ</code> オブジェクトになり、<a href="../base/base.html#Base.convert"><code>convert(Array, _)</code></a>（または短縮形の <code>Array(_)</code>）を使って通常の行列に変換できます。</p><p>分解を反復すると、因子 <code>F.Q</code> と <code>F.H</code> が得られます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
4×4 Matrix{Int64}:
  1   2   3   4
  5   6   7   8
  9  10  11  12
 13  14  15  16

julia&gt; UpperHessenberg(A)
4×4 UpperHessenberg{Int64, Matrix{Int64}}:
 1   2   3   4
 5   6   7   8
 ⋅  10  11  12
 ⋅   ⋅  15  16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/hessenberg.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.UniformScaling" href="#LinearAlgebra.UniformScaling"><code>LinearAlgebra.UniformScaling</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UniformScaling{T&lt;:Number}</code></pre><p>スカラーと単位演算子 <code>λ*I</code> の積として定義された一般的なサイズの均一スケーリング演算子。明示的な <code>size</code> はありませんが、多くの場合、行列のように動作し、一部のインデックス指定をサポートします。詳細は <a href="LinearAlgebra.html#LinearAlgebra.I"><code>I</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>範囲を使用したインデックス指定は、Julia 1.6 以降で利用可能です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia&gt; A = [1. 2.; 3. 4.]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; J*A
2×2 Matrix{Float64}:
 2.0  4.0
 6.0  8.0

julia&gt; J[1:2, 1:2]
2×2 Matrix{Float64}:
 2.0  0.0
 0.0  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/uniformscaling.jl#L6-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.I" href="#LinearAlgebra.I"><code>LinearAlgebra.I</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">I</code></pre><p>任意のサイズの単位行列を表す<a href="LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a>型のオブジェクト。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fill(1, (5,6)) * I == fill(1, (5,6))
true

julia&gt; [1 2im 3; 1im 2 3] * I
2×3 Matrix{Complex{Int64}}:
 1+0im  0+2im  3+0im
 0+1im  2+0im  3+0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/uniformscaling.jl#L43-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.UniformScaling-Tuple{Integer}" href="#LinearAlgebra.UniformScaling-Tuple{Integer}"><code>LinearAlgebra.UniformScaling</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(I::UniformScaling)(n::Integer)</code></pre><p><code>UniformScaling</code>から<code>Diagonal</code>行列を構築します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>このメソッドはJulia 1.2以降で利用可能です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I(3)
3×3 Diagonal{Bool, Vector{Bool}}:
 1  ⋅  ⋅
 ⋅  1  ⋅
 ⋅  ⋅  1

julia&gt; (0.7*I)(3)
3×3 Diagonal{Float64, Vector{Float64}}:
 0.7   ⋅    ⋅
  ⋅   0.7   ⋅
  ⋅    ⋅   0.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/uniformscaling.jl#L61-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Factorization" href="#LinearAlgebra.Factorization"><code>LinearAlgebra.Factorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.Factorization</code></pre><p>行列因子分解（<a href="https://en.wikipedia.org/wiki/Matrix_decomposition">matrix factorizations</a>）の抽象型。利用可能な行列因子分解のリストについては、<a href="LinearAlgebra.html#man-linalg-factorizations">オンラインドキュメント</a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/factorization.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LU" href="#LinearAlgebra.LU"><code>LinearAlgebra.LU</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LU &lt;: Factorization</code></pre><p>正方行列 <code>A</code> の <code>LU</code> 分解の行列分解型です。これは、対応する行列分解関数 <a href="LinearAlgebra.html#LinearAlgebra.lu"><code>lu</code></a> の戻り値の型です。</p><p>分解 <code>F::LU</code> の個々のコンポーネントには、<a href="../base/base.html#Base.getproperty"><code>getproperty</code></a> を介してアクセスできます：</p><table><tr><th style="text-align: left">コンポーネント</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>F.L</code></td><td style="text-align: left"><code>LU</code> の <code>L</code>（単位下三角）部分</td></tr><tr><td style="text-align: left"><code>F.U</code></td><td style="text-align: left"><code>LU</code> の <code>U</code>（上三角）部分</td></tr><tr><td style="text-align: left"><code>F.p</code></td><td style="text-align: left">（右）置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>F.P</code></td><td style="text-align: left">（右）置換 <code>Matrix</code></td></tr></table><p>分解を反復すると、コンポーネント <code>F.L</code>、<code>F.U</code>、および <code>F.p</code> が生成されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4 3; 6 3]
2×2 Matrix{Int64}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L factor:
2×2 Matrix{Float64}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Matrix{Float64}:
 6.0  3.0
 0.0  1.0

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # 反復を介した分解

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lu.jl#L6-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lu" href="#LinearAlgebra.lu"><code>LinearAlgebra.lu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lu(A::AbstractSparseMatrixCSC; check = true, q = nothing, control = get_umfpack_control()) -&gt; F::UmfpackLU</code></pre><p>スパース行列 <code>A</code> のLU因子分解を計算します。</p><p>実数または複素数要素型のスパース <code>A</code> の場合、<code>F</code> の戻り値の型は <code>UmfpackLU{Tv, Ti}</code> であり、<code>Tv</code> は <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> でそれぞれ、<code>Ti</code> は整数型（<a href="../base/numbers.html#Core.Int32"><code>Int32</code></a> または <a href="../base/numbers.html#Core.Int64"><code>Int64</code></a>）です。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p>置換 <code>q</code> は置換ベクトルまたは <code>nothing</code> である可能性があります。置換ベクトルが提供されない場合や <code>q</code> が <code>nothing</code> の場合、UMFPACKのデフォルトが使用されます。置換がゼロベースでない場合、ゼロベースのコピーが作成されます。</p><p><code>control</code> ベクトルは、UMFPACKのためのJulia SparseArraysパッケージのデフォルト設定にデフォルトで設定されます（注：これは反復精度を無効にするためにUMFPACKのデフォルトから修正されています）が、<code>UMFPACK_CONTROL</code> の長さのベクトルを渡すことで変更できます。可能な設定についてはUMFPACKマニュアルを参照してください。たとえば、反復精度を再有効にするには：</p><pre><code class="nohighlight hljs">umfpack_control = SparseArrays.UMFPACK.get_umfpack_control(Float64, Int64) # Float64スパース行列のためのJuliaデフォルト設定を読み取る
SparseArrays.UMFPACK.show_umf_ctrl(umfpack_control) # オプション - 値を表示
umfpack_control[SparseArrays.UMFPACK.JL_UMFPACK_IRSTEP] = 2.0 # 反復精度を再有効にする（2はUMFPACKのデフォルトの最大反復精度ステップ）

Alu = lu(A; control = umfpack_control)
x = Alu \ b   # Ax = bを解く、UMFPACKの反復精度を含む</code></pre><p>因子分解 <code>F</code> の個々のコンポーネントにはインデックスを使用してアクセスできます：</p><table><tr><th style="text-align: left">コンポーネント</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>L</code></td><td style="text-align: left"><code>LU</code> の下三角部分 <code>L</code></td></tr><tr><td style="text-align: left"><code>U</code></td><td style="text-align: left"><code>LU</code> の上三角部分 <code>U</code></td></tr><tr><td style="text-align: left"><code>p</code></td><td style="text-align: left">右置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>q</code></td><td style="text-align: left">左置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>Rs</code></td><td style="text-align: left">スケーリングファクターの <code>Vector</code></td></tr><tr><td style="text-align: left"><code>:</code></td><td style="text-align: left"><code>(L,U,p,q,Rs)</code> コンポーネント</td></tr></table><p><code>F</code> と <code>A</code> の関係は次の通りです。</p><p><code>F.L*F.U == (F.Rs .* A)[F.p, F.q]</code></p><p><code>F</code> はさらに以下の関数をサポートしています：</p><ul><li><a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a></li><li><a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a></li></ul><p>また <a href="LinearAlgebra.html#LinearAlgebra.lu!"><code>lu!</code></a> も参照してください。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>lu(A::AbstractSparseMatrixCSC)</code> は、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の一部であるUMFPACK<sup class="footnote-reference"><a id="citeref-ACM832" href="#footnote-ACM832">[ACM832]</a></sup>ライブラリを使用します。このライブラリは、<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> 要素を持つスパース行列のみをサポートしているため、<code>lu</code> は <code>A</code> を <code>SparseMatrixCSC{Float64}</code> または <code>SparseMatrixCSC{ComplexF64}</code> 型のコピーに変換します。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/umfpack.jl#L325-L383">source</a></section><section><div><pre><code class="language-julia hljs">lu(A, pivot = RowMaximum(); check = true, allowsingular = false) -&gt; F::LU</code></pre><p>行列 <code>A</code> の LU 分解を計算します。</p><p><code>check = true</code> の場合、分解が失敗した場合にエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任はユーザーにあります（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）。</p><p>デフォルトでは、<code>check = true</code> の場合、分解が有効な因子を生成しても、上三角因子 <code>U</code> がランク欠損の場合にもエラーがスローされます。これは <code>allowsingular = true</code> を渡すことで変更できます。</p><p>ほとんどの場合、<code>A</code> が要素型 <code>T</code> を持ち、<code>+</code>、<code>-</code>、<code>*</code> および <code>/</code> をサポートする <code>AbstractMatrix{T}</code> のサブタイプ <code>S</code> である場合、戻り値の型は <code>LU{T,S{T}}</code> です。</p><p>一般に、LU 分解は行列の行の順序を入れ替えることを含みます（以下に説明する <code>F.p</code> 出力に対応）、これは「ピボット」と呼ばれます（これは「ピボット」を含む行を選択することに対応し、<code>F.U</code> の対角成分です）。次のいずれかのピボット戦略をオプションの <code>pivot</code> 引数を介して選択できます：</p><ul><li><code>RowMaximum()</code>（デフォルト）：標準のピボット戦略；ピボットは、残りの因子化される行の中で最大絶対値を持つ要素に対応します。このピボット戦略は、要素型が <a href="../base/math.html#Base.abs"><code>abs</code></a> および <a href="../base/math.html#Base.:&lt;"><code>&lt;</code></a> をサポートすることを要求します。（これは一般に浮動小数点行列に対して唯一の数値的に安定したオプションです。）</li><li><code>RowNonZero()</code>: ピボットは、残りの因子化される行の中で最初の非ゼロ要素に対応します。（これは手計算での典型的な選択に対応し、<code>abs</code> や <code>&lt;</code> をサポートしないより一般的な代数数型にも便利です。）</li><li><code>NoPivot()</code>: ピボットをオフにします（<code>allowsingular = true</code> の場合でも、ピボット位置でゼロエントリに遭遇すると失敗します）。</li></ul><p>分解 <code>F</code> の個々のコンポーネントには <a href="../base/base.html#Base.getproperty"><code>getproperty</code></a> を介してアクセスできます：</p><table><tr><th style="text-align: left">コンポーネント</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: left"><code>F.L</code></td><td style="text-align: left"><code>LU</code> の <code>L</code>（下三角）部分</td></tr><tr><td style="text-align: left"><code>F.U</code></td><td style="text-align: left"><code>LU</code> の <code>U</code>（上三角）部分</td></tr><tr><td style="text-align: left"><code>F.p</code></td><td style="text-align: left">（右）置換 <code>Vector</code></td></tr><tr><td style="text-align: left"><code>F.P</code></td><td style="text-align: left">（右）置換 <code>Matrix</code></td></tr></table><p>分解を反復すると、コンポーネント <code>F.L</code>、<code>F.U</code>、および <code>F.p</code> が得られます。</p><p><code>F</code> と <code>A</code> の関係は次の通りです。</p><p><code>F.L*F.U == A[F.p, :]</code></p><p><code>F</code> はさらに次の関数をサポートします：</p><table><tr><th style="text-align: left">サポートされる関数</th><th style="text-align: left"><code>LU</code></th><th style="text-align: left"><code>LU{T,Tridiagonal{T}}</code></th></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:/"><code>/</code></a></td><td style="text-align: left">✓</td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="LinearAlgebra.html#LinearAlgebra.logabsdet"><code>logabsdet</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr><tr><td style="text-align: left"><a href="../base/arrays.html#Base.size"><code>size</code></a></td><td style="text-align: left">✓</td><td style="text-align: left">✓</td></tr></table><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>allowsingular</code> キーワード引数は Julia 1.11 で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4 3; 6 3]
2×2 Matrix{Int64}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L factor:
2×2 Matrix{Float64}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Matrix{Float64}:
 6.0  3.0
 0.0  1.0

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # 反復を介した分解

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true

julia&gt; lu([1 2; 1 2], allowsingular = true)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L factor:
2×2 Matrix{Float64}:
 1.0  0.0
 1.0  1.0
U factor (rank-deficient):
2×2 Matrix{Float64}:
 1.0  2.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lu.jl#L240-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lu!" href="#LinearAlgebra.lu!"><code>LinearAlgebra.lu!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lu!(F::UmfpackLU, A::AbstractSparseMatrixCSC; check=true, reuse_symbolic=true, q=nothing) -&gt; F::UmfpackLU</code></pre><p>スパース行列 <code>A</code> のLU因子分解を計算し、既存のLU因子分解 <code>F</code> に保存されている符号的因子分解を再利用します。<code>reuse_symbolic</code> が false に設定されていない限り、スパース行列 <code>A</code> はLU因子分解 <code>F</code> を作成するために使用された行列と同一の非ゼロパターンを持っている必要があり、そうでない場合はエラーがスローされます。<code>A</code> と <code>F</code> のサイズが異なる場合、すべてのベクトルはそれに応じてサイズ変更されます。</p><p><code>check = true</code> の場合、分解が失敗した場合にエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任はユーザーにあります（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）。</p><p>置換 <code>q</code> は置換ベクトルまたは <code>nothing</code> である可能性があります。置換ベクトルが提供されない場合や <code>q</code> が <code>nothing</code> の場合、UMFPACK のデフォルトが使用されます。置換がゼロベースでない場合、ゼロベースのコピーが作成されます。</p><p>他にも <a href="LinearAlgebra.html#LinearAlgebra.lu"><code>lu</code></a> を参照してください。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>lu!(F::UmfpackLU, A::AbstractSparseMatrixCSC)</code> は SuiteSparse の一部である UMFPACK ライブラリを使用します。このライブラリは <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> 要素を持つスパース行列のみをサポートしているため、<code>lu!</code> は自動的にLU因子分解によって設定された型または適切な <code>SparseMatrixCSC{ComplexF64}</code> に型を変換します。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>UmfpackLU</code> の <code>lu!</code> は少なくとも Julia 1.5 を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(Float64[1.0 2.0; 0.0 3.0]);

julia&gt; F = lu(A);

julia&gt; B = sparse(Float64[1.0 1.0; 0.0 1.0]);

julia&gt; lu!(F, B);

julia&gt; F \ ones(2)
2-element Vector{Float64}:
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/umfpack.jl#L415-L459">source</a></section><section><div><pre><code class="language-julia hljs">lu!(A, pivot = RowMaximum(); check = true, allowsingular = false) -&gt; LU</code></pre><p><code>lu!</code> は <a href="LinearAlgebra.html#LinearAlgebra.lu"><code>lu</code></a> と同じですが、入力 <code>A</code> を上書きすることでスペースを節約します。因子分解が <code>A</code> の要素型で表現できない数を生成した場合、例えば整数型の場合、<a href="../base/base.html#Core.InexactError"><code>InexactError</code></a> 例外がスローされます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>allowsingular</code> キーワード引数は Julia 1.11 で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4. 3.; 6. 3.]
2×2 Matrix{Float64}:
 4.0  3.0
 6.0  3.0

julia&gt; F = lu!(A)
LU{Float64, Matrix{Float64}, Vector{Int64}}
L 因子:
2×2 Matrix{Float64}:
 1.0       0.0
 0.666667  1.0
U 因子:
2×2 Matrix{Float64}:
 6.0  3.0
 0.0  1.0

julia&gt; iA = [4 3; 6 3]
2×2 Matrix{Int64}:
 4  3
 6  3

julia&gt; lu!(iA)
ERROR: InexactError: Int64(0.6666666666666666)
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lu.jl#L110-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Cholesky" href="#LinearAlgebra.Cholesky"><code>LinearAlgebra.Cholesky</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cholesky &lt;: Factorization</code></pre><p>密な対称/エルミート正定値行列 <code>A</code> のためのコレスキー分解の行列因子化タイプです。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> の戻り値の型です。</p><p>三角形のコレスキー因子は、因子分解 <code>F::Cholesky</code> から <code>F.L</code> および <code>F.U</code> を介して取得でき、<code>A ≈ F.U&#39; * F.U ≈ F.L * F.L&#39;</code> となります。</p><p><code>Cholesky</code> オブジェクトに対して利用可能な関数は、<a href="../base/arrays.html#Base.size"><code>size</code></a>、<a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>、<a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a>、および <a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a> です。</p><p>分解を反復することで、成分 <code>L</code> と <code>U</code> が得られます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Matrix{Float64}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64, Matrix{Float64}}
U factor:
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.U
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.L
3×3 LowerTriangular{Float64, Matrix{Float64}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true

julia&gt; l, u = C; # destructuring via iteration

julia&gt; l == C.L &amp;&amp; u == C.U
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L30-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.CholeskyPivoted" href="#LinearAlgebra.CholeskyPivoted"><code>LinearAlgebra.CholeskyPivoted</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CholeskyPivoted</code></pre><p>密な対称/エルミート半正定値行列 <code>A</code> のピボット付きコレスキー分解の行列因子化タイプです。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky(_, ::RowMaximum)</code></a> の返り値の型です。</p><p>三角形のコレスキー因子は、因子分解 <code>F::CholeskyPivoted</code> から <code>F.L</code> と <code>F.U</code> を介して取得でき、置換は <code>F.p</code> を介して取得できます。ここで、<code>A[F.p, F.p] ≈ Ur&#39; * Ur ≈ Lr * Lr&#39;</code> であり、<code>Ur = F.U[1:F.rank, :]</code> および <code>Lr = F.L[:, 1:F.rank]</code> です。または、<code>A ≈ Up&#39; * Up ≈ Lp * Lp&#39;</code> であり、<code>Up = F.U[1:F.rank, invperm(F.p)]</code> および <code>Lp = F.L[invperm(F.p), 1:F.rank]</code> です。</p><p><code>CholeskyPivoted</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/arrays.html#Base.size"><code>size</code></a>, <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>, <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, および <a href="LinearAlgebra.html#LinearAlgebra.rank"><code>rank</code></a>。</p><p>分解を反復することで、成分 <code>L</code> と <code>U</code> が生成されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = [1.0, 2.0, 3.0, 4.0];

julia&gt; A = X * X&#39;;

julia&gt; C = cholesky(A, RowMaximum(), check = false)
CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}
U因子のランクは1:
4×4 UpperTriangular{Float64, Matrix{Float64}}:
 4.0  2.0  3.0  1.0
  ⋅   0.0  6.0  2.0
  ⋅    ⋅   9.0  3.0
  ⋅    ⋅    ⋅   1.0
置換:
4要素のベクトル{Int64}:
 4
 2
 3
 1

julia&gt; C.U[1:C.rank, :]&#39; * C.U[1:C.rank, :] ≈ A[C.p, C.p]
true

julia&gt; l, u = C; # 反復による分解

julia&gt; l == C.L &amp;&amp; u == C.U
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L105-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky" href="#LinearAlgebra.cholesky"><code>LinearAlgebra.cholesky</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cholesky(A, NoPivot(); check = true) -&gt; Cholesky</code></pre><p>密な対称正定値行列 <code>A</code> のコレスキー分解を計算し、<a href="LinearAlgebra.html#LinearAlgebra.Cholesky"><code>Cholesky</code></a> 分解を返します。行列 <code>A</code> は、<a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <a href="../base/arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> であるか、<em>完全に</em> 対称またはエルミートな <code>AbstractMatrix</code> である必要があります。</p><p>三角形のコレスキー因子は、分解 <code>F</code> から <code>F.L</code> および <code>F.U</code> を介して取得でき、<code>A ≈ F.U&#39; * F.U ≈ F.L * F.L&#39;</code> となります。</p><p><code>Cholesky</code> オブジェクトに対して利用可能な関数は、<a href="../base/arrays.html#Base.size"><code>size</code></a>、<a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>、<a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a> および <a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a> です。</p><p>構築時の丸め誤差により行列 <code>A</code> がわずかに非エルミートである場合は、<code>cholesky</code> に渡す前に <code>Hermitian(A)</code> でラップして、完全にエルミートとして扱います。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Matrix{Float64}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64, Matrix{Float64}}
U因子:
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.U
3×3 UpperTriangular{Float64, Matrix{Float64}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.L
3×3 LowerTriangular{Float64, Matrix{Float64}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L349-L400">source</a></section><section><div><pre><code class="language-julia hljs">cholesky(A, RowMaximum(); tol = 0.0, check = true) -&gt; CholeskyPivoted</code></pre><p>密な対称半正定値行列 <code>A</code> のピボット付きコレスキー分解を計算し、<a href="LinearAlgebra.html#LinearAlgebra.CholeskyPivoted"><code>CholeskyPivoted</code></a> 分解を返します。行列 <code>A</code> は、<a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> <a href="../base/arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> であるか、<em>完全に</em> 対称またはエルミートな <code>AbstractMatrix</code> である必要があります。</p><p>三角形のコレスキー因子は、分解 <code>F</code> から <code>F.L</code> と <code>F.U</code> を介して取得でき、置換は <code>F.p</code> を介して取得できます。ここで、<code>A[F.p, F.p] ≈ Ur&#39; * Ur ≈ Lr * Lr&#39;</code> であり、<code>Ur = F.U[1:F.rank, :]</code> および <code>Lr = F.L[:, 1:F.rank]</code> です。または、<code>A ≈ Up&#39; * Up ≈ Lp * Lp&#39;</code> であり、<code>Up = F.U[1:F.rank, invperm(F.p)]</code> および <code>Lp = F.L[invperm(F.p), 1:F.rank]</code> です。</p><p><code>CholeskyPivoted</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/arrays.html#Base.size"><code>size</code></a>, <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>, <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, および <a href="LinearAlgebra.html#LinearAlgebra.rank"><code>rank</code></a>。</p><p>引数 <code>tol</code> は、ランクを決定するための許容誤差を決定します。負の値の場合、許容誤差は機械精度です。</p><p>構築時の丸め誤差により、行列 <code>A</code> がわずかに非エルミートである場合は、<code>cholesky</code> に渡す前に <code>Hermitian(A)</code> でラップして、完全にエルミートとして扱います。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = [1.0, 2.0, 3.0, 4.0];

julia&gt; A = X * X&#39;;

julia&gt; C = cholesky(A, RowMaximum(), check = false)
CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}
U因子のランクは1:
4×4 UpperTriangular{Float64, Matrix{Float64}}:
 4.0  2.0  3.0  1.0
  ⋅   0.0  6.0  2.0
  ⋅    ⋅   9.0  3.0
  ⋅    ⋅    ⋅   1.0
置換:
4要素のベクトル{Int64}:
 4
 2
 3
 1

julia&gt; C.U[1:C.rank, :]&#39; * C.U[1:C.rank, :] ≈ A[C.p, C.p]
true

julia&gt; l, u = C; # 繰り返しによる分解

julia&gt; l == C.L &amp;&amp; u == C.U
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L414-L468">source</a></section><section><div><pre><code class="language-julia hljs">cholesky(A::SparseMatrixCSC; shift = 0.0, check = true, perm = nothing) -&gt; CHOLMOD.Factor</code></pre><p>スパースの正定値行列 <code>A</code> のコレスキー分解を計算します。<code>A</code> は <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> または <code>SparseMatrixCSC</code> の <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> ビューでなければなりません。<code>A</code> に型タグがなくても、対称またはエルミートである必要があります。<code>perm</code> が指定されていない場合、フィル削減置換が使用されます。<code>F = cholesky(A)</code> は、<code>F\b</code> を使用して方程式系を解くために最も頻繁に使用されますが、<a href="LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、および <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a> のメソッドも <code>F</code> に対して定義されています。<code>F</code> から個々の因子を抽出することもでき、<code>F.L</code> を使用します。ただし、ピボットがデフォルトでオンになっているため、分解は内部的に <code>A == P&#39;*L*L&#39;*P</code> として表現され、置換行列 <code>P</code> が含まれます。<code>P</code> を考慮せずに <code>L</code> のみを使用すると、誤った結果が得られます。置換の効果を含めるためには、通常、<code>PtL = F.PtL</code>（<code>P&#39;*L</code> の同等物）や <code>LtP = F.UP</code>（<code>L&#39;*P</code> の同等物）などの「結合」因子を抽出する方が好ましいです。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p>オプションの <code>shift</code> キーワード引数を設定すると、<code>A</code> の代わりに <code>A+shift*I</code> の分解が計算されます。<code>perm</code> 引数が提供される場合、それは <code>1:size(A,1)</code> の置換であり、使用する順序を指定します（CHOLMOD のデフォルトの AMD 順序の代わりに）。</p><p><strong>例</strong></p><p>次の例では、使用されるフィル削減置換は <code>[3, 2, 1]</code> です。<code>perm</code> が <code>1:3</code> に設定されて置換が行われない場合、因子内の非ゼロ要素の数は 6 になります。</p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 1 1; 1 2 0; 1 0 2]
3×3 Matrix{Int64}:
 2  1  1
 1  2  0
 1  0  2

julia&gt; C = cholesky(sparse(A))
SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  5
nnz:     5
success: true

julia&gt; C.p
3-element Vector{Int64}:
 3
 2
 1

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Matrix{Float64}:
 1.41421   0.0       0.0
 0.0       1.41421   0.0
 0.707107  0.707107  1.0

julia&gt; L * L&#39; ≈ A[C.p, C.p]
true

julia&gt; P = sparse(1:3, C.p, ones(3))
3×3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
  ⋅    ⋅   1.0
  ⋅   1.0   ⋅
 1.0   ⋅    ⋅

julia&gt; P&#39; * L * L&#39; * P ≈ A
true

julia&gt; C = cholesky(sparse(A), perm=1:3)
SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  6
nnz:     6
success: true

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Matrix{Float64}:
 1.41421    0.0       0.0
 0.707107   1.22474   0.0
 0.707107  -0.408248  1.1547

julia&gt; L * L&#39; ≈ A
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の CHOLMOD<sup class="footnote-reference"><a id="citeref-ACM887" href="#footnote-ACM887">[ACM887]</a></sup><sup class="footnote-reference"><a id="citeref-DavisHager2009" href="#footnote-DavisHager2009">[DavisHager2009]</a></sup> ライブラリを使用しています。CHOLMOD は、単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p><p>CHOLMOD からの他の多くの関数はラップされていますが、<code>Base.SparseArrays.CHOLMOD</code> モジュールからはエクスポートされていません。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1502-L1608">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cholesky!" href="#LinearAlgebra.cholesky!"><code>LinearAlgebra.cholesky!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cholesky!(A::AbstractMatrix, NoPivot(); check = true) -&gt; Cholesky</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> と同じですが、入力 <code>A</code> を上書きすることでスペースを節約します。コピーを作成するのではありません。因子分解が <code>A</code> の要素型で表現できない数を生成した場合、例えば整数型の場合、<a href="../base/base.html#Core.InexactError"><code>InexactError</code></a> 例外がスローされます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 2 50]
2×2 Matrix{Int64}:
 1   2
 2  50

julia&gt; cholesky!(A)
ERROR: InexactError: Int64(6.782329983125268)
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L274-L294">source</a></section><section><div><pre><code class="language-julia hljs">cholesky!(A::AbstractMatrix, RowMaximum(); tol = 0.0, check = true) -&gt; CholeskyPivoted</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> と同様ですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。因子分解が <code>A</code> の要素型で表現できない数を生成した場合、例えば整数型の場合、<a href="../base/base.html#Core.InexactError"><code>InexactError</code></a> 例外がスローされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L325-L332">source</a></section><section><div><pre><code class="language-julia hljs">cholesky!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -&gt; CHOLMOD.Factor</code></pre><p>行列 <code>A</code> のコレスキー (<span>$LL&#39;$</span>) 分解を計算し、シンボリック分解 <code>F</code> を再利用します。<code>A</code> は <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/ <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> の <code>SparseMatrixCSC</code> のビューでなければなりません。<code>A</code> が型タグを持っていなくても、対称またはエルミートである必要があります。</p><p>詳細は <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> を参照してください。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、SuiteSparse の CHOLMOD ライブラリを使用しており、これは単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1466-L1481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankupdate" href="#LinearAlgebra.lowrankupdate"><code>LinearAlgebra.lowrankupdate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankupdate(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> を更新します。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U + v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の演算のみを使用します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L821-L827">source</a></section><section><div><pre><code class="language-julia hljs">lowrankupdate(F::CHOLMOD.Factor, C::AbstractArray) -&gt; FF::CHOLMOD.Factor</code></pre><p><code>A + C*C&#39;</code>の<code>LDLt</code>因子分解を、<code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を与えて取得します。</p><p>返される因子は常に<code>LDLt</code>因子分解です。</p><p>他にも<a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate!"><code>lowrankupdate!</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate"><code>lowrankdowndate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate!"><code>lowrankdowndate!</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1767-L1775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate" href="#LinearAlgebra.lowrankdowndate"><code>LinearAlgebra.lowrankdowndate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankdowndate(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> をダウンドデートします。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U - v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の演算のみを使用します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L830-L836">source</a></section><section><div><pre><code class="language-julia hljs">lowrankdowndate(F::CHOLMOD.Factor, C::AbstractArray) -&gt; FF::CHOLMOD.Factor</code></pre><p><code>A + C*C&#39;</code> の <code>LDLt</code> 因子分解を、<code>A</code> の <code>LDLt</code> または <code>LLt</code> 因子分解 <code>F</code> に基づいて取得します。</p><p>返される因子は常に <code>LDLt</code> 因子分解です。</p><p>他にも <a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate!"><code>lowrankdowndate!</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate"><code>lowrankupdate</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate!"><code>lowrankupdate!</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1782-L1790">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankupdate!" href="#LinearAlgebra.lowrankupdate!"><code>LinearAlgebra.lowrankupdate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankupdate!(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> を更新します。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U + v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の演算のみを使用します。入力の分解 <code>C</code> はインプレースで更新され、終了時には <code>C == CC</code> となります。ベクトル <code>v</code> は計算中に破棄されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L722-L729">source</a></section><section><div><pre><code class="language-julia hljs">lowrankupdate!(F::CHOLMOD.Factor, C::AbstractArray)</code></pre><p><code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を<code>A + C*C&#39;</code>の因子分解に更新します。</p><p><code>LLt</code>因子分解は<code>LDLt</code>に変換されます。</p><p><a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate"><code>lowrankupdate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate"><code>lowrankdowndate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate!"><code>lowrankdowndate!</code></a>も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1737-L1745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lowrankdowndate!" href="#LinearAlgebra.lowrankdowndate!"><code>LinearAlgebra.lowrankdowndate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lowrankdowndate!(C::Cholesky, v::AbstractVector) -&gt; CC::Cholesky</code></pre><p>ベクトル <code>v</code> で Cholesky 分解 <code>C</code> をダウンドデートします。もし <code>A = C.U&#39;C.U</code> ならば <code>CC = cholesky(C.U&#39;C.U - v*v&#39;)</code> ですが、<code>CC</code> の計算は <code>O(n^2)</code> の操作のみを使用します。入力の分解 <code>C</code> はインプレースで更新され、終了時には <code>C == CC</code> となります。ベクトル <code>v</code> は計算中に破棄されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/cholesky.jl#L768-L775">source</a></section><section><div><pre><code class="language-julia hljs">lowrankdowndate!(F::CHOLMOD.Factor, C::AbstractArray)</code></pre><p><code>A</code>の<code>LDLt</code>または<code>LLt</code>因子分解<code>F</code>を<code>A - C*C&#39;</code>の因子分解に更新します。</p><p><code>LLt</code>因子分解は<code>LDLt</code>に変換されます。</p><p><a href="LinearAlgebra.html#LinearAlgebra.lowrankdowndate"><code>lowrankdowndate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate"><code>lowrankupdate</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.lowrankupdate!"><code>lowrankupdate!</code></a>も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1752-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LDLt" href="#LinearAlgebra.LDLt"><code>LinearAlgebra.LDLt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LDLt &lt;: Factorization</code></pre><p>実数の <a href="LinearAlgebra.html#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a> 行列 <code>S</code> の <code>LDLt</code> 因子分解の行列因子分解タイプで、<code>S = L*Diagonal(d)*L&#39;</code> となります。ここで、<code>L</code> は <a href="LinearAlgebra.html#LinearAlgebra.UnitLowerTriangular"><code>UnitLowerTriangular</code></a> 行列で、<code>d</code> はベクトルです。<code>LDLt</code> 因子分解 <code>F = ldlt(S)</code> の主な用途は、線形方程式系 <code>Sx = b</code> を <code>F\b</code> で解くことです。これは、対応する行列因子分解関数 <a href="LinearAlgebra.html#LinearAlgebra.ldlt"><code>ldlt</code></a> の戻り値の型です。</p><p>因子分解 <code>F::LDLt</code> の個々のコンポーネントには <code>getproperty</code> を介してアクセスできます：</p><table><tr><th style="text-align: center">コンポーネント</th><th style="text-align: left">説明</th></tr><tr><td style="text-align: center"><code>F.L</code></td><td style="text-align: left"><code>LDLt</code> の <code>L</code>（単位下三角）部分</td></tr><tr><td style="text-align: center"><code>F.D</code></td><td style="text-align: left"><code>LDLt</code> の <code>D</code>（対角）部分</td></tr><tr><td style="text-align: center"><code>F.Lt</code></td><td style="text-align: left"><code>LDLt</code> の <code>Lt</code>（単位上三角）部分</td></tr><tr><td style="text-align: center"><code>F.d</code></td><td style="text-align: left"><code>D</code> の対角値を持つ <code>Vector</code></td></tr></table><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; F = ldlt(S)
LDLt{Float64, SymTridiagonal{Float64, Vector{Float64}}}
L 因子:
3×3 UnitLowerTriangular{Float64, SymTridiagonal{Float64, Vector{Float64}}}:
 1.0        ⋅         ⋅
 0.333333  1.0        ⋅
 0.0       0.545455  1.0
D 因子:
3×3 Diagonal{Float64, Vector{Float64}}:
 3.0   ⋅        ⋅
  ⋅   3.66667   ⋅
  ⋅    ⋅       3.90909</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/ldlt.jl#L3-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldlt" href="#LinearAlgebra.ldlt"><code>LinearAlgebra.ldlt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldlt(S::SymTridiagonal) -&gt; LDLt</code></pre><p>実数対称三重対角行列 <code>S</code> の <code>LDLt</code>（すなわち、<span>$LDL^T$</span>）因子分解を計算します。ここで、<code>S = L*Diagonal(d)*L&#39;</code> となり、<code>L</code> は単位下三角行列、<code>d</code> はベクトルです。<code>LDLt</code> 因子分解 <code>F = ldlt(S)</code> の主な用途は、線形方程式系 <code>Sx = b</code> を <code>F\b</code> で解くことです。</p><p>類似の、しかしピボットされた任意の対称またはエルミート行列の因子分解については、<a href="LinearAlgebra.html#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt(S);

julia&gt; b = [6., 7., 8.];

julia&gt; ldltS \ b
3-element Vector{Float64}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia&gt; S \ b
3-element Vector{Float64}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/ldlt.jl#L129-L162">source</a></section><section><div><pre><code class="language-julia hljs">ldlt(A::SparseMatrixCSC; shift = 0.0, check = true, perm=nothing) -&gt; CHOLMOD.Factor</code></pre><p>スパース行列 <code>A</code> の <span>$LDL&#39;$</span> 分解を計算します。<code>A</code> は <a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a> または <code>SparseMatrixCSC</code> の <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> ビューでなければなりません。<code>A</code> が型タグを持っていなくても、対称またはエルミートである必要があります。フィル削減置換が使用されます。<code>F = ldlt(A)</code> は、方程式系 <code>A*x = b</code> を <code>F\b</code> で解くために最も頻繁に使用されます。返される分解オブジェクト <code>F</code> は、<a href="LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a>、および <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a> メソッドもサポートしています。<code>F</code> から個々の因子を <code>F.L</code> を使用して抽出できます。ただし、ピボッティングがデフォルトでオンになっているため、分解は内部的に <code>A == P&#39;*L*D*L&#39;*P</code> として表現され、置換行列 <code>P</code> が含まれます。<code>P</code> を考慮せずに単に <code>L</code> を使用すると、誤った結果が得られます。置換の影響を含めるためには、通常、<code>PtL = F.PtL</code>（<code>P&#39;*L</code> の同等物）や <code>LtP = F.UP</code>（<code>L&#39;*P</code> の同等物）などの「結合」因子を抽出する方が好ましいです。サポートされている因子の完全なリストは <code>:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP</code> です。</p><p><code>check = true</code> の場合、分解が失敗した場合はエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）はユーザーにあります。</p><p>オプションの <code>shift</code> キーワード引数を設定すると、<code>A</code> の代わりに <code>A+shift*I</code> の分解が計算されます。<code>perm</code> 引数が提供される場合、それは <code>1:size(A,1)</code> の置換であり、使用する順序を指定します（CHOLMOD のデフォルトの AMD 順序の代わりに）。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の CHOLMOD<sup class="footnote-reference"><a id="citeref-ACM887" href="#footnote-ACM887">[ACM887]</a></sup><sup class="footnote-reference"><a id="citeref-DavisHager2009" href="#footnote-DavisHager2009">[DavisHager2009]</a></sup> ライブラリを使用しています。CHOLMOD は、単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p><p>CHOLMOD の他の多くの関数はラップされていますが、<code>Base.SparseArrays.CHOLMOD</code> モジュールからはエクスポートされていません。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1675-L1712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldlt!" href="#LinearAlgebra.ldlt!"><code>LinearAlgebra.ldlt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldlt!(S::SymTridiagonal) -&gt; LDLt</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.ldlt"><code>ldlt</code></a>と同様ですが、コピーを作成するのではなく、入力の<code>S</code>を上書きすることでスペースを節約します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt!(S);

julia&gt; ldltS === S
false

julia&gt; S
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 3.0       0.333333   ⋅
 0.333333  3.66667   0.545455
  ⋅        0.545455  3.90909</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/ldlt.jl#L92-L116">source</a></section><section><div><pre><code class="language-julia hljs">ldlt!(F::CHOLMOD.Factor, A::SparseMatrixCSC; shift = 0.0, check = true) -&gt; CHOLMOD.Factor</code></pre><p><code>A</code>の<span>$LDL&#39;$</span>因子分解を計算し、シンボリック因子分解<code>F</code>を再利用します。<code>A</code>は<a href="SparseArrays.html#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>または<code>SparseMatrixCSC</code>の<a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a>/<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a>ビューでなければなりません。<code>A</code>が型タグを持っていなくても、対称またはエルミートである必要があります。</p><p>詳細は<a href="LinearAlgebra.html#LinearAlgebra.ldlt"><code>ldlt</code></a>を参照してください。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>このメソッドは、<a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a>のCHOLMODライブラリを使用しており、これは単精度または倍精度の実数または複素数型のみをサポートしています。これらの要素型でない入力行列は、適切にこれらの型に変換されます。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/cholmod.jl#L1633-L1648">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.QR" href="#LinearAlgebra.QR"><code>LinearAlgebra.QR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QR &lt;: Factorization</code></pre><p>QR行列因子分解は、通常<a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a>から得られるパック形式で保存されます。<span>$A$</span>が<code>m</code>×<code>n</code>行列であるとき、</p><p class="math-container">\[A = Q R\]</p><p>ここで、<span>$Q$</span>は直交/ユニタリ行列であり、<span>$R$</span>は上三角行列です。行列<span>$Q$</span>は、Householder反射器<span>$v_i$</span>と係数<span>$\tau_i$</span>の列として保存されます：</p><p class="math-container">\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</p><p>分解を繰り返すことで、成分<code>Q</code>と<code>R</code>が生成されます。</p><p>オブジェクトには2つのフィールドがあります：</p><ul><li><p><code>factors</code>は<code>m</code>×<code>n</code>行列です。</p><ul><li>上三角部分には<span>$R$</span>の要素が含まれています。すなわち、<code>R = triu(F.factors)</code>は<code>QR</code>オブジェクト<code>F</code>に対して成り立ちます。</li><li>下対角部分には、パック形式で保存された反射器<span>$v_i$</span>が含まれています。ここで、<span>$v_i$</span>は行列<code>V = I + tril(F.factors, -1)</code>の<span>$i$</span>番目の列です。</li></ul></li><li><p><code>τ</code>は長さ<code>min(m,n)</code>のベクトルで、係数<span>$au_i$</span>を含みます。</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/qr.jl#L4-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.QRCompactWY" href="#LinearAlgebra.QRCompactWY"><code>LinearAlgebra.QRCompactWY</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QRCompactWY &lt;: Factorization</code></pre><p>コンパクトブロック形式で保存されたQR行列因子分解で、通常は<a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a>から得られます。<span>$A$</span>が<code>m</code>×<code>n</code>行列であるとき、</p><p class="math-container">\[A = Q R\]</p><p>ここで、<span>$Q$</span>は直交/ユニタリ行列で、<span>$R$</span>は上三角行列です。これは<a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a>形式に似ていますが、直交/ユニタリ行列<span>$Q$</span>は<em>Compact WY</em>形式で保存されています<sup class="footnote-reference"><a id="citeref-Schreiber1989" href="#footnote-Schreiber1989">[Schreiber1989]</a></sup>。ブロックサイズ<span>$n_b$</span>に対して、これは<code>m</code>×<code>n</code>の下台形行列<span>$V$</span>と、<span>$b = \lceil \min(m,n) / n_b \rceil$</span>個の上三角行列<span>$T_j$</span>（サイズ<span>$n_b$</span>×<span>$n_b$</span>、<span>$j = 1, ..., b-1$</span>）から構成される行列<span>$T = (T_1 \; T_2 \; ... \; T_{b-1} \; T_b&#39;)$</span>として保存され、上台形の<span>$n_b$</span>×<span>$\min(m,n) - (b-1) n_b$</span>行列<span>$T_b&#39;$</span>（<span>$j=b$</span>）の上の正方部分は<span>$T_b$</span>と呼ばれ、次のように満たします。</p><p class="math-container">\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T)
= \prod_{j=1}^{b} (I - V_j T_j V_j^T)\]</p><p>ここで、<span>$v_i$</span>は<span>$V$</span>の<span>$i$</span>列目、<span>$\tau_i$</span>は<code>[diag(T_1); diag(T_2); …; diag(T_b)]</code>の<span>$i$</span>要素であり、<span>$(V_1 \; V_2 \; ... \; V_b)$</span>は<span>$V$</span>の左<code>m</code>×<code>min(m, n)</code>ブロックです。<a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a>を使用して構築されると、ブロックサイズは<span>$n_b = \min(m, n, 36)$</span>で与えられます。</p><p>分解を繰り返すことで、成分<code>Q</code>と<code>R</code>が生成されます。</p><p>このオブジェクトには2つのフィールドがあります：</p><ul><li><p><code>factors</code>は、<a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a>型のように、<code>m</code>×<code>n</code>行列です。</p><ul><li>上三角部分には<span>$R$</span>の要素が含まれ、すなわち<code>R = triu(F.factors)</code>は<code>QR</code>オブジェクト<code>F</code>に対して成り立ちます。</li><li>下対角部分には、パック形式で保存された反射体<span>$v_i$</span>が含まれ、<code>V = I + tril(F.factors, -1)</code>となります。</li></ul></li><li><p><code>T</code>は、上記のように<span>$n_b$</span>×<span>$\min(m,n)$</span>行列です。各三角行列<span>$T_j$</span>の下対角要素は無視されます。</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>この形式は、古い<em>WY</em>表現<sup class="footnote-reference"><a id="citeref-Bischof1987" href="#footnote-Bischof1987">[Bischof1987]</a></sup>と混同しないでください。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/qr.jl#L59-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.QRPivoted" href="#LinearAlgebra.QRPivoted"><code>LinearAlgebra.QRPivoted</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QRPivoted &lt;: Factorization</code></pre><p>列ピボットを伴うQR行列因子分解で、通常は<a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a>から得られるパック形式です。<span>$A$</span>が<code>m</code>×<code>n</code>行列であるとき、</p><p class="math-container">\[A P = Q R\]</p><p>ここで、<span>$P$</span>は置換行列、<span>$Q$</span>は直交/ユニタリ行列、<span>$R$</span>は上三角行列です。行列<span>$Q$</span>はハウスホルダー反射器の列として保存されます：</p><p class="math-container">\[Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T).\]</p><p>分解を繰り返すことで、成分<code>Q</code>、<code>R</code>、および<code>p</code>が生成されます。</p><p>オブジェクトには3つのフィールドがあります：</p><ul><li><p><code>factors</code>は<code>m</code>×<code>n</code>行列です。</p><ul><li>上三角部分には<span>$R$</span>の要素が含まれています。すなわち、<code>R = triu(F.factors)</code>は<code>QR</code>オブジェクト<code>F</code>に対して成り立ちます。</li><li>下対角部分には、パック形式で保存された反射器<span>$v_i$</span>が含まれています。ここで<span>$v_i$</span>は行列<code>V = I + tril(F.factors, -1)</code>の<span>$i$</span>番目の列です。</li></ul></li><li><p><code>τ</code>は長さ<code>min(m,n)</code>のベクトルで、係数<span>$au_i$</span>を含みます。</p></li><li><p><code>jpvt</code>は長さ<code>n</code>の整数ベクトルで、置換<span>$P$</span>に対応します。</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/qr.jl#L169-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.qr" href="#LinearAlgebra.qr"><code>LinearAlgebra.qr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr(A::SparseMatrixCSC; tol=_default_tol(A), ordering=ORDERING_DEFAULT) -&gt; QRSparse</code></pre><p>スパース行列 <code>A</code> の <code>QR</code> 分解を計算します。フィル削減行と列の置換が使用され、<code>F.R = F.Q&#39;*A[F.prow,F.pcol]</code> となります。このタイプの主な用途は、<a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a> を使用して最小二乗または過剰決定問題を解決することです。この関数は C ライブラリ SPQR<sup class="footnote-reference"><a id="citeref-ACM933" href="#footnote-ACM933">[ACM933]</a></sup> を呼び出します。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>qr(A::SparseMatrixCSC)</code> は <a href="https://github.com/DrTimothyAldenDavis/SuiteSparse">SuiteSparse</a> の一部である SPQR ライブラリを使用します。このライブラリは <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a> または <code>ComplexF64</code> 要素を持つスパース行列のみをサポートしているため、Julia v1.4 以降、<code>qr</code> は <code>A</code> を <code>SparseMatrixCSC{Float64}</code> または <code>SparseMatrixCSC{ComplexF64}</code> 型のコピーに変換します。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1,2,3,4], [1,1,2,2], [1.0,1.0,1.0,1.0])
4×2 SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0   ⋅
 1.0   ⋅
  ⋅   1.0
  ⋅   1.0

julia&gt; qr(A)
SparseArrays.SPQR.QRSparse{Float64, Int64}
Q 因子:
4×4 SparseArrays.SPQR.QRSparseQ{Float64, Int64}
R 因子:
2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 -1.41421    ⋅
   ⋅       -1.41421
行の置換:
4-element Vector{Int64}:
 1
 3
 4
 2
列の置換:
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/spqr.jl#L151-L194">source</a></section><section><div><pre><code class="language-julia hljs">qr(A, pivot = NoPivot(); blocksize) -&gt; F</code></pre><p>行列 <code>A</code> の QR 分解を計算します：直交行列（または <code>A</code> が複素数の場合はユニタリ行列）<code>Q</code> と上三角行列 <code>R</code> で、次のようになります。</p><p class="math-container">\[A = Q R\]</p><p>返されるオブジェクト <code>F</code> は、パック形式で分解を格納します：</p><ul><li><code>pivot == ColumnNorm()</code> の場合、<code>F</code> は <a href="LinearAlgebra.html#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> オブジェクトです。</li><li>それ以外の場合、<code>A</code> の要素型が BLAS 型（<a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>、<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>、<code>ComplexF32</code> または <code>ComplexF64</code>）である場合、<code>F</code> は <a href="LinearAlgebra.html#LinearAlgebra.QRCompactWY"><code>QRCompactWY</code></a> オブジェクトです。</li><li>それ以外の場合、<code>F</code> は <a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a> オブジェクトです。</li></ul><p>分解 <code>F</code> の個々のコンポーネントはプロパティアクセサを介して取得できます：</p><ul><li><code>F.Q</code>: 直交/ユニタリ行列 <code>Q</code></li><li><code>F.R</code>: 上三角行列 <code>R</code></li><li><code>F.p</code>: ピボットの置換ベクトル（<a href="LinearAlgebra.html#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> のみ）</li><li><code>F.P</code>: ピボットの置換行列（<a href="LinearAlgebra.html#LinearAlgebra.QRPivoted"><code>QRPivoted</code></a> のみ）</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>F.R</code> を介して上三角因子に各参照を行うと、新しい配列が割り当てられます。したがって、その配列をキャッシュすることをお勧めします。たとえば、<code>R = F.R</code> として、<code>R</code> で作業を続けます。</p></div></div><p>分解を反復することで、コンポーネント <code>Q</code>、<code>R</code>、および存在する場合は <code>p</code> を生成します。</p><p><code>QR</code> オブジェクトに対しては、次の関数が利用可能です：<a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>、<a href="../base/arrays.html#Base.size"><code>size</code></a>、および <a href="../base/math.html#Base.:\\-Tuple{Any, Any}"><code>\</code></a>。<code>A</code> が長方形の場合、<code>\</code> は最小二乗解を返し、解が一意でない場合は、最小ノルムのものが返されます。<code>A</code> がフルランクでない場合、最小ノルム解を得るためには（列）ピボッティングを伴う分解が必要です。</p><p>フル/正方行列または非フル/正方行列 <code>Q</code> に関しての乗算が許可されています。つまり、<code>F.Q*F.R</code> と <code>F.Q*A</code> の両方がサポートされています。<code>Q</code> 行列は <a href="../base/arrays.html#Base.Matrix"><code>Matrix</code></a> を使用して通常の行列に変換できます。この操作は「薄い」Q 因子を返します。すなわち、<code>A</code> が <code>m</code>×<code>n</code> で <code>m&gt;=n</code> の場合、<code>Matrix(F.Q)</code> は直交正規列を持つ <code>m</code>×<code>n</code> 行列を生成します。「フル」Q 因子を取得するには、<code>F.Q*I</code> または <code>collect(F.Q)</code> を使用します。<code>m&lt;=n</code> の場合、<code>Matrix(F.Q)</code> は <code>m</code>×<code>m</code> の直交行列を生成します。</p><p>QR 分解のブロックサイズは、<code>pivot == NoPivot()</code> かつ <code>A isa StridedMatrix{&lt;:BlasFloat}</code> の場合にキーワード引数 <code>blocksize :: Integer</code> で指定できます。<code>blocksize &gt; minimum(size(A))</code> の場合は無視されます。<a href="LinearAlgebra.html#LinearAlgebra.QRCompactWY"><code>QRCompactWY</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p><code>blocksize</code> キーワード引数は Julia 1.4 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Matrix{Float64}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qr(A)
LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}
Q 因子: 3×3 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}
R 因子:
2×2 Matrix{Float64}:
 -5.0  10.0
  0.0  -1.0

julia&gt; F.Q * F.R == A
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>qr</code> は複数の型を返します。なぜなら、LAPACK はハウスホルダー基本反射の積のメモリストレージ要件を最小限に抑えるためにいくつかの表現を使用するため、<code>Q</code> と <code>R</code> 行列を2つの別々の密行列としてではなく、コンパクトに格納できるからです。</p></div></div><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/qr.jl#L343-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.qr!" href="#LinearAlgebra.qr!"><code>LinearAlgebra.qr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr!(A, pivot = NoPivot(); blocksize)</code></pre><p><code>qr!</code> は、<code>A</code> が <a href="../base/arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a> のサブタイプである場合、<a href="LinearAlgebra.html#LinearAlgebra.qr"><code>qr</code></a> と同じですが、入力 <code>A</code> を上書きすることでスペースを節約し、コピーを作成しません。因子分解が <code>A</code> の要素型で表現できない数を生成した場合、例えば整数型の場合、<a href="../base/base.html#Core.InexactError"><code>InexactError</code></a> 例外がスローされます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p><code>blocksize</code> キーワード引数は、Julia 1.4 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1. 2.; 3. 4.]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; qr!(a)
LinearAlgebra.QRCompactWY{Float64, Matrix{Float64}, Matrix{Float64}}
Q 因子: 2×2 LinearAlgebra.QRCompactWYQ{Float64, Matrix{Float64}, Matrix{Float64}}
R 因子:
2×2 Matrix{Float64}:
 -3.16228  -4.42719
  0.0      -0.632456

julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; qr!(a)
ERROR: InexactError: Int64(3.1622776601683795)
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/qr.jl#L297-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LQ" href="#LinearAlgebra.LQ"><code>LinearAlgebra.LQ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LQ &lt;: Factorization</code></pre><p>行列 <code>A</code> の <code>LQ</code> 分解の行列因子化タイプです。<code>LQ</code> 分解は、<code>transpose(A)</code> の <a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a> 分解です。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.lq"><code>lq</code></a> の戻り値の型です。</p><p><code>S::LQ</code> が因子化オブジェクトである場合、下三角成分は <code>S.L</code> を介して取得でき、直交/ユニタリ成分は <code>S.Q</code> を介して取得できるため、<code>A ≈ S.L*S.Q</code> となります。</p><p>分解を反復することで、成分 <code>S.L</code> と <code>S.Q</code> が得られます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [5. 7.; -2. -4.]
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; S = lq(A)
LQ{Float64, Matrix{Float64}, Vector{Float64}}
L 因子:
2×2 Matrix{Float64}:
 -8.60233   0.0
  4.41741  -0.697486
Q 因子: 2×2 LinearAlgebra.LQPackedQ{Float64, Matrix{Float64}, Vector{Float64}}

julia&gt; S.L * S.Q
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; l, q = S; # 反復による分解

julia&gt; l == S.L &amp;&amp;  q == S.Q
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lq.jl#L4-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lq" href="#LinearAlgebra.lq"><code>LinearAlgebra.lq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq(A) -&gt; S::LQ</code></pre><p>行列 <code>A</code> の LQ 分解を計算します。分解の下三角成分は、<a href="LinearAlgebra.html#LinearAlgebra.LQ"><code>LQ</code></a> オブジェクト <code>S</code> から <code>S.L</code> を介して取得でき、直交/ユニタリ成分は <code>S.Q</code> を介して取得できるため、<code>A ≈ S.L*S.Q</code> となります。</p><p>分解を繰り返すことで、成分 <code>S.L</code> と <code>S.Q</code> を得ることができます。</p><p>LQ 分解は <code>transpose(A)</code> の QR 分解であり、行数よりも列数が多いが行ランクが完全な方程式系に対して最小ノルム解 <code>lq(A) \ b</code> を計算するために有用です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [5. 7.; -2. -4.]
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; S = lq(A)
LQ{Float64, Matrix{Float64}, Vector{Float64}}
L 因子:
2×2 Matrix{Float64}:
 -8.60233   0.0
  4.41741  -0.697486
Q 因子: 2×2 LinearAlgebra.LQPackedQ{Float64, Matrix{Float64}, Vector{Float64}}

julia&gt; S.L * S.Q
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; l, q = S; # 繰り返しによる分解

julia&gt; l == S.L &amp;&amp;  q == S.Q
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lq.jl#L73-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lq!" href="#LinearAlgebra.lq!"><code>LinearAlgebra.lq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq!(A) -&gt; LQ</code></pre><p>行列 <code>A</code> の <a href="LinearAlgebra.html#LinearAlgebra.LQ"><code>LQ</code></a> 分解を計算します。入力行列を作業スペースとして使用します。詳細は <a href="LinearAlgebra.html#LinearAlgebra.lq"><code>lq</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lq.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BunchKaufman" href="#LinearAlgebra.BunchKaufman"><code>LinearAlgebra.BunchKaufman</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BunchKaufman &lt;: Factorization</code></pre><p>対称行列またはエルミート行列 <code>A</code> のバンチ-カウフマン因子分解の行列因子化タイプを <code>P&#39;UDU&#39;P</code> または <code>P&#39;LDL&#39;P</code> として、<code>A</code> に上三角（デフォルト）または下三角が格納されているかに応じて決定します。<code>A</code> が複素対称である場合、<code>U&#39;</code> と <code>L&#39;</code> は共役でない転置を示し、すなわちそれぞれ <code>transpose(U)</code> と <code>transpose(L)</code> です。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a> の返り値の型です。</p><p>もし <code>S::BunchKaufman</code> が因子分解オブジェクトであれば、コンポーネントは <code>S.uplo</code> と <code>S.p</code> に応じて <code>S.D</code>、<code>S.U</code> または <code>S.L</code> を介して取得できます。</p><p>分解を反復することで、<code>S.uplo</code> と <code>S.p</code> に応じて適切なコンポーネント <code>S.D</code>、<code>S.U</code> または <code>S.L</code> を生成します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Float64.([1 2; 2 3])
2×2 Matrix{Float64}:
 1.0  2.0
 2.0  3.0

julia&gt; S = bunchkaufman(A) # A は内部的に Symmetric(A) でラップされます
BunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}
D 因子:
2×2 Tridiagonal{Float64, Vector{Float64}}:
 -0.333333  0.0
  0.0       3.0
U 因子:
2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:
 1.0  0.666667
  ⋅   1.0
置換:
2-element Vector{Int64}:
 1
 2

julia&gt; d, u, p = S; # 反復による分解

julia&gt; d == S.D &amp;&amp; u == S.U &amp;&amp; p == S.p
true

julia&gt; S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}
D 因子:
2×2 Tridiagonal{Float64, Vector{Float64}}:
 3.0   0.0
 0.0  -0.333333
L 因子:
2×2 UnitLowerTriangular{Float64, Matrix{Float64}}:
 1.0        ⋅
 0.666667  1.0
置換:
2-element Vector{Int64}:
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/bunchkaufman.jl#L16-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.bunchkaufman" href="#LinearAlgebra.bunchkaufman"><code>LinearAlgebra.bunchkaufman</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bunchkaufman(A, rook::Bool=false; check = true) -&gt; S::BunchKaufman</code></pre><p>対称行列またはエルミート行列 <code>A</code> のバンチ-カウフマン <sup class="footnote-reference"><a id="citeref-Bunch1977" href="#footnote-Bunch1977">[Bunch1977]</a></sup> 分解を <code>P&#39;*U*D*U&#39;*P</code> または <code>P&#39;*L*D*L&#39;*P</code> として計算し、<code>A</code> に格納されている三角形に応じて <a href="LinearAlgebra.html#LinearAlgebra.BunchKaufman"><code>BunchKaufman</code></a> オブジェクトを返します。<code>A</code> が複素対称の場合、<code>U&#39;</code> と <code>L&#39;</code> は共役でない転置を示します。すなわち、<code>transpose(U)</code> と <code>transpose(L)</code> です。</p><p>分解を繰り返すことで、<code>S.uplo</code> に応じて適切なコンポーネント <code>S.D</code>、<code>S.U</code> または <code>S.L</code>、および <code>S.p</code> を生成します。</p><p><code>rook</code> が <code>true</code> の場合、ルークピボッティングが使用されます。<code>rook</code> が false の場合、ルークピボッティングは使用されません。</p><p><code>check = true</code> の場合、分解が失敗した場合にエラーがスローされます。<code>check = false</code> の場合、分解の有効性を確認する責任はユーザーにあります（<a href="LinearAlgebra.html#LinearAlgebra.issuccess"><code>issuccess</code></a> を介して）。</p><p><code>BunchKaufman</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/arrays.html#Base.size"><code>size</code></a>, <code>\</code>, <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.issymmetric"><code>issymmetric</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.ishermitian"><code>ishermitian</code></a>, <a href="../base/collections.html#Base.getindex"><code>getindex</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Float64.([1 2; 2 3])
2×2 Matrix{Float64}:
 1.0  2.0
 2.0  3.0

julia&gt; S = bunchkaufman(A) # A は内部で Symmetric(A) にラップされます
BunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}
D 因子:
2×2 Tridiagonal{Float64, Vector{Float64}}:
 -0.333333  0.0
  0.0       3.0
U 因子:
2×2 UnitUpperTriangular{Float64, Matrix{Float64}}:
 1.0  0.666667
  ⋅   1.0
置換:
2-element Vector{Int64}:
 1
 2

julia&gt; d, u, p = S; # 繰り返しによる分解

julia&gt; d == S.D &amp;&amp; u == S.U &amp;&amp; p == S.p
true

julia&gt; S.U*S.D*S.U&#39; - S.P*A*S.P&#39;
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0

julia&gt; S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64, Matrix{Float64}, Vector{Int64}}
D 因子:
2×2 Tridiagonal{Float64, Vector{Float64}}:
 3.0   0.0
 0.0  -0.333333
L 因子:
2×2 UnitLowerTriangular{Float64, Matrix{Float64}}:
 1.0        ⋅
 0.666667  1.0
置換:
2-element Vector{Int64}:
 2
 1

julia&gt; S.L*S.D*S.L&#39; - A[S.p, S.p]
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/bunchkaufman.jl#L130-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.bunchkaufman!" href="#LinearAlgebra.bunchkaufman!"><code>LinearAlgebra.bunchkaufman!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bunchkaufman!(A, rook::Bool=false; check = true) -&gt; BunchKaufman</code></pre><p><code>bunchkaufman!</code> は <a href="LinearAlgebra.html#LinearAlgebra.bunchkaufman"><code>bunchkaufman</code></a> と同じですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/bunchkaufman.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Eigen" href="#LinearAlgebra.Eigen"><code>LinearAlgebra.Eigen</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Eigen &lt;: Factorization</code></pre><p>行列 <code>A</code> の固有値/スペクトル分解の行列因子化タイプです。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a> の戻り値の型です。</p><p><code>F::Eigen</code> が因子化オブジェクトである場合、固有値は <code>F.values</code> を介して取得でき、固有ベクトルは行列 <code>F.vectors</code> の列として取得できます。（<code>k</code> 番目の固有ベクトルはスライス <code>F.vectors[:, k]</code> から取得できます。）</p><p>分解を反復すると、コンポーネント <code>F.values</code> と <code>F.vectors</code> が得られます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}
values:
3-element Vector{Float64}:
  1.0
  3.0
 18.0
vectors:
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; F.values
3-element Vector{Float64}:
  1.0
  3.0
 18.0

julia&gt; F.vectors
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; vals, vecs = F; # 反復による分解

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L4-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.GeneralizedEigen" href="#LinearAlgebra.GeneralizedEigen"><code>LinearAlgebra.GeneralizedEigen</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedEigen &lt;: Factorization</code></pre><p>行列 <code>A</code> と <code>B</code> の一般化固有値/スペクトル分解の行列因子化タイプです。これは、2つの行列引数で呼び出されたときの対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a> の戻り値の型です。</p><p><code>F::GeneralizedEigen</code> が因子化オブジェクトである場合、固有値は <code>F.values</code> を介して取得でき、固有ベクトルは行列 <code>F.vectors</code> の列として取得できます。（<code>k</code> 番目の固有ベクトルはスライス <code>F.vectors[:, k]</code> から取得できます。）</p><p>分解を反復すると、コンポーネント <code>F.values</code> と <code>F.vectors</code> が生成されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 0; 0 -1]
2×2 Matrix{Int64}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Matrix{Int64}:
 0  1
 1  0

julia&gt; F = eigen(A, B)
GeneralizedEigen{ComplexF64, ComplexF64, Matrix{ComplexF64}, Vector{ComplexF64}}
values:
2-element Vector{ComplexF64}:
 0.0 - 1.0im
 0.0 + 1.0im
vectors:
2×2 Matrix{ComplexF64}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia&gt; F.values
2-element Vector{ComplexF64}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; F.vectors
2×2 Matrix{ComplexF64}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L60-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigvals" href="#LinearAlgebra.eigvals"><code>LinearAlgebra.eigvals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigvals(A; permute::Bool=true, scale::Bool=true, sortby) -&gt; values</code></pre><p>行列 <code>A</code> の固有値を返します。</p><p>一般的な非対称行列に対しては、固有値計算の前に行列がどのようにバランスされるかを指定することが可能です。<code>permute</code>、<code>scale</code>、および <code>sortby</code> キーワードは <a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a> と同じです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; diag_matrix = [1 0; 0 4]
2×2 Matrix{Int64}:
 1  0
 0  4

julia&gt; eigvals(diag_matrix)
2-element Vector{Float64}:
 1.0
 4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L321-L342">source</a></section><section><div><p>スカラー入力の場合、<code>eigvals</code> はスカラーを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eigvals(-2)
-2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L346-L354">source</a></section><section><div><pre><code class="language-julia hljs">eigvals(A, B) -&gt; values</code></pre><p>行列 <code>A</code> と <code>B</code> の一般化固有値を計算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 0; 0 -1]
2×2 Matrix{Int64}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Matrix{Int64}:
 0  1
 1  0

julia&gt; eigvals(A,B)
2-element Vector{ComplexF64}:
 0.0 - 1.0im
 0.0 + 1.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L599-L621">source</a></section><section><div><pre><code class="language-julia hljs">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p><code>A</code>の固有値を返します。ソートされた固有値のインデックスをカバーする<a href="../base/collections.html#Base.UnitRange"><code>UnitRange</code></a> <code>irange</code>を指定することで、固有値のサブセットのみを計算することが可能です。例えば、2番目から8番目の固有値などです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, 2:2)
1-element Vector{Float64}:
 0.9999999999999996

julia&gt; eigvals(A)
3-element Vector{Float64}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetriceigen.jl#L86-L111">source</a></section><section><div><pre><code class="language-julia hljs">eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p><code>A</code>の固有値を返します。固有値の下限と上限を指定することで、固有値のサブセットのみを計算することが可能です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, -1, 2)
1-element Vector{Float64}:
 1.0000000000000009

julia&gt; eigvals(A)
3-element Vector{Float64}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetriceigen.jl#L126-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigvals!" href="#LinearAlgebra.eigvals!"><code>LinearAlgebra.eigvals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigvals!(A; permute::Bool=true, scale::Bool=true, sortby) -&gt; values</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.eigvals"><code>eigvals</code></a> と同じですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。<code>permute</code>、<code>scale</code>、および <code>sortby</code> キーワードは <a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a> と同じです。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>eigvals!</code> が呼び出されると、入力行列 <code>A</code> にはその固有値が含まれなくなります - <code>A</code> は作業スペースとして使用されます。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 2.; 3. 4.]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; eigvals!(A)
2-element Vector{Float64}:
 -0.3722813232690143
  5.372281323269014

julia&gt; A
2×2 Matrix{Float64}:
 -0.372281  -1.0
  0.0        5.37228</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L280-L307">source</a></section><section><div><pre><code class="language-julia hljs">eigvals!(A, B; sortby) -&gt; values</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.eigvals"><code>eigvals</code></a>と同様ですが、コピーを作成する代わりに入力の<code>A</code>（および<code>B</code>）を上書きすることでスペースを節約します。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>eigvals!</code>が呼び出された後、入力行列<code>A</code>と<code>B</code>はその固有値を含まなくなります。これらは作業スペースとして使用されます。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 0.; 0. -1.]
2×2 Matrix{Float64}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Matrix{Float64}:
 0.0  1.0
 1.0  0.0

julia&gt; eigvals!(A, B)
2-element Vector{ComplexF64}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; A
2×2 Matrix{Float64}:
 -0.0  -1.0
  1.0  -0.0

julia&gt; B
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L542-L579">source</a></section><section><div><pre><code class="language-julia hljs">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.eigvals"><code>eigvals</code></a> と同様ですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。<code>irange</code> は検索する固有値の <em>インデックス</em> の範囲です - 例えば、2番目から8番目の固有値です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetriceigen.jl#L77-L82">source</a></section><section><div><pre><code class="language-julia hljs">eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.eigvals"><code>eigvals</code></a> と同様ですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。<code>vl</code> は固有値を検索するための区間の下限で、<code>vu</code> は上限です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetriceigen.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigmax" href="#LinearAlgebra.eigmax"><code>LinearAlgebra.eigmax</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigmax(A; permute::Bool=true, scale::Bool=true)</code></pre><p>行列 <code>A</code> の最大固有値を返します。オプション <code>permute=true</code> は行列を上三角行列に近づけるために行列を置換し、<code>scale=true</code> は行列の対角要素でスケーリングして行と列のノルムをより等しくします。注意すべきは、<code>A</code> の固有値が複素数の場合、この方法は失敗します。なぜなら、複素数はソートできないからです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [0 im; -im 0]
2×2 Matrix{Complex{Int64}}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmax(A)
1.0

julia&gt; A = [0 im; -1 0]
2×2 Matrix{Complex{Int64}}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` は複素固有値を持つことができません。
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L357-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigmin" href="#LinearAlgebra.eigmin"><code>LinearAlgebra.eigmin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigmin(A; permute::Bool=true, scale::Bool=true)</code></pre><p>行列 <code>A</code> の最小固有値を返します。オプション <code>permute=true</code> は行列を上三角行列に近づけるために行列を置換し、<code>scale=true</code> は行列の対角要素によって行と列のノルムをより等しくするために行列をスケーリングします。注意すべきは、<code>A</code> の固有値が複素数である場合、この方法は失敗することです。なぜなら、複素数はソートできないからです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [0 im; -im 0]
2×2 Matrix{Complex{Int64}}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmin(A)
-1.0

julia&gt; A = [0 im; -1 0]
2×2 Matrix{Complex{Int64}}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` は複素固有値を持つことができません。
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L398-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigvecs" href="#LinearAlgebra.eigvecs"><code>LinearAlgebra.eigvecs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigvecs(A::SymTridiagonal[, eigvals]) -&gt; Matrix</code></pre><p>行列 <code>M</code> を返し、その列は <code>A</code> の固有ベクトルです。 (<code>k</code> 番目の固有ベクトルはスライス <code>M[:, k]</code> から取得できます。)</p><p>オプションの固有値ベクトル <code>eigvals</code> が指定されている場合、<code>eigvecs</code> は対応する特定の固有ベクトルを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64, Vector{Float64}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A)
3-element Vector{Float64}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia&gt; eigvecs(A)
3×3 Matrix{Float64}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia&gt; eigvecs(A, [1.])
3×1 Matrix{Float64}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/tridiag.jl#L290-L325">source</a></section><section><div><pre><code class="language-julia hljs">eigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -&gt; Matrix</code></pre><p>行列 <code>A</code> の固有ベクトルからなる行列 <code>M</code> を返します。(<code>k</code> 番目の固有ベクトルはスライス <code>M[:, k]</code> から取得できます。) <code>permute</code>、<code>scale</code>、および <code>sortby</code> キーワードは <a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a> と同じです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L258-L273">source</a></section><section><div><pre><code class="language-julia hljs">eigvecs(A, B) -&gt; Matrix</code></pre><p>行列 <code>M</code> を返します。<code>M</code> の列は <code>A</code> と <code>B</code> の一般化固有ベクトルです。<code>k</code> 番目の固有ベクトルはスライス <code>M[:, k]</code> から取得できます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 0; 0 -1]
2×2 Matrix{Int64}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Matrix{Int64}:
 0  1
 1  0

julia&gt; eigvecs(A, B)
2×2 Matrix{ComplexF64}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L627-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigen" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigen(A; permute::Bool=true, scale::Bool=true, sortby) -&gt; Eigen</code></pre><p>行列 <code>A</code> の固有値分解を計算し、固有値を <code>F.values</code> に、固有ベクトルを行列 <code>F.vectors</code> の列に含む <a href="LinearAlgebra.html#LinearAlgebra.Eigen"><code>Eigen</code></a> 因子化オブジェクト <code>F</code> を返します。これは、<code>Ax =  λx</code> の形の固有値問題を解くことに対応し、ここで <code>A</code> は行列、<code>x</code> は固有ベクトル、<code>λ</code> は固有値です。(<code>k</code> 番目の固有ベクトルはスライス <code>F.vectors[:, k]</code> から取得できます。)</p><p>分解を反復することで、成分 <code>F.values</code> と <code>F.vectors</code> を得ることができます。</p><p><code>Eigen</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, および <a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a>。</p><p>一般的な非対称行列に対しては、固有ベクトル計算の前に行列がどのようにバランスされるかを指定することが可能です。オプション <code>permute=true</code> は行列を上三角行列に近づけるように並べ替え、<code>scale=true</code> は行列を対角要素でスケーリングして行と列のノルムをより等しくします。デフォルトは両方のオプションが <code>true</code> です。</p><p>デフォルトでは、固有値とベクトルは <code>(real(λ),imag(λ))</code> によって辞書式にソートされます。異なる比較関数 <code>by(λ)</code> を <code>sortby</code> に渡すことができ、または <code>sortby=nothing</code> を渡して固有値を任意の順序のままにすることもできます。一部の特別な行列タイプ（例: <a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a> や <a href="LinearAlgebra.html#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a>）は独自のソート規則を実装しており、<code>sortby</code> キーワードを受け付けない場合があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}
values:
3-element Vector{Float64}:
  1.0
  3.0
 18.0
vectors:
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; F.values
3-element Vector{Float64}:
  1.0
  3.0
 18.0

julia&gt; F.vectors
3×3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; vals, vecs = F; # 反復による分解

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L181-L237">source</a></section><section><div><pre><code class="language-julia hljs">eigen(A, B; sortby) -&gt; GeneralizedEigen</code></pre><p>行列 <code>A</code> と <code>B</code> の一般化固有値分解を計算し、一般化固有値を <code>F.values</code> に、一般化固有ベクトルを行列 <code>F.vectors</code> の列に含む <a href="LinearAlgebra.html#LinearAlgebra.GeneralizedEigen"><code>GeneralizedEigen</code></a> 因子化オブジェクト <code>F</code> を返します。これは、一般化固有値問題 <code>Ax =  λBx</code> を解くことに対応し、ここで <code>A, B</code> は行列、<code>x</code> は固有ベクトル、<code>λ</code> は固有値です。 (<code>k</code> 番目の一般化固有ベクトルはスライス <code>F.vectors[:, k]</code> から取得できます。)</p><p>分解を反復することで、成分 <code>F.values</code> と <code>F.vectors</code> を得ることができます。</p><p>デフォルトでは、固有値とベクトルは <code>(real(λ),imag(λ))</code> によって辞書式にソートされます。異なる比較関数 <code>by(λ)</code> を <code>sortby</code> に渡すことができ、または <code>sortby=nothing</code> を渡して固有値を任意の順序のままにすることもできます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 0; 0 -1]
2×2 Matrix{Int64}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Matrix{Int64}:
 0  1
 1  0

julia&gt; F = eigen(A, B);

julia&gt; F.values
2-element Vector{ComplexF64}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; F.vectors
2×2 Matrix{ComplexF64}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia&gt; vals, vecs = F; # 反復による分解

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L481-L526">source</a></section><section><div><pre><code class="language-julia hljs">eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; Eigen</code></pre><p>行列 <code>A</code> の固有値分解を計算し、固有値を <code>F.values</code> に、固有ベクトルを行列 <code>F.vectors</code> の列に含む <a href="LinearAlgebra.html#LinearAlgebra.Eigen"><code>Eigen</code></a> 因子化オブジェクト <code>F</code> を返します。（<code>k</code> 番目の固有ベクトルはスライス <code>F.vectors[:, k]</code> から取得できます。）</p><p>分解を反復すると、コンポーネント <code>F.values</code> と <code>F.vectors</code> が得られます。</p><p><code>Eigen</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, および <a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a>。</p><p><a href="../base/collections.html#Base.UnitRange"><code>UnitRange</code></a> <code>irange</code> は、検索するソートされた固有値のインデックスを指定します。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>irange</code> が <code>1:n</code> でない場合、ここで <code>n</code> は <code>A</code> の次元であるため、返される因子化は <em>切り捨てられた</em> 因子化になります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetriceigen.jl#L19-L35">source</a></section><section><div><pre><code class="language-julia hljs">eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; Eigen</code></pre><p>行列 <code>A</code> の固有値分解を計算し、固有値を <code>F.values</code> に、固有ベクトルを行列 <code>F.vectors</code> の列に含む <a href="LinearAlgebra.html#LinearAlgebra.Eigen"><code>Eigen</code></a> 因子化オブジェクト <code>F</code> を返します。（<code>k</code> 番目の固有ベクトルはスライス <code>F.vectors[:, k]</code> から取得できます。）</p><p>分解を反復することで、コンポーネント <code>F.values</code> と <code>F.vectors</code> を得ることができます。</p><p><code>Eigen</code> オブジェクトに対して利用可能な関数は次のとおりです: <a href="../base/math.html#Base.inv-Tuple{Number}"><code>inv</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.det"><code>det</code></a>, および <a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a>。</p><p><code>vl</code> は検索する固有値のウィンドウの下限であり、<code>vu</code> は上限です。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>[<code>vl</code>, <code>vu</code>] が <code>A</code> のすべての固有値を含まない場合、返される因子化は <em>切り捨てられた</em> 因子化になります。</p></div></div><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetriceigen.jl#L44-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.eigen!" href="#LinearAlgebra.eigen!"><code>LinearAlgebra.eigen!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigen!(A; permute, scale, sortby)
eigen!(A, B; sortby)</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a> と同様ですが、コピーを作成するのではなく、入力 <code>A</code>（および <code>B</code>）を上書きすることでスペースを節約します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/eigen.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Hessenberg" href="#LinearAlgebra.Hessenberg"><code>LinearAlgebra.Hessenberg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hessenberg &lt;: 因数分解</code></pre><p><code>Hessenberg</code>オブジェクトは、正方行列のヘッセンベルグ因数分解<code>QHQ&#39;</code>、またはそのシフト<code>Q(H+μI)Q&#39;</code>を表し、これは<a href="LinearAlgebra.html#LinearAlgebra.hessenberg"><code>hessenberg</code></a>関数によって生成されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/hessenberg.jl#L374-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.hessenberg" href="#LinearAlgebra.hessenberg"><code>LinearAlgebra.hessenberg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hessenberg(A) -&gt; Hessenberg</code></pre><p>行列 <code>A</code> のヘッセンベルグ分解を計算し、<code>Hessenberg</code> オブジェクトを返します。<code>F</code> が因子化オブジェクトである場合、ユニタリ行列には <code>F.Q</code>（型 <code>LinearAlgebra.HessenbergQ</code>）でアクセスでき、ヘッセンベルグ行列には <code>F.H</code>（型 <a href="LinearAlgebra.html#LinearAlgebra.UpperHessenberg"><code>UpperHessenberg</code></a>）でアクセスできます。どちらも <code>Matrix(F.H)</code> または <code>Matrix(F.Q)</code> を使用して通常の行列に変換できます。</p><p><code>A</code> が <a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> または実 <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a> である場合、ヘッセンベルグ分解は実対称トリディアゴナル行列を生成し、<code>F.H</code> は型 <a href="LinearAlgebra.html#LinearAlgebra.SymTridiagonal"><code>SymTridiagonal</code></a> になります。</p><p>シフト因子化 <code>A+μI = Q (H+μI) Q&#39;</code> は、<a href="LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a> オブジェクト <a href="LinearAlgebra.html#LinearAlgebra.I"><code>I</code></a> を使用して <code>F + μ*I</code> によって効率的に構築できます。これにより、共有ストレージと修正されたシフトを持つ新しい <code>Hessenberg</code> オブジェクトが作成されます。与えられた <code>F</code> のシフトは <code>F.μ</code> によって取得されます。これは、<code>F</code> が作成された後に、異なる <code>μ</code> および/または <code>b</code> に対して複数のシフト解 <code>(F + μ*I) \ b</code> を効率的に実行できるため便利です。</p><p>分解を反復することで、因子 <code>F.Q, F.H, F.μ</code> が得られます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Matrix{Float64}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; F = hessenberg(A)
Hessenberg{Float64, UpperHessenberg{Float64, Matrix{Float64}}, Matrix{Float64}, Vector{Float64}, Bool}
Q factor: 3×3 LinearAlgebra.HessenbergQ{Float64, Matrix{Float64}, Vector{Float64}, false}
H factor:
3×3 UpperHessenberg{Float64, Matrix{Float64}}:
  4.0      -11.3137       -1.41421
 -5.65685    5.0           2.0
   ⋅        -8.88178e-16   1.0

julia&gt; F.Q * F.H * F.Q&#39;
3×3 Matrix{Float64}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; q, h = F; # 反復による分解

julia&gt; q == F.Q &amp;&amp; h == F.H
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/hessenberg.jl#L422-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.hessenberg!" href="#LinearAlgebra.hessenberg!"><code>LinearAlgebra.hessenberg!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hessenberg!(A) -&gt; ヘッセンベルグ</code></pre><p><code>hessenberg!</code> は <a href="LinearAlgebra.html#LinearAlgebra.hessenberg"><code>hessenberg</code></a> と同じですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/hessenberg.jl#L414-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Schur" href="#LinearAlgebra.Schur"><code>LinearAlgebra.Schur</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Schur &lt;: Factorization</code></pre><p>行列 <code>A</code> のシュール分解の行列因子化タイプです。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.schur"><code>schur(_)</code></a> の戻り値の型です。</p><p><code>F::Schur</code> が因子化オブジェクトである場合、（準）三角シュール因子は <code>F.Schur</code> または <code>F.T</code> を介して取得でき、直交/ユニタリシュールベクトルは <code>F.vectors</code> または <code>F.Z</code> を介して取得できるため、<code>A = F.vectors * F.Schur * F.vectors&#39;</code> となります。行列 <code>A</code> の固有値は <code>F.values</code> で取得できます。</p><p>分解を反復することで、成分 <code>F.T</code>、<code>F.Z</code>、および <code>F.values</code> が得られます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [5. 7.; -2. -4.]
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur(A)
Schur{Float64, Matrix{Float64}, Vector{Float64}}
T因子:
2×2 Matrix{Float64}:
 3.0   9.0
 0.0  -2.0
Z因子:
2×2 Matrix{Float64}:
  0.961524  0.274721
 -0.274721  0.961524
固有値:
2要素 Vector{Float64}:
  3.0
 -2.0

julia&gt; F.vectors * F.Schur * F.vectors&#39;
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; t, z, vals = F; # 反復による分解

julia&gt; t == F.T &amp;&amp; z == F.Z &amp;&amp; vals == F.values
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L4-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.GeneralizedSchur" href="#LinearAlgebra.GeneralizedSchur"><code>LinearAlgebra.GeneralizedSchur</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedSchur &lt;: Factorization</code></pre><p>2つの行列 <code>A</code> と <code>B</code> の一般化シュール因子分解の行列因子化タイプです。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.schur"><code>schur(_, _)</code></a> の返り値の型です。</p><p><code>F::GeneralizedSchur</code> が因子分解オブジェクトである場合、(準)三角シュール因子は <code>F.S</code> と <code>F.T</code> を介して取得でき、左ユニタリ/直交シュールベクトルは <code>F.left</code> または <code>F.Q</code> を介して、右ユニタリ/直交シュールベクトルは <code>F.right</code> または <code>F.Z</code> を介して取得でき、次のようになります： <code>A=F.left*F.S*F.right&#39;</code> および <code>B=F.left*F.T*F.right&#39;</code>。行列 <code>A</code> と <code>B</code> の一般化固有値は <code>F.α./F.β</code> を使用して取得できます。</p><p>分解を反復すると、コンポーネント <code>F.S</code>、<code>F.T</code>、<code>F.Q</code>、<code>F.Z</code>、<code>F.α</code>、および <code>F.β</code> が生成されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L293-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.schur" href="#LinearAlgebra.schur"><code>LinearAlgebra.schur</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur(A) -&gt; F::Schur</code></pre><p>行列 <code>A</code> のシュール分解を計算します。 (準)三角シュール因子は、<code>F</code> という <code>Schur</code> オブジェクトから <code>F.Schur</code> または <code>F.T</code> を使って取得でき、直交/ユニタリシュールベクトルは <code>F.vectors</code> または <code>F.Z</code> を使って取得できるため、<code>A = F.vectors * F.Schur * F.vectors&#39;</code> となります。行列 <code>A</code> の固有値は <code>F.values</code> で取得できます。</p><p>実数の <code>A</code> に対して、シュール分解は「準三角形」であり、これは複素固有値の共役対に対して 2×2 の対角ブロックを持つ上三角行列であることを意味します。これにより、複素固有値が存在しても分解が純粋に実数であることが可能です。実数の準三角分解から (複素) 純上三角シュール分解を取得するには、<code>Schur{Complex}(schur(A))</code> を使用できます。</p><p>分解を繰り返すことで、コンポーネント <code>F.T</code>、<code>F.Z</code>、および <code>F.values</code> を得ることができます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [5. 7.; -2. -4.]
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur(A)
Schur{Float64, Matrix{Float64}, Vector{Float64}}
T 因子:
2×2 Matrix{Float64}:
 3.0   9.0
 0.0  -2.0
Z 因子:
2×2 Matrix{Float64}:
  0.961524  0.274721
 -0.274721  0.961524
固有値:
2-element Vector{Float64}:
  3.0
 -2.0

julia&gt; F.vectors * F.Schur * F.vectors&#39;
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; t, z, vals = F; # 繰り返しによる分解

julia&gt; t == F.T &amp;&amp; z == F.Z &amp;&amp; vals == F.values
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L107-L156">source</a></section><section><div><pre><code class="language-julia hljs">schur(A, B) -&gt; F::GeneralizedSchur</code></pre><p>行列 <code>A</code> と <code>B</code> の一般化シュール（または QZ）因子分解を計算します。(準)三角シュール因子は、<code>F</code> という <code>Schur</code> オブジェクトから <code>F.S</code> と <code>F.T</code> を使って取得でき、左ユニタリ/直交シュールベクトルは <code>F.left</code> または <code>F.Q</code> で取得でき、右ユニタリ/直交シュールベクトルは <code>F.right</code> または <code>F.Z</code> で取得できるため、<code>A=F.left*F.S*F.right&#39;</code> および <code>B=F.left*F.T*F.right&#39;</code> となります。<code>A</code> と <code>B</code> の一般化固有値は <code>F.α./F.β</code> で取得できます。</p><p>分解を繰り返すことで、成分 <code>F.S</code>、<code>F.T</code>、<code>F.Q</code>、<code>F.Z</code>、<code>F.α</code>、および <code>F.β</code> が得られます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L356-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.schur!" href="#LinearAlgebra.schur!"><code>LinearAlgebra.schur!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur!(A) -&gt; F::Schur</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.schur"><code>schur</code></a> と同様ですが、入力引数 <code>A</code> を作業領域として使用します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [5. 7.; -2. -4.]
2×2 Matrix{Float64}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur!(A)
Schur{Float64, Matrix{Float64}, Vector{Float64}}
T 因子:
2×2 Matrix{Float64}:
 3.0   9.0
 0.0  -2.0
Z 因子:
2×2 Matrix{Float64}:
  0.961524  0.274721
 -0.274721  0.961524
固有値:
2要素 Vector{Float64}:
  3.0
 -2.0

julia&gt; A
2×2 Matrix{Float64}:
 3.0   9.0
 0.0  -2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L70-L102">source</a></section><section><div><pre><code class="language-julia hljs">schur!(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.schur"><code>schur</code></a> と同様ですが、入力行列 <code>A</code> と <code>B</code> を作業領域として使用します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ordschur" href="#LinearAlgebra.ordschur"><code>LinearAlgebra.ordschur</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p>行列 <code>A = Z*T*Z&#39;</code> のシュール分解 <code>F</code> を論理配列 <code>select</code> に従って再配置し、再配置された分解 <code>F</code> オブジェクトを返します。選択された固有値は <code>F.Schur</code> の主対角線に現れ、対応する <code>F.vectors</code> の主列は対応する右不変部分空間の直交/ユニタリ基底を形成します。実数の場合、複素共役の固有値の対は、<code>select</code> を介して両方とも含めるか、両方とも除外する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L280-L289">source</a></section><section><div><pre><code class="language-julia hljs">ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p>行列ペア <code>(A, B) = (Q*S*Z&#39;, Q*T*Z&#39;)</code> の一般化シュア分解 <code>F</code> を論理配列 <code>select</code> に従って再配置し、一般化シュアオブジェクト <code>F</code> を返します。選択された固有値は、<code>F.S</code> と <code>F.T</code> の両方の主対角線に現れ、左および右の直交/ユニタリシュアベクトルも再配置されるため、<code>(A, B) = F.Q*(F.S, F.T)*F.Z&#39;</code> が依然として成り立ち、<code>A</code> と <code>B</code> の一般化固有値は <code>F.α./F.β</code> で依然として取得できます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L394-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ordschur!" href="#LinearAlgebra.ordschur!"><code>LinearAlgebra.ordschur!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur</code></pre><p><a href="LinearAlgebra.html#LinearAlgebra.ordschur"><code>ordschur</code></a> と同様ですが、因子分解 <code>F</code> を上書きします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L263-L267">source</a></section><section><div><pre><code class="language-julia hljs">ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur</code></pre><p><code>ordschur</code>と同様ですが、因子分解<code>F</code>を上書きします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/schur.jl#L374-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.SVD" href="#LinearAlgebra.SVD"><code>LinearAlgebra.SVD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SVD &lt;: Factorization</code></pre><p>行列 <code>A</code> の特異値分解 (SVD) の行列因子化タイプです。これは、対応する行列因子化関数 <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd(_)</code></a> の戻り値の型です。</p><p><code>F::SVD</code> が因子化オブジェクトである場合、<code>U</code>、<code>S</code>、<code>V</code> および <code>Vt</code> は <code>F.U</code>、<code>F.S</code>、<code>F.V</code> および <code>F.Vt</code> を介して取得でき、<code>A = U * Diagonal(S) * Vt</code> となります。<code>S</code> の特異値は降順にソートされています。</p><p>分解を反復することで、成分 <code>U</code>、<code>S</code>、および <code>V</code> を得ることができます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Matrix{Float64}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svd(A)
SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}
U factor:
4×4 Matrix{Float64}:
 0.0  1.0   0.0  0.0
 1.0  0.0   0.0  0.0
 0.0  0.0   0.0  1.0
 0.0  0.0  -1.0  0.0
singular values:
4-element Vector{Float64}:
 3.0
 2.23606797749979
 2.0
 0.0
Vt factor:
4×5 Matrix{Float64}:
 -0.0        0.0  1.0  -0.0  0.0
  0.447214   0.0  0.0   0.0  0.894427
  0.0       -1.0  0.0   0.0  0.0
  0.0        0.0  0.0   1.0  0.0

julia&gt; F.U * Diagonal(F.S) * F.Vt
4×5 Matrix{Float64}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; u, s, v = F; # 反復による分解

julia&gt; u == F.U &amp;&amp; s == F.S &amp;&amp; v == F.V
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L4-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.GeneralizedSVD" href="#LinearAlgebra.GeneralizedSVD"><code>LinearAlgebra.GeneralizedSVD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneralizedSVD &lt;: Factorization</code></pre><p>2つの行列 <code>A</code> と <code>B</code> の一般化特異値分解 (SVD) の行列因子化タイプであり、<code>A = F.U*F.D1*F.R0*F.Q&#39;</code> および <code>B = F.V*F.D2*F.R0*F.Q&#39;</code> となります。これは <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd(_, _)</code></a> の戻り値の型であり、対応する行列因子化関数です。</p><p>M×N 行列 <code>A</code> と P×N 行列 <code>B</code> に対して、</p><ul><li><code>U</code> は M×M の直交行列です。</li><li><code>V</code> は P×P の直交行列です。</li><li><code>Q</code> は N×N の直交行列です。</li><li><code>D1</code> は最初の K エントリに 1 がある M×(K+L) の対角行列です。</li><li><code>D2</code> は上部右の L×L ブロックが対角である P×(K+L) の行列です。</li><li><code>R0</code> は最も右の (K+L)×(K+L) ブロックが非特異上三角である (K+L)×N の行列です。</li></ul><p><code>K+L</code> は行列 <code>[A; B]</code> の有効数値ランクです。</p><p>分解を繰り返すことで、成分 <code>U</code>、<code>V</code>、<code>Q</code>、<code>D1</code>、<code>D2</code>、および <code>R0</code> が生成されます。</p><p><code>F.D1</code> と <code>F.D2</code> のエントリは関連しており、<a href="https://www.netlib.org/lapack/lug/node36.html">一般化 SVD</a> の LAPACK ドキュメントおよびその下で呼び出される <a href="https://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html">xGGSVD3</a> ルーチンで説明されています (LAPACK 3.6.0 以降)。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 0.; 0. -1.]
2×2 Matrix{Float64}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Matrix{Float64}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svd(A, B)
GeneralizedSVD{Float64, Matrix{Float64}, Float64, Vector{Float64}}
U factor:
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0
V factor:
2×2 Matrix{Float64}:
 -0.0  -1.0
  1.0   0.0
Q factor:
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0
D1 factor:
2×2 Matrix{Float64}:
 0.707107  0.0
 0.0       0.707107
D2 factor:
2×2 Matrix{Float64}:
 0.707107  0.0
 0.0       0.707107
R0 factor:
2×2 Matrix{Float64}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; F.U*F.D1*F.R0*F.Q&#39;
2×2 Matrix{Float64}:
 1.0   0.0
 0.0  -1.0

julia&gt; F.V*F.D2*F.R0*F.Q&#39;
2×2 Matrix{Float64}:
 -0.0  1.0
  1.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L281-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.svd" href="#LinearAlgebra.svd"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -&gt; SVD</code></pre><p>行列 <code>A</code> の特異値分解 (SVD) を計算し、<code>SVD</code> オブジェクトを返します。</p><p>因子分解 <code>F</code> から <code>U</code>、<code>S</code>、<code>V</code> および <code>Vt</code> を取得することができ、<code>F.U</code>、<code>F.S</code>、<code>F.V</code> および <code>F.Vt</code> を使用します。これにより、<code>A = U * Diagonal(S) * Vt</code> となります。アルゴリズムは <code>Vt</code> を生成するため、<code>Vt</code> を抽出する方が <code>V</code> よりも効率的です。<code>S</code> の特異値は降順にソートされています。</p><p>分解を繰り返すことで、成分 <code>U</code>、<code>S</code>、および <code>V</code> を得ることができます。</p><p><code>full = false</code>（デフォルト）の場合、&quot;薄い&quot; SVD が返されます。<span>$M \times N$</span> 行列 <code>A</code> の場合、完全な因子分解では <code>U</code> は <span>$M \times M$</span> であり、<code>V</code> は <span>$N \times N$</span> ですが、薄い因子分解では <code>U</code> は <span>$M \times K$</span> であり、<code>V</code> は <span>$N \times K$</span> です。ここで、<span>$K = \min(M,N)$</span> は特異値の数です。</p><p><code>alg = DivideAndConquer()</code> の場合、分割統治アルゴリズムが SVD の計算に使用されます。別の（通常は遅いがより正確な）オプションは <code>alg = QRIteration()</code> です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p><code>alg</code> キーワード引数は Julia 1.3 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(4,3);

julia&gt; F = svd(A); # 因子分解オブジェクトを保存

julia&gt; A ≈ F.U * Diagonal(F.S) * F.Vt
true

julia&gt; U, S, V = F; # 繰り返しによる分解

julia&gt; A ≈ U * Diagonal(S) * V&#39;
true

julia&gt; Uonly, = svd(A); # U のみを保存

julia&gt; Uonly == U
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L134-L177">source</a></section><section><div><pre><code class="language-julia hljs">svd(A, B) -&gt; GeneralizedSVD</code></pre><p><code>A</code> と <code>B</code> の一般化 SVD を計算し、<code>[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q&#39;</code> となる <code>GeneralizedSVD</code> 因子化オブジェクト <code>F</code> を返します。</p><ul><li><code>U</code> は M-by-M の直交行列です。</li><li><code>V</code> は P-by-P の直交行列です。</li><li><code>Q</code> は N-by-N の直交行列です。</li><li><code>D1</code> は最初の K エントリに 1 が入った M-by-(K+L) の対角行列です。</li><li><code>D2</code> は右上の L-by-L ブロックが対角行列である P-by-(K+L) の行列です。</li><li><code>R0</code> は右端の (K+L)-by-(K+L) ブロックが非特異上三角行列である (K+L)-by-N の行列です。</li></ul><p><code>K+L</code> は行列 <code>[A; B]</code> の有効な数値ランクです。</p><p>分解を繰り返すことで、成分 <code>U</code>、<code>V</code>、<code>Q</code>、<code>D1</code>、<code>D2</code>、および <code>R0</code> が得られます。</p><p>一般化 SVD は、<code>A</code> にどれだけ属するかと <code>B</code> にどれだけ属するかを比較したい場合、例えば人間と酵母のゲノム、信号とノイズ、またはクラスタ間とクラスタ内の比較などのアプリケーションで使用されます。（議論については Edelman と Wang を参照してください: https://arxiv.org/abs/1901.00485）</p><p>これは <code>[A; B]</code> を <code>[UC; VS]H</code> に分解し、<code>[UC; VS]</code> は <code>[A; B]</code> の列空間の自然な直交基底であり、<code>H = RQ&#39;</code> は <code>[A;B]</code> の行空間の自然な非直交基底です。上部の行は <code>A</code> 行列に最も密接に帰属し、下部は <code>B</code> 行列に帰属します。多重コサイン/サイン行列 <code>C</code> と <code>S</code> は、<code>A</code> と <code>B</code> のどれだけの割合を測定するかの多重測定を提供し、<code>U</code> と <code>V</code> はこれらが測定される方向を提供します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = randn(3,2); B=randn(4,2);

julia&gt; F = svd(A, B);

julia&gt; U,V,Q,C,S,R = F;

julia&gt; H = R*Q&#39;;

julia&gt; [A; B] ≈ [U*C; V*S]*H
true

julia&gt; [A; B] ≈ [F.U*F.D1; F.V*F.D2]*F.R0*F.Q&#39;
true

julia&gt; Uonly, = svd(A,B);

julia&gt; U == Uonly
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L407-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.svd!" href="#LinearAlgebra.svd!"><code>LinearAlgebra.svd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -&gt; SVD</code></pre><p><code>svd!</code> は <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a> と同じですが、コピーを作成するのではなく、入力 <code>A</code> を上書きすることでスペースを節約します。詳細については <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a> のドキュメントを参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L94-L99">source</a></section><section><div><pre><code class="language-julia hljs">svd!(A, B) -&gt; GeneralizedSVD</code></pre><p><code>svd!</code>は<a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a>と同じですが、引数<code>A</code>と<code>B</code>をインプレースで変更し、コピーを作成しません。詳細については<a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a>のドキュメントを参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L389-L394">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.svdvals" href="#LinearAlgebra.svdvals"><code>LinearAlgebra.svdvals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svdvals(A)</code></pre><p>行列 <code>A</code> の特異値を降順で返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Matrix{Float64}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals(A)
4-element Vector{Float64}:
 3.0
 2.23606797749979
 2.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L220-L241">source</a></section><section><div><pre><code class="language-julia hljs">svdvals(A, B)</code></pre><p><code>A</code> と <code>B</code> の一般化特異値分解から一般化特異値を返します。詳細は <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 0.; 0. -1.]
2×2 Matrix{Float64}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Matrix{Float64}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals(A, B)
2-element Vector{Float64}:
 1.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L543-L566">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.svdvals!" href="#LinearAlgebra.svdvals!"><code>LinearAlgebra.svdvals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svdvals!(A)</code></pre><p>行列 <code>A</code> の特異値を返し、入力を上書きすることでスペースを節約します。詳細は <a href="LinearAlgebra.html#LinearAlgebra.svdvals"><code>svdvals</code></a> と <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L211-L216">source</a></section><section><div><pre><code class="language-julia hljs">svdvals!(A, B)</code></pre><p>一般化特異値分解の一般化特異値を <code>A</code> と <code>B</code> から返し、<code>A</code> と <code>B</code> を上書きすることでスペースを節約します。詳細は <a href="LinearAlgebra.html#LinearAlgebra.svd"><code>svd</code></a> と <a href="LinearAlgebra.html#LinearAlgebra.svdvals"><code>svdvals</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/svd.jl#L526-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Givens" href="#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.Givens(i1,i2,c,s) -&gt; G</code></pre><p>Givens回転線形演算子。フィールド<code>c</code>と<code>s</code>は、それぞれ回転角のコサインとサインを表します。<code>Givens</code>型は、左乗算<code>G*A</code>と共役転置右乗算<code>A*G&#39;</code>をサポートします。この型には<code>size</code>がないため、<code>G*A</code>の場合は<code>i2&lt;=size(A,2)</code>、<code>A*G&#39;</code>の場合は<code>i2&lt;=size(A,1)</code>であれば任意のサイズの行列と乗算できます。</p><p>詳細は<a href="LinearAlgebra.html#LinearAlgebra.givens"><code>givens</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/givens.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.givens" href="#LinearAlgebra.givens"><code>LinearAlgebra.givens</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -&gt; (G::Givens, r::T)</code></pre><p>Givens回転<code>G</code>とスカラー<code>r</code>を計算します。これは、任意のベクトル<code>x</code>に対して次のようになります。</p><pre><code class="nohighlight hljs">x[i1] = f
x[i2] = g</code></pre><p>乗算の結果</p><pre><code class="nohighlight hljs">y = G*x</code></pre><p>は次の性質を持ちます。</p><pre><code class="nohighlight hljs">y[i1] = r
y[i2] = 0</code></pre><p>詳細は<a href="LinearAlgebra.html#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/givens.jl#L267-L287">source</a></section><section><div><pre><code class="language-julia hljs">givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -&gt; (G::Givens, r)</code></pre><p>Givens回転<code>G</code>とスカラー<code>r</code>を計算します。これにより、掛け算の結果が</p><pre><code class="nohighlight hljs">B = G*A</code></pre><p>次の性質を持つようになります。</p><pre><code class="nohighlight hljs">B[i1,j] = r
B[i2,j] = 0</code></pre><p>詳細は<a href="LinearAlgebra.html#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a>を参照してください。 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/givens.jl#L299-L313">source</a></section><section><div><pre><code class="language-julia hljs">givens(x::AbstractVector, i1::Integer, i2::Integer) -&gt; (G::Givens, r)</code></pre><p>Givens回転<code>G</code>とスカラー<code>r</code>を計算します。これにより、乗算の結果が</p><pre><code class="nohighlight hljs">B = G*x</code></pre><p>次の性質を持つようになります。</p><pre><code class="nohighlight hljs">B[i1] = r
B[i2] = 0</code></pre><p>詳細は<a href="LinearAlgebra.html#LinearAlgebra.Givens"><code>LinearAlgebra.Givens</code></a>を参照してください。 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/givens.jl#L318-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.triu" href="#LinearAlgebra.triu"><code>LinearAlgebra.triu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triu(M)</code></pre><p>行列の上三角部分。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = fill(1.0, (4,4))
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a)
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L325-L346">source</a></section><section><div><pre><code class="language-julia hljs">triu(M, k::Integer)</code></pre><p><code>k</code>番目の上対角線から始まる<code>M</code>の上三角行列を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = fill(1.0, (4,4))
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a,3)
4×4 Matrix{Float64}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; triu(a,-3)
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L373-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.triu!" href="#LinearAlgebra.triu!"><code>LinearAlgebra.triu!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">triu!(M)</code></pre><p>行列の上三角を取得し、その過程で <code>M</code> を上書きします。詳細は <a href="LinearAlgebra.html#LinearAlgebra.triu"><code>triu</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L435-L440">source</a></section><section><div><pre><code class="language-julia hljs">triu!(M, k::Integer)</code></pre><p><code>M</code>の<code>k</code>番目の上対角線から始まる上三角行列を返し、その過程で<code>M</code>を上書きします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Matrix{Int64}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; triu!(M, 1)
5×5 Matrix{Int64}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L114-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tril" href="#LinearAlgebra.tril"><code>LinearAlgebra.tril</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tril(M)</code></pre><p>行列の下三角部分。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = fill(1.0, (4,4))
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a)
4×4 Matrix{Float64}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L349-L370">source</a></section><section><div><pre><code class="language-julia hljs">tril(M, k::Integer)</code></pre><p><code>k</code>番目の上対角線から始まる<code>M</code>の下三角行列を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = fill(1.0, (4,4))
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,3)
4×4 Matrix{Float64}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,-3)
4×4 Matrix{Float64}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L404-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tril!" href="#LinearAlgebra.tril!"><code>LinearAlgebra.tril!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tril!(M)</code></pre><p>行列の下三角を取得し、その過程で <code>M</code> を上書きします。詳細は <a href="LinearAlgebra.html#LinearAlgebra.tril"><code>tril</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L443-L448">source</a></section><section><div><pre><code class="language-julia hljs">tril!(M, k::Integer)</code></pre><p><code>M</code>の<code>k</code>番目の上対角線から始まる下三角行列を返し、その過程で<code>M</code>を上書きします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Matrix{Int64}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; tril!(M, 2)
5×5 Matrix{Int64}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L152-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diagind" href="#LinearAlgebra.diagind"><code>LinearAlgebra.diagind</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagind(M::AbstractMatrix, k::Integer = 0, indstyle::IndexStyle = IndexLinear())
diagind(M::AbstractMatrix, indstyle::IndexStyle = IndexLinear())</code></pre><p>行列 <code>M</code> の <code>k</code> 番目の対角線のインデックスを与える <code>AbstractRange</code>。オプションで、返される範囲のタイプを決定するインデックススタイルを指定できます。<code>indstyle</code> が <code>IndexLinear</code> (デフォルト) の場合、これは <code>AbstractRange{Integer}</code> を返します。一方、<code>indstyle</code> が <code>IndexCartesian</code> の場合、これは <code>AbstractRange{CartesianIndex{2}}</code> を返します。</p><p><code>k</code> が指定されていない場合、<code>0</code> (主対角線に対応) と見なされます。</p><p>参照: <a href="LinearAlgebra.html#LinearAlgebra.diag"><code>diag</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.diagm"><code>diagm</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diagind(A, -1)
2:4:6

julia&gt; diagind(A, IndexCartesian())
StepRangeLen(CartesianIndex(1, 1), CartesianIndex(1, 1), 3)</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>IndexStyle</code> を指定するには、少なくとも Julia 1.11 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L218-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diag" href="#LinearAlgebra.diag"><code>LinearAlgebra.diag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diag(M, k::Integer=0)</code></pre><p>行列の <code>k</code> 番目の対角線をベクトルとして返します。</p><p>関連情報としては <a href="LinearAlgebra.html#LinearAlgebra.diagm"><code>diagm</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.diagind"><code>diagind</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a>, <a href="LinearAlgebra.html#LinearAlgebra.isdiag"><code>isdiag</code></a> があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diag(A,1)
2-element Vector{Int64}:
 2
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L256-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.diagm" href="#LinearAlgebra.diagm"><code>LinearAlgebra.diagm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)
diagm(m::Integer, n::Integer, kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)

`Pair`の対角線とベクトルから行列を構築します。ベクトル `kv.second` は `kv.first` 対角線に配置されます。デフォルトでは行列は正方形で、そのサイズは `kv` から推測されますが、非正方形のサイズ `m`×`n`（必要に応じてゼロでパディングされる）を最初の引数として `m,n` を渡すことで指定できます。繰り返しの対角線インデックス `kv.first` に対しては、対応するベクトル `kv.second` の値が加算されます。

`diagm` はフル行列を構築します。ストレージ効率の良いバージョンで高速な算術演算を希望する場合は、[`Diagonal`](@ref)、[`Bidiagonal`](@ref)、[`Tridiagonal`](@ref)、および [`SymTridiagonal`](@ref) を参照してください。

# 例
</code></pre><p>jldoctest julia&gt; diagm(1 =&gt; [1,2,3]) 4×4 Matrix{Int64}:  0  1  0  0  0  0  2  0  0  0  0  3  0  0  0  0</p><p>julia&gt; diagm(1 =&gt; [1,2,3], -1 =&gt; [4,5]) 4×4 Matrix{Int64}:  0  1  0  0  4  0  2  0  0  5  0  3  0  0  0  0</p><p>julia&gt; diagm(1 =&gt; [1,2,3], 1 =&gt; [1,2,3]) 4×4 Matrix{Int64}:  0  2  0  0  0  0  4  0  0  0  0  6  0  0  0  0 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L279-L318">source</a></section><section><div><pre><code class="language-julia hljs">diagm(v::AbstractVector)
diagm(m::Integer, n::Integer, v::AbstractVector)</code></pre><p>ベクトルの要素を対角要素とする行列を構築します。デフォルトでは、行列は正方形で、そのサイズは <code>length(v)</code> によって与えられますが、最初の引数として <code>m,n</code> を渡すことで非正方形のサイズ <code>m</code>×<code>n</code> を指定することができます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; diagm([1,2,3])
3×3 Matrix{Int64}:
 1  0  0
 0  2  0
 0  0  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L351-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rank" href="#LinearAlgebra.rank"><code>LinearAlgebra.rank</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank(::QRSparse{Tv,Ti}) -&gt; Ti</code></pre><p>QR分解のランクを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/spqr.jl#L369-L373">source</a></section><section><div><pre><code class="language-julia hljs">rank(S::SparseMatrixCSC{Tv,Ti}; [tol::Real]) -&gt; Ti</code></pre><p>行列 <code>S</code> のランクを QR 分解を用いて計算します。<code>tol</code> より小さい値はゼロと見なされます。SPQR のマニュアルを参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/solvers/spqr.jl#L376-L380">source</a></section><section><div><pre><code class="language-julia hljs">rank(A::AbstractMatrix; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : n*ϵ)
rank(A::AbstractMatrix, rtol::Real)</code></pre><p>行列の数値的ランクを計算するには、<code>svdvals(A)</code> の出力のうち、<code>max(atol, rtol*σ₁)</code> より大きいものの数を数えます。ここで、<code>σ₁</code> は <code>A</code> の計算された最大特異値です。<code>atol</code> と <code>rtol</code> はそれぞれ絶対許容誤差と相対許容誤差です。デフォルトの相対許容誤差は <code>n*ϵ</code> であり、ここで <code>n</code> は <code>A</code> の最小次元のサイズ、<code>ϵ</code> は <code>A</code> の要素型の <a href="../base/base.html#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>eps</code></a> です。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>数値的ランクは、特異値が閾値許容誤差 <code>max(atol, rtol*σ₁)</code> に近い条件の悪い行列の敏感で不正確な特性を示すことがあります。そのような場合、特異値計算や行列へのわずかな摂動が、1つまたは複数の特異値を閾値を越えさせることによって <code>rank</code> の結果を変える可能性があります。これらの変動は、異なるJuliaのバージョン、アーキテクチャ、コンパイラ、またはオペレーティングシステム間の浮動小数点誤差の変化によっても発生することがあります。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>atol</code> と <code>rtol</code> のキーワード引数は、少なくともJulia 1.1が必要です。Julia 1.0では <code>rtol</code> は位置引数として利用可能ですが、これはJulia 2.0で非推奨になります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rank(Matrix(I, 3, 3))
3

julia&gt; rank(diagm(0 =&gt; [1, 0, 2]))
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), rtol=0.1)
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), rtol=0.00001)
3

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), atol=1.5)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L954-L996">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(A, p::Real=2)</code></pre><p>任意の数値（または <code>norm</code> が定義されている任意の要素型）の iterable コンテナ <code>A</code>（任意の次元の配列を含む）に対して、<code>p</code>-ノルム（デフォルトは <code>p=2</code>）を計算します。これは、<code>A</code> が対応する長さのベクトルであるかのように扱われます。</p><p><code>p</code>-ノルムは次のように定義されます。</p><p class="math-container">\[\|A\|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p}\]</p><p>ここで、<span>$a_i$</span> は <code>A</code> のエントリ、<span>$| a_i |$</span> は <a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a> の <code>a_i</code> のノルム、<span>$n$</span> は <code>A</code> の長さです。<code>p</code>-ノルムは <code>A</code> のエントリの <a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a> を使用して計算されるため、<code>p != 2</code> の場合、ベクトルのベクトルの <code>p</code>-ノルムは一般的にブロックベクトルとしての解釈と互換性がありません。</p><p><code>p</code> は任意の数値を取ることができます（すべての値が数学的に有効なベクトルノルムを生成するわけではありません）。特に、<code>norm(A, Inf)</code> は <code>abs.(A)</code> の中で最大の値を返し、<code>norm(A, -Inf)</code> は最小の値を返します。<code>A</code> が行列で <code>p=2</code> の場合、これはフロベニウスノルムに相当します。</p><p>第二引数 <code>p</code> は必ずしも <code>norm</code> のインターフェースの一部ではなく、カスタム型は第二引数なしで <code>norm(A)</code> のみを実装することがあります。</p><p>行列の演算子ノルムを計算するには <a href="LinearAlgebra.html#LinearAlgebra.opnorm"><code>opnorm</code></a> を使用してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [3, -2, 6]
3-element Vector{Int64}:
  3
 -2
  6

julia&gt; norm(v)
7.0

julia&gt; norm(v, 1)
11.0

julia&gt; norm(v, Inf)
6.0

julia&gt; norm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia&gt; norm([1 2 3 4 5 6 7 8 9])
16.881943016134134

julia&gt; norm(1:9)
16.881943016134134

julia&gt; norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)
true

julia&gt; norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)
true

julia&gt; norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L539-L600">source</a></section><section><div><pre><code class="language-julia hljs">norm(x::Number, p::Real=2)</code></pre><p>数値の場合、<span>$\left( |x|^p \right)^{1/p}$</span>を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; norm(2, 1)
2.0

julia&gt; norm(-2, 1)
2.0

julia&gt; norm(2, 2)
2.0

julia&gt; norm(-2, 2)
2.0

julia&gt; norm(2, Inf)
2.0

julia&gt; norm(-2, Inf)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L618-L643">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opnorm(A::AbstractMatrix, p::Real=2)</code></pre><p>ベクトル <code>p</code>-ノルムによって誘導される演算子ノルム（または行列ノルム）を計算します。ここで有効な <code>p</code> の値は <code>1</code>、<code>2</code>、または <code>Inf</code> です。（スパース行列の場合、<code>p=2</code> は現在実装されていないことに注意してください。）フロベニウスノルムを計算するには <a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a> を使用します。</p><p><code>p=1</code> の場合、演算子ノルムは行列 <code>A</code> の最大絶対列和です：</p><p class="math-container">\[\|A\|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} |\]</p><p>ここで <span>$a_{ij}$</span> は行列 <code>A</code> の要素であり、<span>$m$</span> と <span>$n$</span> はその次元です。</p><p><code>p=2</code> の場合、演算子ノルムはスペクトルノルムであり、行列 <code>A</code> の最大特異値に等しいです。</p><p><code>p=Inf</code> の場合、演算子ノルムは行列 <code>A</code> の最大絶対行和です：</p><p class="math-container">\[\|A\|_\infty = \max_{1 ≤ i ≤ m} \sum _{j=1}^n | a_{ij} |\]</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 -2 -3; 2 3 -1]
2×3 Matrix{Int64}:
 1  -2  -3
 2   3  -1

julia&gt; opnorm(A, Inf)
6.0

julia&gt; opnorm(A, 1)
5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L707-L742">source</a></section><section><div><pre><code class="language-julia hljs">opnorm(x::Number, p::Real=2)</code></pre><p>数値の場合、<span>$\left( |x|^p \right)^{1/p}$</span>を返します。これは<a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a>と同等です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L755-L760">source</a></section><section><div><pre><code class="language-julia hljs">opnorm(A::Adjoint{&lt;:Any,&lt;:AbstractVector}, q::Real=2)
opnorm(A::Transpose{&lt;:Any,&lt;:AbstractVector}, q::Real=2)</code></pre><p>Adjoint/Transposeでラップされたベクトルの場合、<code>A</code>の演算子<span>$q$</span>-ノルムを返します。これは、値<code>p = q/(q-1)</code>の<code>p</code>-ノルムに相当します。<code>p = q = 2</code>のときに一致します。<code>A</code>の<code>p</code>ノルムをベクトルとして計算するには、<a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a>を使用してください。</p><p>ベクトル空間とその双対の間のノルムの違いは、双対性と内積の関係を保持するために生じ、結果は<code>1 × n</code>行列の演算子<code>p</code>-ノルムと一致します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1; im];

julia&gt; vc = v&#39;;

julia&gt; opnorm(vc, 1)
1.0

julia&gt; norm(vc, 1)
2.0

julia&gt; norm(v, 1)
2.0

julia&gt; opnorm(vc, 2)
1.4142135623730951

julia&gt; norm(vc, 2)
1.4142135623730951

julia&gt; norm(v, 2)
1.4142135623730951

julia&gt; opnorm(vc, Inf)
2.0

julia&gt; norm(vc, Inf)
1.0

julia&gt; norm(v, Inf)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L763-L808">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(a::AbstractArray, p::Real=2)</code></pre><p>配列 <code>a</code> をインプレースで正規化し、その <code>p</code>-ノルムが1に等しくなるようにします。すなわち、<code>norm(a, p) == 1</code> です。詳細は <a href="LinearAlgebra.html#LinearAlgebra.normalize"><code>normalize</code></a> および <a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1816-L1822">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize" href="#LinearAlgebra.normalize"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize(a, p::Real=2)</code></pre><p><code>a</code>を正規化してその<code>p</code>-ノルムが1になるようにします。すなわち、<code>norm(a, p) == 1</code>です。スカラーの場合、これはsign(a)に似ていますが、normalize(0) = NaNです。詳細は<a href="LinearAlgebra.html#LinearAlgebra.normalize!"><code>normalize!</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.norm"><code>norm</code></a>、および<a href="../base/math.html#Base.sign"><code>sign</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Vector{Float64}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Vector{Float64}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia&gt; norm(c, 1)
1.0

julia&gt; a = [1 2 4 ; 1 2 4]
2×3 Matrix{Int64}:
 1  2  4
 1  2  4

julia&gt; norm(a)
6.48074069840786

julia&gt; normalize(a)
2×3 Matrix{Float64}:
 0.154303  0.308607  0.617213
 0.154303  0.308607  0.617213

julia&gt; normalize(3, 1)
1.0

julia&gt; normalize(-8, 1)
-1.0

julia&gt; normalize(0, 1)
NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1842-L1894">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cond" href="#LinearAlgebra.cond"><code>LinearAlgebra.cond</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cond(M, p::Real=2)</code></pre><p>行列 <code>M</code> の条件数で、演算子 <code>p</code>-ノルムを使用して計算されます。<code>p</code> の有効な値は <code>1</code>、<code>2</code>（デフォルト）、または <code>Inf</code> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1625-L1630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.condskeel" href="#LinearAlgebra.condskeel"><code>LinearAlgebra.condskeel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">condskeel(M, [x, p::Real=Inf])</code></pre><p class="math-container">\[\kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \\
\kappa_S(M, x, p) = \frac{\left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p}{\left \Vert x \right \Vert_p}\]</p><p>行列 <code>M</code> のスキール条件数 <span>$\kappa_S$</span> は、ベクトル <code>x</code> に関してオプションで、演算子 <code>p</code>-ノルムを使用して計算されます。 <span>$\left\vert M \right\vert$</span> は <span>$M$</span> の（要素ごとの）絶対値の行列を示します; <span>$\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert$</span>。 <code>p</code> の有効な値は <code>1</code>、<code>2</code>、および <code>Inf</code>（デフォルト）です。</p><p>この量は文献ではバウアー条件数、相対条件数、または成分ごとの相対条件数としても知られています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1176-L1192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tr(M)</code></pre><p>行列のトレース。<code>M</code>の対角要素を合計します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; tr(A)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1005-L1020">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.det" href="#LinearAlgebra.det"><code>LinearAlgebra.det</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">det(M)</code></pre><p>行列式。</p><p>参照: <a href="LinearAlgebra.html#LinearAlgebra.logdet"><code>logdet</code></a> および <a href="LinearAlgebra.html#LinearAlgebra.logabsdet"><code>logabsdet</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 0; 2 2]
2×2 Matrix{Int64}:
 1  0
 2  2

julia&gt; det(M)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1628-L1645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.logdet" href="#LinearAlgebra.logdet"><code>LinearAlgebra.logdet</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logdet(M)</code></pre><p>行列式の対数。<code>log(det(M))</code>と同等ですが、精度が向上し、オーバーフロー/アンダーフローを回避することができます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 0; 2 2]
2×2 Matrix{Int64}:
 1  0
 2  2

julia&gt; logdet(M)
0.6931471805599453

julia&gt; logdet(Matrix(I, 3, 3))
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1697-L1716">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.logabsdet" href="#LinearAlgebra.logabsdet"><code>LinearAlgebra.logabsdet</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logabsdet(M)</code></pre><p>行列式の絶対値の対数。<code>(log(abs(det(M))), sign(det(M)))</code> と同等ですが、精度や速度が向上する可能性があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [-1. 0.; 0. 1.]
2×2 Matrix{Float64}:
 -1.0  0.0
  0.0  1.0

julia&gt; det(A)
-1.0

julia&gt; logabsdet(A)
(0.0, -1.0)

julia&gt; B = [2. 0.; 0. 1.]
2×2 Matrix{Float64}:
 2.0  0.0
 0.0  1.0

julia&gt; det(B)
2.0

julia&gt; logabsdet(B)
(0.6931471805599453, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1658-L1688">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.inv-Tuple{AbstractMatrix}" href="#Base.inv-Tuple{AbstractMatrix}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv(M)</code></pre><p>行列の逆行列。行列 <code>M</code> と <code>N</code> の積が単位行列 <code>I</code> になるような行列 <code>N</code> を計算します。これは左除算 <code>N = M \ I</code> を解くことによって計算されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [2 5; 1 3]
2×2 Matrix{Int64}:
 2  5
 1  3

julia&gt; N = inv(M)
2×2 Matrix{Float64}:
  3.0  -5.0
 -1.0   2.0

julia&gt; M*N == N*M == Matrix(I, 2, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1032-L1055">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.pinv" href="#LinearAlgebra.pinv"><code>LinearAlgebra.pinv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pinv(M; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : n*ϵ)
pinv(M, rtol::Real) = pinv(M; rtol=rtol) # to be deprecated in Julia 2.0</code></pre><p>ムーア・ペンローズ擬似逆行列を計算します。</p><p>浮動小数点要素を持つ行列 <code>M</code> に対して、擬似逆行列を計算するためには、<code>σ₁</code> が <code>M</code> の最大特異値であるとき、<code>max(atol, rtol*σ₁)</code> より大きい特異値のみを逆転させることが便利です。</p><p>絶対許容誤差（<code>atol</code>）と相対許容誤差（<code>rtol</code>）の最適な選択は、<code>M</code> の値と擬似逆行列の意図された用途によって異なります。デフォルトの相対許容誤差は <code>n*ϵ</code> であり、ここで <code>n</code> は <code>M</code> の最小次元のサイズ、<code>ϵ</code> は <code>M</code> の要素型の <a href="../base/base.html#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>eps</code></a> です。</p><p>最小二乗法の観点から、密な条件の悪い行列を逆転させるためには、<code>rtol = sqrt(eps(real(float(oneunit(eltype(M))))))</code> が推奨されます。</p><p>詳細については、[^\issue8859]、[^\B96]、[^\S84]、[^\KY88] を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1.5 1.3; 1.2 1.9]
2×2 Matrix{Float64}:
 1.5  1.3
 1.2  1.9

julia&gt; N = pinv(M)
2×2 Matrix{Float64}:
  1.47287   -1.00775
 -0.930233   1.16279

julia&gt; M * N
2×2 Matrix{Float64}:
 1.0          -2.22045e-16
 4.44089e-16   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1500-L1545">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.nullspace" href="#LinearAlgebra.nullspace"><code>LinearAlgebra.nullspace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nullspace(M; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : n*ϵ)
nullspace(M, rtol::Real) = nullspace(M; rtol=rtol) # to be deprecated in Julia 2.0</code></pre><p><code>M</code>のヌル空間の基底を計算します。これは、<code>M</code>の特異値のうち、絶対値が<code>max(atol, rtol*σ₁)</code>より小さい特異ベクトルを含むもので、ここで<code>σ₁</code>は<code>M</code>の最大特異値です。</p><p>デフォルトでは、相対許容誤差<code>rtol</code>は<code>n*ϵ</code>であり、<code>n</code>は<code>M</code>の最小次元のサイズ、<code>ϵ</code>は<code>M</code>の要素型の<a href="../base/base.html#Base.eps-Tuple{Type{&lt;:AbstractFloat}}"><code>eps</code></a>です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 0 0; 0 1 0; 0 0 0]
3×3 Matrix{Int64}:
 1  0  0
 0  1  0
 0  0  0

julia&gt; nullspace(M)
3×1 Matrix{Float64}:
 0.0
 0.0
 1.0

julia&gt; nullspace(M, rtol=3)
3×3 Matrix{Float64}:
 0.0  1.0  0.0
 1.0  0.0  0.0
 0.0  0.0  1.0

julia&gt; nullspace(M, atol=0.95)
3×1 Matrix{Float64}:
 0.0
 0.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1577-L1615">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kron(A, B)</code></pre><p>2つのベクトル、行列、または数のクロネッカー積を計算します。</p><p>実ベクトル <code>v</code> と <code>w</code> に対して、クロネッカー積は外積に関連しており、<code>kron(v,w) == vec(w * transpose(v))</code> または <code>w * transpose(v) == reshape(kron(v,w), (length(w), length(v)))</code> となります。これらの式の左側と右側で <code>v</code> と <code>w</code> の順序が異なることに注意してください（列優先ストレージのため）。複素ベクトルの場合、外積 <code>w * v&#39;</code> も <code>v</code> の共役によって異なります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; B = [im 1; 1 -im]
2×2 Matrix{Complex{Int64}}:
 0+1im  1+0im
 1+0im  0-1im

julia&gt; kron(A, B)
4×4 Matrix{Complex{Int64}}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im

julia&gt; v = [1, 2]; w = [3, 4, 5];

julia&gt; w*transpose(v)
3×2 Matrix{Int64}:
 3   6
 4   8
 5  10

julia&gt; reshape(kron(v,w), (length(w), length(v)))
3×2 Matrix{Int64}:
 3   6
 4   8
 5  10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L447-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.kron!" href="#Base.kron!"><code>Base.kron!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kron!(C, A, B)</code></pre><p><code>A</code>と<code>B</code>のクロネッカー積を計算し、その結果を<code>C</code>に格納し、<code>C</code>の既存の内容を上書きします。これは<a href="LinearAlgebra.html#Base.kron"><code>kron</code></a>のインプレースバージョンです。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>この関数はJulia 1.6以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L385-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Union{Float32, Float64, ComplexF64, ComplexF32}}" href="#Base.exp-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Union{Float32, Float64, ComplexF64, ComplexF32}}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の行列指数関数を計算します。これは次のように定義されます。</p><p class="math-container">\[e^A = \sum_{n=0}^{\infty} \frac{A^n}{n!}.\]</p><p>対称行列またはエルミート行列 <code>A</code> の場合は、固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）が使用され、それ以外の場合はスケーリングと平方化アルゴリズムが選択されます（[^\H05]を参照）。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Matrix(1.0I, 2, 2)
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0

julia&gt; exp(A)
2×2 Matrix{Float64}:
 2.71828  0.0
 0.0      2.71828</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L595-L621">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cis-Tuple{AbstractMatrix}" href="#Base.cis-Tuple{AbstractMatrix}"><code>Base.cis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cis(A::AbstractMatrix)</code></pre><p>平方行列 <code>A</code> の <code>exp(im*A)</code> のより効率的な方法（特に <code>A</code> が <code>Hermitian</code> または実対称行列の場合）。</p><p><a href="../base/math.html#Base.cispi"><code>cispi</code></a>、<a href="../base/math.html#Base.Math.sincos-Tuple{Float64}"><code>sincos</code></a>、<a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp</code></a> も参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>行列に対して <code>cis</code> を使用するサポートは Julia 1.7 で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cis([π 0; 0 π]) ≈ -I
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L626-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:^-Tuple{AbstractMatrix, Number}" href="#Base.:^-Tuple{AbstractMatrix, Number}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">^(A::AbstractMatrix, p::Number)</code></pre><p>行列の累乗、<span>$\exp(p\log(A))$</span>に相当します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; [1 2; 0 3]^3
2×2 Matrix{Int64}:
 1  26
 0  27</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L578-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:^-Tuple{Number, AbstractMatrix}" href="#Base.:^-Tuple{Number, AbstractMatrix}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">^(b::Number, A::AbstractMatrix)</code></pre><p>行列の指数関数、<span>$\exp(\log(b)A)$</span>に相当します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>Irrational</code> 数（例えば <code>ℯ</code>）を行列に対して累乗するサポートは、Julia 1.1で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 2^[1 2; 0 3]
2×2 Matrix{Float64}:
 2.0  6.0
 0.0  8.0

julia&gt; ℯ^[1 2; 0 3]
2×2 Matrix{Float64}:
 2.71828  17.3673
 0.0      20.0855</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L649-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{StridedMatrix{T} where T}" href="#Base.log-Tuple{StridedMatrix{T} where T}"><code>Base.log</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(A::AbstractMatrix)</code></pre><p>もし <code>A</code> に負の実固有値がない場合、<code>A</code> の主行列対数を計算します。すなわち、<span>$e^X = A$</span> であり、すべての固有値 <span>$\lambda$</span> に対して <span>$-\pi &lt; Im(\lambda) &lt; \pi$</span> となる唯一の行列 <span>$X$</span> を求めます。もし <code>A</code> に非正の固有値がある場合、可能な限り非主行列関数が返されます。</p><p><code>A</code> が対称またはエルミートの場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）が使用され、<code>A</code> が三角行列の場合は、逆スケーリングと平方根法の改良版が使用されます（[^\AH12] および [^\AHR13] を参照）。もし <code>A</code> が負の固有値を持たない実数の場合、実シュア形式が計算されます。それ以外の場合は、複素シュア形式が計算されます。次に、[^\AHR13] の上部（準）三角アルゴリズムが上部（準）三角因子に対して使用されます。</p><p>[^\AH12]: Awad H. Al-Mohy と Nicholas J. Higham, &quot;Improved inverse scaling and squaring algorithms for the matrix logarithm&quot;, SIAM Journal on Scientific Computing, 34(4), 2012, C153-C169. <a href="https://doi.org/10.1137/110852553">doi:10.1137/110852553</a></p><p>[^\AHR13]: Awad H. Al-Mohy, Nicholas J. Higham と Samuel D. Relton, &quot;Computing the Fréchet derivative of the matrix logarithm and estimating the condition number&quot;, SIAM Journal on Scientific Computing, 35(4), 2013, C394-C410. <a href="https://doi.org/10.1137/120885991">doi:10.1137/120885991</a></p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Matrix(2.7182818*I, 2, 2)
2×2 Matrix{Float64}:
 2.71828  0.0
 0.0      2.71828

julia&gt; log(A)
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L794-L825">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sqrt-Tuple{StridedMatrix{T} where T}" href="#Base.sqrt-Tuple{StridedMatrix{T} where T}"><code>Base.sqrt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sqrt(x)</code></pre><p>返す <span>$\sqrt{x}$</span>。</p><p>負の <a href="../base/numbers.html#Core.Real"><code>Real</code></a> 引数に対して <a href="../base/base.html#Core.DomainError"><code>DomainError</code></a> をスローします。代わりに複素数の負の引数を使用してください。<code>sqrt</code> は負の実数軸に沿った分岐切断を持つことに注意してください。</p><p>接頭辞演算子 <code>√</code> は <code>sqrt</code> と同等です。</p><p>関連項目: <a href="../base/math.html#Base.Math.hypot"><code>hypot</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sqrt(big(81))
9.0

julia&gt; sqrt(big(-81))
ERROR: DomainError with -81.0:
NaN result for non-NaN input.
Stacktrace:
 [1] sqrt(::BigFloat) at ./mpfr.jl:501
[...]

julia&gt; sqrt(big(complex(-81)))
0.0 + 9.0im

julia&gt; sqrt(-81 - 0.0im)  # -0.0im は分岐切断の下にあります
0.0 - 9.0im

julia&gt; .√(1:4)
4-element Vector{Float64}:
 1.0
 1.4142135623730951
 1.7320508075688772
 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/math.jl#L612-L650">source</a></section><section><div><pre><code class="language-julia hljs">sqrt(A::AbstractMatrix)</code></pre><p>もし <code>A</code> に負の実固有値がない場合、<code>A</code> の主行列平方根を計算します。つまり、<span>$X^2 = A$</span> となる、実部が正の固有値を持つ一意の行列 <span>$X$</span> です。それ以外の場合、非主平方根が返されます。</p><p><code>A</code> が実対称行列またはエルミート行列である場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用して平方根を計算します。このような行列に対して、丸め誤差のためにわずかに負に見える固有値 λ は、ゼロであるかのように扱われます。より正確には、すべての固有値が <code>≥ -rtol*(max |λ|)</code> である行列は半正定値として扱われ（エルミート平方根を生成）、負の固有値はゼロと見なされます。<code>rtol</code> は <code>sqrt</code> へのキーワード引数（エルミート/実対称の場合のみ）で、デフォルトは <code>size(A,1)</code> にスケーリングされた機械精度です。</p><p>それ以外の場合、平方根はBjörck-Hammarling法 <sup class="footnote-reference"><a id="citeref-BH83" href="#footnote-BH83">[BH83]</a></sup> によって決定され、複素シュール形式（<a href="LinearAlgebra.html#LinearAlgebra.schur"><code>schur</code></a>）を計算し、その後三角因子の複素平方根を計算します。実平方根が存在する場合は、実シュール形式を計算し、その後準三角因子の実平方根を計算するこの方法の拡張 <sup class="footnote-reference"><a id="citeref-H87" href="#footnote-H87">[H87]</a></sup> が代わりに使用されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4 0; 0 4]
2×2 Matrix{Int64}:
 4  0
 0  4

julia&gt; sqrt(A)
2×2 Matrix{Float64}:
 2.0  0.0
 0.0  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L857-L902">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.cbrt-Tuple{AbstractMatrix{&lt;:Real}}" href="#Base.Math.cbrt-Tuple{AbstractMatrix{&lt;:Real}}"><code>Base.Math.cbrt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cbrt(A::AbstractMatrix{&lt;:Real})</code></pre><p>実数値行列 <code>A</code> の実数値立方根を計算します。もし <code>T = cbrt(A)</code> であれば、<code>T*T*T ≈ A</code> となります。以下に示す例を参照してください。</p><p>もし <code>A</code> が対称であれば、すなわち <code>HermOrSym{&lt;:Real}</code> 型であれば、(<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>) を使用して立方根を求めます。そうでない場合は、特化した p-th 根アルゴリズム <sup class="footnote-reference"><a id="citeref-S03" href="#footnote-S03">[S03]</a></sup> が利用され、実数値シュール分解 (<a href="LinearAlgebra.html#LinearAlgebra.schur"><code>schur</code></a>) を利用して立方根を計算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [0.927524 -0.15857; -1.3677 -1.01172]
2×2 Matrix{Float64}:
  0.927524  -0.15857
 -1.3677    -1.01172

julia&gt; T = cbrt(A)
2×2 Matrix{Float64}:
  0.910077  -0.151019
 -1.30257   -0.936818

julia&gt; T*T*T ≈ A
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L938-L970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cos-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}" href="#Base.cos-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}"><code>Base.cos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cos(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列コサインを計算します。</p><p><code>A</code> が対称またはエルミートの場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用してコサインを計算します。そうでない場合、コサインは <a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp</code></a> を呼び出すことによって決定されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cos(fill(1.0, (2,2)))
2×2 Matrix{Float64}:
  0.291927  -0.708073
 -0.708073   0.291927</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L999-L1014">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sin-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}" href="#Base.sin-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}"><code>Base.sin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sin(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列サインを計算します。</p><p><code>A</code> が対称またはエルミートの場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用してサインを計算します。それ以外の場合、サインは <a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp</code></a> を呼び出すことによって決定されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sin(fill(1.0, (2,2)))
2×2 Matrix{Float64}:
 0.454649  0.454649
 0.454649  0.454649</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1032-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.sincos-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}" href="#Base.Math.sincos-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}"><code>Base.Math.sincos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sincos(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列サインとコサインを計算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; S, C = sincos(fill(1.0, (2,2)));

julia&gt; S
2×2 Matrix{Float64}:
 0.454649  0.454649
 0.454649  0.454649

julia&gt; C
2×2 Matrix{Float64}:
  0.291927  -0.708073
 -0.708073   0.291927</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1069-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.tan-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}" href="#Base.tan-Tuple{StridedMatrix{var&quot;#s1041&quot;} where var&quot;#s1041&quot;&lt;:Real}"><code>Base.tan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tan(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列タンジェントを計算します。</p><p><code>A</code> が対称またはエルミートの場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用してタンジェントを計算します。それ以外の場合、タンジェントは <a href="../base/math.html#Base.exp-Tuple{Float64}"><code>exp</code></a> を呼び出すことによって決定されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tan(fill(1.0, (2,2)))
2×2 Matrix{Float64}:
 -1.09252  -1.09252
 -1.09252  -1.09252</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1118-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.sec-Tuple{StridedMatrix{T} where T}" href="#Base.Math.sec-Tuple{StridedMatrix{T} where T}"><code>Base.Math.sec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sec(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列セカントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1344-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.csc-Tuple{StridedMatrix{T} where T}" href="#Base.Math.csc-Tuple{StridedMatrix{T} where T}"><code>Base.Math.csc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">csc(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列コセカントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1344-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.cot-Tuple{StridedMatrix{T} where T}" href="#Base.Math.cot-Tuple{StridedMatrix{T} where T}"><code>Base.Math.cot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cot(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列コタンジェントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1344-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cosh-Tuple{StridedMatrix{T} where T}" href="#Base.cosh-Tuple{StridedMatrix{T} where T}"><code>Base.cosh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosh(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列双曲線コサインを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1143-L1147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sinh-Tuple{StridedMatrix{T} where T}" href="#Base.sinh-Tuple{StridedMatrix{T} where T}"><code>Base.sinh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sinh(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列双曲線正弦を計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1157-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.tanh-Tuple{StridedMatrix{T} where T}" href="#Base.tanh-Tuple{StridedMatrix{T} where T}"><code>Base.tanh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tanh(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の行列双曲線正接を計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1171-L1175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.sech-Tuple{StridedMatrix{T} where T}" href="#Base.Math.sech-Tuple{StridedMatrix{T} where T}"><code>Base.Math.sech</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sech(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の行列双曲線セカントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1349-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.csch-Tuple{StridedMatrix{T} where T}" href="#Base.Math.csch-Tuple{StridedMatrix{T} where T}"><code>Base.Math.csch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">csch(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の行列双曲線余割を計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1349-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.coth-Tuple{StridedMatrix{T} where T}" href="#Base.Math.coth-Tuple{StridedMatrix{T} where T}"><code>Base.Math.coth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coth(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の行列双曲線コタンジェントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1349-L1353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.acos-Tuple{StridedMatrix{T} where T}" href="#Base.acos-Tuple{StridedMatrix{T} where T}"><code>Base.acos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acos(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の逆行列コサインを計算します。</p><p><code>A</code> が対称またはエルミートの場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用して逆コサインを計算します。そうでない場合、逆コサインは <a href="../base/math.html#Base.log-Tuple{Number}"><code>log</code></a> と <a href="../base/math.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a> を使用して決定されます。この関数を計算するために使用される理論と対数式については、<sup class="footnote-reference"><a id="citeref-AH16_1" href="#footnote-AH16_1">[AH16_1]</a></sup> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; acos(cos([0.5 0.1; -0.2 0.3]))
2×2 Matrix{ComplexF64}:
  0.5-8.32667e-17im  0.1+0.0im
 -0.2+2.63678e-16im  0.3-3.46945e-16im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1191-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.asin-Tuple{StridedMatrix{T} where T}" href="#Base.asin-Tuple{StridedMatrix{T} where T}"><code>Base.asin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asin(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の逆行列サインを計算します。</p><p><code>A</code> が対称行列またはエルミート行列である場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用して逆サインを計算します。そうでない場合、逆サインは <a href="../base/math.html#Base.log-Tuple{Number}"><code>log</code></a> と <a href="../base/math.html#Base.sqrt-Tuple{Number}"><code>sqrt</code></a> を使用して決定されます。この関数を計算するために使用される理論と対数式については、<sup class="footnote-reference"><a id="citeref-AH16_2" href="#footnote-AH16_2">[AH16_2]</a></sup> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; asin(sin([0.5 0.1; -0.2 0.3]))
2×2 Matrix{ComplexF64}:
  0.5-4.16334e-17im  0.1-5.55112e-17im
 -0.2+9.71445e-17im  0.3-1.249e-16im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1222-L1241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.atan-Tuple{StridedMatrix{T} where T}" href="#Base.atan-Tuple{StridedMatrix{T} where T}"><code>Base.atan</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">atan(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の逆行列タンジェントを計算します。</p><p><code>A</code> が対称またはエルミートの場合、その固有分解（<a href="LinearAlgebra.html#LinearAlgebra.eigen"><code>eigen</code></a>）を使用して逆タンジェントを計算します。そうでない場合、逆タンジェントは <a href="../base/math.html#Base.log-Tuple{Number}"><code>log</code></a> を使用して決定されます。この関数を計算するために使用される理論と対数式については、<sup class="footnote-reference"><a id="citeref-AH16_3" href="#footnote-AH16_3">[AH16_3]</a></sup> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; atan(tan([0.5 0.1; -0.2 0.3]))
2×2 Matrix{ComplexF64}:
  0.5+1.38778e-17im  0.1-2.77556e-17im
 -0.2+6.93889e-17im  0.3-4.16334e-17im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1253-L1272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.asec-Tuple{StridedMatrix{T} where T}" href="#Base.Math.asec-Tuple{StridedMatrix{T} where T}"><code>Base.Math.asec</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asec(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の逆行列セカントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1363-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.acsc-Tuple{StridedMatrix{T} where T}" href="#Base.Math.acsc-Tuple{StridedMatrix{T} where T}"><code>Base.Math.acsc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acsc(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の逆行列コセカントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1363-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.acot-Tuple{StridedMatrix{T} where T}" href="#Base.Math.acot-Tuple{StridedMatrix{T} where T}"><code>Base.Math.acot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acot(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の逆行列コタンジェントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1363-L1365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.acosh-Tuple{StridedMatrix{T} where T}" href="#Base.acosh-Tuple{StridedMatrix{T} where T}"><code>Base.acosh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acosh(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の逆双曲線行列コサインを計算します。この関数を計算するために使用される理論と対数式については、<sup class="footnote-reference"><a id="citeref-AH16_4" href="#footnote-AH16_4">[AH16_4]</a></sup>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1283-L1290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.asinh-Tuple{StridedMatrix{T} where T}" href="#Base.asinh-Tuple{StridedMatrix{T} where T}"><code>Base.asinh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asinh(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の逆双曲線行列サインを計算します。この関数を計算するために使用される理論と対数式については、<sup class="footnote-reference"><a id="citeref-AH16_5" href="#footnote-AH16_5">[AH16_5]</a></sup>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1302-L1309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.atanh-Tuple{StridedMatrix{T} where T}" href="#Base.atanh-Tuple{StridedMatrix{T} where T}"><code>Base.atanh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">atanh(A::AbstractMatrix)</code></pre><p>正方行列 <code>A</code> の逆双曲線行列タンジェントを計算します。この関数を計算するために使用される理論と対数式については、<sup class="footnote-reference"><a id="citeref-AH16_6" href="#footnote-AH16_6">[AH16_6]</a></sup>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1320-L1327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.asech-Tuple{StridedMatrix{T} where T}" href="#Base.Math.asech-Tuple{StridedMatrix{T} where T}"><code>Base.Math.asech</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asech(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の逆行列双曲線セカントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1366-L1368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.acsch-Tuple{StridedMatrix{T} where T}" href="#Base.Math.acsch-Tuple{StridedMatrix{T} where T}"><code>Base.Math.acsch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acsch(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の逆行列双曲線余弦の計算を行います。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1366-L1368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Math.acoth-Tuple{StridedMatrix{T} where T}" href="#Base.Math.acoth-Tuple{StridedMatrix{T} where T}"><code>Base.Math.acoth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acoth(A::AbstractMatrix)</code></pre><p>行列 <code>A</code> の逆行列双曲線コタンジェントを計算します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1366-L1368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lyap" href="#LinearAlgebra.lyap"><code>LinearAlgebra.lyap</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyap(A, C)</code></pre><p>連続リャプノフ方程式 <code>AX + XA&#39; + C = 0</code> の解 <code>X</code> を計算します。ここで、<code>A</code> の固有値の実部がゼロでないこと、かつ二つの固有値が負の複素共役でないことが条件です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3. 4.; 5. 6]
2×2 Matrix{Float64}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Matrix{Float64}:
 1.0  1.0
 1.0  2.0

julia&gt; X = lyap(A, B)
2×2 Matrix{Float64}:
  0.5  -0.5
 -0.5   0.25

julia&gt; A*X + X*A&#39; ≈ -B
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1733-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.sylvester" href="#LinearAlgebra.sylvester"><code>LinearAlgebra.sylvester</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sylvester(A, B, C)</code></pre><p>シルベスター方程式 <code>AX + XB + C = 0</code> の解 <code>X</code> を計算します。ここで、<code>A</code>、<code>B</code>、および <code>C</code> は互換性のある次元を持ち、<code>A</code> と <code>-B</code> は実部が等しい固有値を持たない必要があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3. 4.; 5. 6]
2×2 Matrix{Float64}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Matrix{Float64}:
 1.0  1.0
 1.0  2.0

julia&gt; C = [1. 2.; -2. 1]
2×2 Matrix{Float64}:
  1.0  2.0
 -2.0  1.0

julia&gt; X = sylvester(A, B, C)
2×2 Matrix{Float64}:
 -4.46667   1.93333
  3.73333  -1.8

julia&gt; A*X + X*B ≈ -C
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L1656-L1687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.issuccess" href="#LinearAlgebra.issuccess"><code>LinearAlgebra.issuccess</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issuccess(F::Factorization)</code></pre><p>行列の因数分解が成功したかどうかをテストします。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>issuccess(::CholeskyPivoted)</code> はJulia 1.6以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = cholesky([1 0; 0 1]);

julia&gt; issuccess(F)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/factorization.jl#L72-L88">source</a></section><section><div><pre><code class="language-julia hljs">issuccess(F::LU; allowsingular = false)</code></pre><p>LU分解が成功したかどうかをテストします。デフォルトでは、有効だがランクが不足しているU因子を生成する分解は失敗と見なされます。これは<code>allowsingular = true</code>を渡すことで変更できます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>allowsingular</code>キーワード引数はJulia 1.11で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = lu([1 2; 1 2], check = false);

julia&gt; issuccess(F)
false

julia&gt; issuccess(F, allowsingular = true)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lu.jl#L403-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.issymmetric" href="#LinearAlgebra.issymmetric"><code>LinearAlgebra.issymmetric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issymmetric(A) -&gt; Bool</code></pre><p>行列が対称であるかどうかをテストします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 2 -1]
2×2 Matrix{Int64}:
 1   2
 2  -1

julia&gt; issymmetric(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Matrix{Complex{Int64}}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; issymmetric(b)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1199-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.isposdef" href="#LinearAlgebra.isposdef"><code>LinearAlgebra.isposdef</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isposdef(A) -&gt; Bool</code></pre><p>行列が正定値（およびエルミート）であるかどうかを、<code>A</code>のコレスキー分解を試みることでテストします。</p><p><a href="LinearAlgebra.html#LinearAlgebra.isposdef!"><code>isposdef!</code></a>や<a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 2 50]
2×2 Matrix{Int64}:
 1   2
 2  50

julia&gt; isposdef(A)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L73-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.isposdef!" href="#LinearAlgebra.isposdef!"><code>LinearAlgebra.isposdef!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isposdef!(A) -&gt; Bool</code></pre><p>行列が正定値（およびエルミート）であるかどうかを、<code>A</code>のコレスキー分解を試みることで確認します。この過程で<code>A</code>は上書きされます。詳細は<a href="LinearAlgebra.html#LinearAlgebra.isposdef"><code>isposdef</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1. 2.; 2. 50.];

julia&gt; isposdef!(A)
true

julia&gt; A
2×2 Matrix{Float64}:
 1.0  2.0
 2.0  6.78233</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/dense.jl#L50-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.istril" href="#LinearAlgebra.istril"><code>LinearAlgebra.istril</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istril(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</code></pre><p><code>A</code>が<code>k</code>番目のスーパー対角線から始まる下三角行列であるかどうかをテストします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 2 -1]
2×2 Matrix{Int64}:
 1   2
 2  -1

julia&gt; istril(a)
false

julia&gt; istril(a, 1)
true

julia&gt; c = [1 1 0; 1 1 1; 1 1 1]
3×3 Matrix{Int64}:
 1  1  0
 1  1  1
 1  1  1

julia&gt; istril(c)
false

julia&gt; istril(c, 1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1322-L1352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.istriu" href="#LinearAlgebra.istriu"><code>LinearAlgebra.istriu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">istriu(A::AbstractMatrix, k::Integer = 0) -&gt; Bool</code></pre><p><code>A</code>が<code>k</code>番目のスーパー対角線から始まる上三角行列であるかどうかをテストします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 2 -1]
2×2 Matrix{Int64}:
 1   2
 2  -1

julia&gt; istriu(a)
false

julia&gt; istriu(a, -1)
true

julia&gt; c = [1 1 1; 1 1 1; 0 1 1]
3×3 Matrix{Int64}:
 1  1  1
 1  1  1
 0  1  1

julia&gt; istriu(c)
false

julia&gt; istriu(c, -1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1277-L1307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.isdiag" href="#LinearAlgebra.isdiag"><code>LinearAlgebra.isdiag</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdiag(A) -&gt; Bool</code></pre><p>行列が対角行列であるかどうかをテストします。すなわち、<code>iszero(A[i,j])</code> が <code>i == j</code> でない限り真であることを確認します。<code>A</code> が正方行列である必要はありません。正方行列であることも確認したい場合は、<code>size(A, 1) == size(A, 2)</code> をチェックする必要があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 2 -1]
2×2 Matrix{Int64}:
 1   2
 2  -1

julia&gt; isdiag(a)
false

julia&gt; b = [im 0; 0 -im]
2×2 Matrix{Complex{Int64}}:
 0+1im  0+0im
 0+0im  0-1im

julia&gt; isdiag(b)
true

julia&gt; c = [1 0 0; 0 2 0]
2×3 Matrix{Int64}:
 1  0  0
 0  2  0

julia&gt; isdiag(c)
true

julia&gt; d = [1 0 0; 0 2 3]
2×3 Matrix{Int64}:
 1  0  0
 0  2  3

julia&gt; isdiag(d)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1400-L1441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ishermitian" href="#LinearAlgebra.ishermitian"><code>LinearAlgebra.ishermitian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishermitian(A) -&gt; Bool</code></pre><p>行列がエルミートかどうかをテストします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 2 -1]
2×2 Matrix{Int64}:
 1   2
 2  -1

julia&gt; ishermitian(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Matrix{Complex{Int64}}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; ishermitian(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L1238-L1261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.transpose" href="#Base.transpose"><code>Base.transpose</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose(A)</code></pre><p>遅延転置。返されたオブジェクトを変更すると、適切に <code>A</code> が変更されます。しばしば、しかし常にではなく、<code>Transpose(A)</code> を返します。ここで <code>Transpose</code> は遅延転置ラッパーです。この操作は再帰的であることに注意してください。</p><p>この操作は線形代数の使用を意図しています - 一般的なデータ操作については <a href="../base/arrays.html#Base.permutedims"><code>permutedims</code></a> を参照してください。これは再帰的ではありません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3 2; 0 0]
2×2 Matrix{Int64}:
 3  2
 0  0

julia&gt; B = transpose(A)
2×2 transpose(::Matrix{Int64}) with eltype Int64:
 3  0
 2  0

julia&gt; B isa Transpose
true

julia&gt; transpose(B) === A # 転置の転置は親をアンラップします
true

julia&gt; Transpose(B) # ただし、コンストラクタは常にその引数をラップします
2×2 transpose(transpose(::Matrix{Int64})) with eltype Int64:
 3  2
 0  0

julia&gt; B[1,2] = 4; # Bを変更するとAも自動的に変更されます

julia&gt; A
2×2 Matrix{Int64}:
 3  2
 4  0</code></pre><p>複素行列の場合、<code>adjoint</code> 操作は共役転置に相当します。</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape([Complex(x, x) for x in 1:4], 2, 2)
2×2 Matrix{Complex{Int64}}:
 1+1im  3+3im
 2+2im  4+4im

julia&gt; adjoint(A) == conj(transpose(A))
true</code></pre><p><code>AbstractVector</code> の <code>transpose</code> は行ベクトルです：</p><pre><code class="language-julia-repl hljs">julia&gt; v = [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; transpose(v) # 行ベクトルを返します
1×3 transpose(::Vector{Int64}) with eltype Int64:
 1  2  3

julia&gt; transpose(v) * v # ドット積を計算します
14</code></pre><p>行列の行列の場合、個々のブロックは再帰的に操作されます：</p><pre><code class="language-julia-repl hljs">julia&gt; C = [1 3; 2 4]
2×2 Matrix{Int64}:
 1  3
 2  4

julia&gt; D = reshape([C, 2C, 3C, 4C], 2, 2) # ブロック行列を構築します
2×2 Matrix{Matrix{Int64}}:
 [1 3; 2 4]  [3 9; 6 12]
 [2 6; 4 8]  [4 12; 8 16]

julia&gt; transpose(D) # ブロックは再帰的に転置されます
2×2 transpose(::Matrix{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:
 [1 2; 3 4]   [2 4; 6 8]
 [3 6; 9 12]  [4 8; 12 16]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/adjtrans.jl#L191-L276">source</a></section><section><div><pre><code class="language-julia hljs">transpose(F::Factorization)</code></pre><p>因子分解 <code>F</code> の遅延転置。デフォルトでは <a href="LinearAlgebra.html#LinearAlgebra.TransposeFactorization"><code>TransposeFactorization</code></a> を返しますが、実数の <code>eltype</code> を持つ <code>Factorization</code> の場合は <a href="LinearAlgebra.html#LinearAlgebra.AdjointFactorization"><code>AdjointFactorization</code></a> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/factorization.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.transpose!" href="#LinearAlgebra.transpose!"><code>LinearAlgebra.transpose!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti}) where {Tv,Ti}</code></pre><p>行列 <code>A</code> を転置し、行列 <code>X</code> に格納します。<code>size(X)</code> は <code>size(transpose(A))</code> と等しくなければなりません。必要に応じて、<code>X</code> の rowval と nzval のサイズ変更以外に追加のメモリは割り当てられません。</p><p><code>halfperm!</code> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1426-L1434">source</a></section><section><div><pre><code class="language-julia hljs">transpose!(dest,src)</code></pre><p>配列 <code>src</code> を転置し、その結果を事前に確保された配列 <code>dest</code> に格納します。<code>dest</code> のサイズは <code>(size(src,2),size(src,1))</code> に対応している必要があります。インプレースの転置はサポートされておらず、<code>src</code> と <code>dest</code> が重複するメモリ領域を持つ場合、予期しない結果が生じる可能性があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Matrix{Complex{Int64}}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; transpose!(B, A);

julia&gt; B
2×2 Matrix{Complex{Int64}}:
 3+2im  8+7im
 9+2im  4+6im

julia&gt; A
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 8+7im  4+6im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/transpose.jl#L8-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Transpose" href="#LinearAlgebra.Transpose"><code>LinearAlgebra.Transpose</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">転置</code></pre><p>基礎となる線形代数オブジェクト、通常は <code>AbstractVector</code>/<code>AbstractMatrix</code> の転置ビューのための遅延ラッパー型です。通常、<code>Transpose</code> コンストラクタは直接呼び出すべきではなく、代わりに <a href="LinearAlgebra.html#Base.transpose"><code>transpose</code></a> を使用してください。ビューを具現化するには <a href="../base/base.html#Base.copy"><code>copy</code></a> を使用します。</p><p>この型は線形代数の使用を意図しています - 一般的なデータ操作については <a href="../base/arrays.html#Base.permutedims"><code>permutedims</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [2 3; 0 0]
2×2 Matrix{Int64}:
 2  3
 0  0

julia&gt; Transpose(A)
2×2 transpose(::Matrix{Int64}) with eltype Int64:
 2  0
 3  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/adjtrans.jl#L35-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.TransposeFactorization" href="#LinearAlgebra.TransposeFactorization"><code>LinearAlgebra.TransposeFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransposeFactorization</code></pre><p>基になる <code>Factorization</code> オブジェクトの転置のための遅延ラッパー型です。通常、<code>TransposeFactorization</code> コンストラクタは直接呼び出すべきではなく、代わりに <a href="LinearAlgebra.html#Base.transpose"><code>transpose(:: Factorization)</code></a> を使用してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/factorization.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A&#39;
adjoint(A)</code></pre><p>遅延随伴（共役転置）。<code>adjoint</code>が要素に再帰的に適用されることに注意してください。</p><p>数値型の場合、<code>adjoint</code>は複素共役を返し、したがって実数に対しては恒等関数と同等です。</p><p>この操作は線形代数の使用を意図しています - 一般的なデータ操作については<a href="../base/arrays.html#Base.permutedims"><code>permutedims</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3+2im 9+2im; 0  0]
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 0+0im  0+0im

julia&gt; B = A&#39; # 同等に adjoint(A)
2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:
 3-2im  0+0im
 9-2im  0+0im

julia&gt; B isa Adjoint
true

julia&gt; adjoint(B) === A # 随伴の随伴は親を解きほぐす
true

julia&gt; Adjoint(B) # ただし、コンストラクタは常にその引数をラップします
2×2 adjoint(adjoint(::Matrix{Complex{Int64}})) with eltype Complex{Int64}:
 3+2im  9+2im
 0+0im  0+0im

julia&gt; B[1,2] = 4 + 5im; # Bを変更するとAも自動的に変更されます

julia&gt; A
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 4-5im  0+0im</code></pre><p>実数行列の場合、<code>adjoint</code>操作は<code>transpose</code>と同等です。</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape([x for x in 1:4], 2, 2)
2×2 Matrix{Int64}:
 1  3
 2  4

julia&gt; A&#39;
2×2 adjoint(::Matrix{Int64}) with eltype Int64:
 1  2
 3  4

julia&gt; adjoint(A) == transpose(A)
true</code></pre><p><code>AbstractVector</code>の随伴は行ベクトルです：</p><pre><code class="language-julia-repl hljs">julia&gt; x = [3, 4im]
2-element Vector{Complex{Int64}}:
 3 + 0im
 0 + 4im

julia&gt; x&#39;
1×2 adjoint(::Vector{Complex{Int64}}) with eltype Complex{Int64}:
 3+0im  0-4im

julia&gt; x&#39;x # 内積を計算します、同等に x&#39; * x
25 + 0im</code></pre><p>行列の行列の場合、個々のブロックは再帰的に操作されます：</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape([x + im*x for x in 1:4], 2, 2)
2×2 Matrix{Complex{Int64}}:
 1+1im  3+3im
 2+2im  4+4im

julia&gt; C = reshape([A, 2A, 3A, 4A], 2, 2)
2×2 Matrix{Matrix{Complex{Int64}}}:
 [1+1im 3+3im; 2+2im 4+4im]  [3+3im 9+9im; 6+6im 12+12im]
 [2+2im 6+6im; 4+4im 8+8im]  [4+4im 12+12im; 8+8im 16+16im]

julia&gt; C&#39;
2×2 adjoint(::Matrix{Matrix{Complex{Int64}}}) with eltype Adjoint{Complex{Int64}, Matrix{Complex{Int64}}}:
 [1-1im 2-2im; 3-3im 4-4im]    [2-2im 4-4im; 6-6im 8-8im]
 [3-3im 6-6im; 9-9im 12-12im]  [4-4im 8-8im; 12-12im 16-16im]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/adjtrans.jl#L95-L188">source</a></section><section><div><pre><code class="language-julia hljs">adjoint(F::Factorization)</code></pre><p>因子分解 <code>F</code> の遅延随伴。デフォルトでは、<a href="LinearAlgebra.html#LinearAlgebra.AdjointFactorization"><code>AdjointFactorization</code></a> ラッパーを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/factorization.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.adjoint!" href="#LinearAlgebra.adjoint!"><code>LinearAlgebra.adjoint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjoint!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti}) where {Tv,Ti}</code></pre><p>行列 <code>A</code> を転置し、行列 <code>X</code> の要素の随伴を格納します。<code>size(X)</code> は <code>size(transpose(A))</code> と等しくなければなりません。必要に応じて、<code>X</code> の rowval と nzval のサイズ変更以外に追加のメモリは割り当てられません。</p><p><code>halfperm!</code> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/242035184c0d539bdb5e64bf26eb7726b123db14/src/sparsematrix.jl#L1437-L1445">source</a></section><section><div><pre><code class="language-julia hljs">adjoint!(dest,src)</code></pre><p>共役転置配列 <code>src</code> を計算し、その結果を事前に確保された配列 <code>dest</code> に格納します。<code>dest</code> のサイズは <code>(size(src,2),size(src,1))</code> に対応している必要があります。インプレースの転置はサポートされておらず、<code>src</code> と <code>dest</code> が重複するメモリ領域を持つ場合、予期しない結果が生じる可能性があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Matrix{Complex{Int64}}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; adjoint!(B, A);

julia&gt; B
2×2 Matrix{Complex{Int64}}:
 3-2im  8-7im
 9-2im  4-6im

julia&gt; A
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 8+7im  4+6im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/transpose.jl#L43-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.Adjoint" href="#LinearAlgebra.Adjoint"><code>LinearAlgebra.Adjoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">随伴</code></pre><p>基になる線形代数オブジェクト、通常は <code>AbstractVector</code>/<code>AbstractMatrix</code> の随伴ビューのための遅延ラッパー型です。通常、<code>Adjoint</code> コンストラクタは直接呼び出すべきではなく、代わりに <a href="LinearAlgebra.html#Base.adjoint"><code>adjoint</code></a> を使用してください。ビューを具現化するには <a href="../base/base.html#Base.copy"><code>copy</code></a> を使用します。</p><p>この型は線形代数の使用を目的としています - 一般的なデータ操作については <a href="../base/arrays.html#Base.permutedims"><code>permutedims</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [3+2im 9+2im; 0 0]
2×2 Matrix{Complex{Int64}}:
 3+2im  9+2im
 0+0im  0+0im

julia&gt; Adjoint(A)
2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:
 3-2im  0+0im
 9-2im  0+0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/adjtrans.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.AdjointFactorization" href="#LinearAlgebra.AdjointFactorization"><code>LinearAlgebra.AdjointFactorization</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjointFactorization</code></pre><p>基になる <code>Factorization</code> オブジェクトの随伴のための遅延ラッパー型です。通常、<code>AdjointFactorization</code> コンストラクタは直接呼び出すべきではなく、代わりに <a href="LinearAlgebra.html#Base.adjoint"><code>adjoint(:: Factorization)</code></a> を使用してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/factorization.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{Union{Adjoint, Transpose}}" href="#Base.copy-Tuple{Union{Adjoint, Transpose}}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(A::Transpose)
copy(A::Adjoint)</code></pre><p>遅延行列の転置/随伴を即座に評価します。転置は要素に再帰的に適用されることに注意してください。</p><p>この操作は線形代数の使用を意図しています - 一般的なデータ操作については、再帰的でない<a href="../base/arrays.html#Base.permutedims"><code>permutedims</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2im; -3im 4]
2×2 Matrix{Complex{Int64}}:
 1+0im  0+2im
 0-3im  4+0im

julia&gt; T = transpose(A)
2×2 transpose(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:
 1+0im  0-3im
 0+2im  4+0im

julia&gt; copy(T)
2×2 Matrix{Complex{Int64}}:
 1+0im  0-3im
 0+2im  4+0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/transpose.jl#L153-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.stride1" href="#LinearAlgebra.stride1"><code>LinearAlgebra.stride1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stride1(A) -&gt; Int</code></pre><p>次元1における連続する配列要素間の距離を要素サイズの単位で返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1,2,3,4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; LinearAlgebra.stride1(A)
1

julia&gt; B = view(A, 2:2:4)
2-element view(::Vector{Int64}, 2:2:4) with eltype Int64:
 2
 4

julia&gt; LinearAlgebra.stride1(B)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L249-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.checksquare" href="#LinearAlgebra.checksquare"><code>LinearAlgebra.checksquare</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.checksquare(A)</code></pre><p>行列が正方行列であることを確認し、その共通の次元を返します。複数の引数がある場合は、ベクトルを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (4,4)); B = fill(1, (5,5));

julia&gt; LinearAlgebra.checksquare(A, B)
2-element Vector{Int64}:
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L284-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.peakflops" href="#LinearAlgebra.peakflops"><code>LinearAlgebra.peakflops</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearAlgebra.peakflops(n::Integer=4096; eltype::DataType=Float64, ntrials::Integer=3, parallel::Bool=false)</code></pre><p><code>peakflops</code>は、倍精度<a href="LinearAlgebra.html#LinearAlgebra.BLAS.gemm!"><code>gemm!</code></a>を使用してコンピュータのピークフロップレートを計算します。デフォルトでは、引数が指定されていない場合、サイズ<code>n x n</code>の2つの<code>Float64</code>行列を掛け算します。ここで、<code>n = 4096</code>です。基盤となるBLASが複数のスレッドを使用している場合、より高いフロップレートが実現されます。BLASスレッドの数は<a href="LinearAlgebra.html#LinearAlgebra.BLAS.set_num_threads"><code>BLAS.set_num_threads(n)</code></a>で設定できます。</p><p>キーワード引数<code>eltype</code>が指定されている場合、<code>peakflops</code>はピークフロップレートを計算するために<code>eltype</code>型の要素を持つ行列を構築します。</p><p>デフォルトでは、<code>peakflops</code>は3回の試行から最良のタイミングを使用します。<code>ntrials</code>キーワード引数が指定されている場合、<code>peakflops</code>はその数の試行を使用して最良のタイミングを選択します。</p><p>キーワード引数<code>parallel</code>が<code>true</code>に設定されている場合、<code>peakflops</code>はすべてのワーカープロセッサで並列に実行されます。全体の並列コンピュータのフロップレートが返されます。並列で実行する際は、1つのBLASスレッドのみが使用されます。引数<code>n</code>は、各プロセッサで解決される問題のサイズを指します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>この関数は少なくともJulia 1.1が必要です。Julia 1.0では、標準ライブラリ<code>InteractiveUtils</code>から利用可能です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L671-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.hermitianpart" href="#LinearAlgebra.hermitianpart"><code>LinearAlgebra.hermitianpart</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hermitianpart(A::AbstractMatrix, uplo::Symbol=:U) -&gt; Hermitian</code></pre><p>正方行列 <code>A</code> のエルミート部分を返します。これは <code>(A + A&#39;) / 2</code> と定義され、<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> 行列として返されます。実数行列 <code>A</code> に対しては、これは <code>A</code> の対称部分としても知られています。また、時には「演算子の実部」とも呼ばれます。オプションの引数 <code>uplo</code> は、<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian</code></a> ビューの対応する引数を制御します。実数行列の場合、後者は <a href="LinearAlgebra.html#LinearAlgebra.Symmetric"><code>Symmetric</code></a> ビューに相当します。</p><p>対応するインプレース操作については、<a href="LinearAlgebra.html#LinearAlgebra.hermitianpart!"><code>hermitianpart!</code></a> も参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.10</header><div class="admonition-body"><p>この関数は Julia 1.10 以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetric.jl#L848-L861">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.hermitianpart!" href="#LinearAlgebra.hermitianpart!"><code>LinearAlgebra.hermitianpart!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hermitianpart!(A::AbstractMatrix, uplo::Symbol=:U) -&gt; Hermitian</code></pre><p>正方行列 <code>A</code> をそのエルミート部分 <code>(A + A&#39;) / 2</code> でインプレースで上書きし、<a href="LinearAlgebra.html#LinearAlgebra.Hermitian"><code>Hermitian(A, uplo)</code></a> を返します。実数行列 <code>A</code> に対して、これは <code>A</code> の対称部分としても知られています。</p><p>対応するアウトオブプレース操作については、<a href="LinearAlgebra.html#LinearAlgebra.hermitianpart"><code>hermitianpart</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.10</header><div class="admonition-body"><p>この関数は Julia 1.10 以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/symmetric.jl#L864-L875">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.copy_adjoint!" href="#LinearAlgebra.copy_adjoint!"><code>LinearAlgebra.copy_adjoint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy_adjoint!(B::AbstractVecOrMat, ir_dest::AbstractRange{Int}, jr_dest::AbstractRange{Int},
                A::AbstractVecOrMat, ir_src::AbstractRange{Int}, jr_src::AbstractRange{Int}) -&gt; B</code></pre><p>行列 <code>A</code> の要素を随伴を用いて <code>B</code> に効率的にコピーします:</p><pre><code class="nohighlight hljs">B[ir_dest, jr_dest] = adjoint(A)[jr_src, ir_src]</code></pre><p>要素 <code>B[ir_dest, jr_dest]</code> は上書きされます。さらに、インデックス範囲のパラメータは <code>length(ir_dest) == length(jr_src)</code> および <code>length(jr_dest) == length(ir_src)</code> を満たす必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/transpose.jl#L202-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.copy_transpose!" href="#LinearAlgebra.copy_transpose!"><code>LinearAlgebra.copy_transpose!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy_transpose!(B::AbstractVecOrMat, ir_dest::AbstractRange{Int}, jr_dest::AbstractRange{Int},
                A::AbstractVecOrMat, ir_src::AbstractRange{Int}, jr_src::AbstractRange{Int}) -&gt; B</code></pre><p>行列 <code>A</code> の要素を転置しながら <code>B</code> に効率的にコピーします:</p><pre><code class="nohighlight hljs">B[ir_dest, jr_dest] = transpose(A)[jr_src, ir_src]</code></pre><p>要素 <code>B[ir_dest, jr_dest]</code> は上書きされます。さらに、インデックス範囲のパラメータは <code>length(ir_dest) == length(jr_src)</code> および <code>length(jr_dest) == length(ir_src)</code> を満たす必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/transpose.jl#L186-L197">source</a></section><section><div><pre><code class="language-julia hljs">copy_transpose!(B::AbstractMatrix, ir_dest::AbstractUnitRange, jr_dest::AbstractUnitRange,
                tM::AbstractChar,
                M::AbstractVecOrMat, ir_src::AbstractUnitRange, jr_src::AbstractUnitRange) -&gt; B</code></pre><p>行列 <code>M</code> の要素を、文字パラメータ <code>tM</code> に基づいて <code>B</code> に効率的にコピーします。以下のように条件付けられます：</p><table><tr><th style="text-align: right"><code>tM</code></th><th style="text-align: left">宛先</th><th style="text-align: left">ソース</th></tr><tr><td style="text-align: right"><code>&#39;N&#39;</code></td><td style="text-align: left"><code>B[ir_dest, jr_dest]</code></td><td style="text-align: left"><code>transpose(M)[jr_src, ir_src]</code></td></tr><tr><td style="text-align: right"><code>&#39;T&#39;</code></td><td style="text-align: left"><code>B[ir_dest, jr_dest]</code></td><td style="text-align: left"><code>M[jr_src, ir_src]</code></td></tr><tr><td style="text-align: right"><code>&#39;C&#39;</code></td><td style="text-align: left"><code>B[ir_dest, jr_dest]</code></td><td style="text-align: left"><code>conj(M)[jr_src, ir_src]</code></td></tr></table><p>要素 <code>B[ir_dest, jr_dest]</code> は上書きされます。さらに、インデックス範囲パラメータは <code>length(ir_dest) == length(jr_src)</code> および <code>length(jr_dest) == length(ir_src)</code> を満たす必要があります。</p><p>さらに <a href="../base/c.html#Base.copyto!"><code>copyto!</code></a> および <a href="LinearAlgebra.html#LinearAlgebra.copy_adjoint!"><code>copy_adjoint!</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L746-L765">source</a></section></article><h2 id="Low-level-matrix-operations"><a class="docs-heading-anchor" href="#Low-level-matrix-operations">Low-level matrix operations</a><a id="Low-level-matrix-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-matrix-operations" title="Permalink"></a></h2><p>多くの場合、事前に割り当てられた出力ベクトルや行列を提供できる行列演算のインプレースバージョンがあります。これは、繰り返しの割り当てのオーバーヘッドを回避するために、重要なコードを最適化する際に便利です。これらのインプレース操作は、通常のJuliaの慣例に従って、以下のように<code>!</code>で終わります（例：<code>mul!</code>）。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mul!(Y, A, B) -&gt; Y</code></pre><p>行列-行列または行列-ベクトルの積 <span>$A B$</span> を計算し、結果を <code>Y</code> に格納します。これは、既存の <code>Y</code> の値を上書きします。<code>Y</code> は <code>A</code> または <code>B</code> とエイリアスされてはいけません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0; 3.0 4.0]; B = [1.0 1.0; 1.0 1.0]; Y = similar(B);

julia&gt; mul!(Y, A, B) === Y
true

julia&gt; Y
2×2 Matrix{Float64}:
 3.0  3.0
 7.0  7.0

julia&gt; Y == A * B
true</code></pre><p><strong>実装</strong></p><p>カスタム行列およびベクトルタイプの場合、可能であれば3引数の <code>mul!</code> を直接実装するのではなく、5引数の <code>mul!</code> を実装することをお勧めします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L225-L252">source</a></section><section><div><pre><code class="language-julia hljs">mul!(C, A, B, α, β) -&gt; C</code></pre><p>行列-行列または行列-ベクトルの組み合わせのインプレース乗算加算 <span>$A B α + C β$</span>。結果は <code>C</code> に上書きされて保存されます。 <code>C</code> は <code>A</code> または <code>B</code> とエイリアスされてはいけません。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>五引数の <code>mul!</code> は少なくとも Julia 1.3 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0; 3.0 4.0]; B = [1.0 1.0; 1.0 1.0]; C = [1.0 2.0; 3.0 4.0];

julia&gt; α, β = 100.0, 10.0;

julia&gt; mul!(C, A, B, α, β) === C
true

julia&gt; C
2×2 Matrix{Float64}:
 310.0  320.0
 730.0  740.0

julia&gt; C_original = [1.0 2.0; 3.0 4.0]; # C の元の値のコピー

julia&gt; C == A * B * α + C_original * β
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L255-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lmul!" href="#LinearAlgebra.lmul!"><code>LinearAlgebra.lmul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lmul!(a::Number, B::AbstractArray)</code></pre><p>スカラー <code>a</code> で配列 <code>B</code> をスケーリングし、<code>B</code> をその場で上書きします。スカラーを右から掛けるには <a href="LinearAlgebra.html#LinearAlgebra.rmul!"><code>rmul!</code></a> を使用してください。スケーリング操作は、<code>a</code> と <code>B</code> の要素との間の乗算 <a href="../base/math.html#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a> の意味論を尊重します。特に、これは <code>NaN</code> や <code>±Inf</code> のような非有限数を含む乗算にも適用されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Julia 1.1 より前は、<code>B</code> の <code>NaN</code> および <code>±Inf</code> エントリは一貫性がなく扱われていました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; lmul!(2, B)
2×2 Matrix{Int64}:
 2  4
 6  8

julia&gt; lmul!(0.0, [Inf])
1-element Vector{Float64}:
 NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L195-L224">source</a></section><section><div><pre><code class="language-julia hljs">lmul!(A, B)</code></pre><p>行列の積 <span>$AB$</span> を計算し、<code>B</code> を上書きして結果を返します。ここで、<code>A</code> は特別な行列タイプでなければなりません。例えば、<a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a>、または <a href="LinearAlgebra.html#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a> のような、あるいは <a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = [0 1; 1 0];

julia&gt; A = UpperTriangular([1 2; 0 3]);

julia&gt; lmul!(A, B);

julia&gt; B
2×2 Matrix{Int64}:
 2  1
 3  0

julia&gt; B = [1.0 2.0; 3.0 4.0];

julia&gt; F = qr([0 1; -1 0]);

julia&gt; lmul!(F.Q, B)
2×2 Matrix{Float64}:
 3.0  4.0
 1.0  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L330-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rmul!" href="#LinearAlgebra.rmul!"><code>LinearAlgebra.rmul!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rmul!(A::AbstractArray, b::Number)</code></pre><p>スカラー <code>b</code> で配列 <code>A</code> をスケーリングし、<code>A</code> をその場で上書きします。スカラーを左から掛けるには <a href="LinearAlgebra.html#LinearAlgebra.lmul!"><code>lmul!</code></a> を使用してください。スケーリング操作は、<code>A</code> の要素と <code>b</code> の間の乗算 <a href="../base/math.html#Base.:*-Tuple{Any, Vararg{Any}}"><code>*</code></a> の意味論を尊重します。特に、これは <code>NaN</code> や <code>±Inf</code> のような非有限数を含む乗算にも適用されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Julia 1.1 より前は、<code>A</code> の <code>NaN</code> および <code>±Inf</code> エントリは一貫性がなく扱われていました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rmul!(A, 2)
2×2 Matrix{Int64}:
 2  4
 6  8

julia&gt; rmul!([NaN], 0.0)
1-element Vector{Float64}:
 NaN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L157-L186">source</a></section><section><div><pre><code class="language-julia hljs">rmul!(A, B)</code></pre><p>行列の積 <span>$AB$</span> を計算し、<code>A</code> を上書きして結果を返します。ここで、<code>B</code> は特別な行列タイプでなければなりません。例えば、<a href="LinearAlgebra.html#LinearAlgebra.Diagonal"><code>Diagonal</code></a>、<a href="LinearAlgebra.html#LinearAlgebra.UpperTriangular"><code>UpperTriangular</code></a> または <a href="LinearAlgebra.html#LinearAlgebra.LowerTriangular"><code>LowerTriangular</code></a> のような、または <a href="LinearAlgebra.html#LinearAlgebra.QR"><code>QR</code></a> のような何らかの直交タイプです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [0 1; 1 0];

julia&gt; B = UpperTriangular([1 2; 0 3]);

julia&gt; rmul!(A, B);

julia&gt; A
2×2 Matrix{Int64}:
 0  3
 1  2

julia&gt; A = [1.0 2.0; 3.0 4.0];

julia&gt; F = qr([0 1; -1 0]);

julia&gt; rmul!(A, F.Q)
2×2 Matrix{Float64}:
 2.0  1.0
 4.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/matmul.jl#L297-L327">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.ldiv!" href="#LinearAlgebra.ldiv!"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldiv!(Y, A, B) -&gt; Y</code></pre><p><code>A \ B</code> をインプレースで計算し、結果を <code>Y</code> に格納して返します。</p><p>引数 <code>A</code> は <em>行列</em> であってはなりません。むしろ、行列の代わりに因子分解オブジェクト（例えば、<a href="LinearAlgebra.html#LinearAlgebra.factorize"><code>factorize</code></a> や <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> によって生成されたもの）である必要があります。これは、因子分解自体が高コストであり、通常はメモリを割り当てるためです（ただし、<a href="LinearAlgebra.html#LinearAlgebra.lu!"><code>lu!</code></a> などを介してインプレースで行うことも可能です）。<code>ldiv!</code> を必要とするパフォーマンスクリティカルな状況では、通常、<code>A</code> の因子分解に対する細かい制御も必要です。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Diagonal</code> や <code>UpperTriangular</code> のような特定の構造化行列タイプは許可されています。これらはすでに因子化された形になっています。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = zero(X);

julia&gt; ldiv!(Y, qr(A), X);

julia&gt; Y ≈ A\X
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L337-L366">source</a></section><section><div><pre><code class="language-julia hljs">ldiv!(A, B)</code></pre><p><code>A \ B</code> をインプレースで計算し、結果を <code>B</code> に上書きします。</p><p>引数 <code>A</code> は <em>行列</em> であってはなりません。むしろ、行列の代わりに因子分解オブジェクト（例えば、<a href="LinearAlgebra.html#LinearAlgebra.factorize"><code>factorize</code></a> や <a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a> によって生成されたもの）であるべきです。これは、因子分解自体が高コストであり、通常はメモリを割り当てるためです（ただし、例えば <a href="LinearAlgebra.html#LinearAlgebra.lu!"><code>lu!</code></a> を介してインプレースで行うことも可能です）。<code>ldiv!</code> を必要とするパフォーマンスクリティカルな状況では、通常、<code>A</code> の因子分解に対する細かい制御も必要です。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Diagonal</code> や <code>UpperTriangular</code> のような特定の構造化行列タイプは許可されています。これらはすでに因子化された形になっています。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = copy(X);

julia&gt; ldiv!(qr(A), X);

julia&gt; X ≈ A\Y
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L369-L398">source</a></section><section><div><pre><code class="language-julia hljs">ldiv!(a::Number, B::AbstractArray)</code></pre><p>スカラー <code>a</code> で配列 <code>B</code> の各エントリを割り算し、<code>B</code> をその場で上書きします。スカラーを右から割るには <a href="LinearAlgebra.html#LinearAlgebra.rdiv!"><code>rdiv!</code></a> を使用してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = [1.0 2.0; 3.0 4.0]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; ldiv!(2.0, B)
2×2 Matrix{Float64}:
 0.5  1.0
 1.5  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L258-L276">source</a></section><section><div><pre><code class="language-julia hljs">ldiv!(A::Tridiagonal, B::AbstractVecOrMat) -&gt; B</code></pre><p><code>A \ B</code>をガウス消去法による部分ピボットを用いてインプレースで計算し、結果を<code>B</code>に格納して返します。この過程で、<code>A</code>の対角成分も上書きされます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>Tridiagonal</code>の左辺に対する<code>ldiv!</code>は、少なくともJulia 1.11が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/tridiag.jl#L919-L927">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.rdiv!" href="#LinearAlgebra.rdiv!"><code>LinearAlgebra.rdiv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rdiv!(A, B)</code></pre><p><code>A / B</code>をインプレースで計算し、結果を格納するために<code>A</code>を上書きします。</p><p>引数<code>B</code>は<em>行列</em>であってはなりません。むしろ、行列の代わりに因子分解オブジェクト（例えば、<a href="LinearAlgebra.html#LinearAlgebra.factorize"><code>factorize</code></a>や<a href="LinearAlgebra.html#LinearAlgebra.cholesky"><code>cholesky</code></a>によって生成されたもの）である必要があります。これは、因子分解自体が高コストであり、通常はメモリを割り当てるためです（ただし、例えば<a href="LinearAlgebra.html#LinearAlgebra.lu!"><code>lu!</code></a>を介してインプレースで行うことも可能です）。<code>rdiv!</code>を必要とするパフォーマンスクリティカルな状況では、通常、<code>B</code>の因子分解に対する細かい制御も必要です。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Diagonal</code>や<code>UpperTriangular</code>のような特定の構造化行列タイプは許可されています。これらはすでに因子化された形であるためです。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/LinearAlgebra.jl#L402-L417">source</a></section><section><div><pre><code class="language-julia hljs">rdiv!(A::AbstractArray, b::Number)</code></pre><p>配列 <code>A</code> の各エントリをスカラー <code>b</code> で割り、<code>A</code> をその場で上書きします。スカラーを左から割るには <a href="LinearAlgebra.html#LinearAlgebra.ldiv!"><code>ldiv!</code></a> を使用してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2.0; 3.0 4.0]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; rdiv!(A, 2.0)
2×2 Matrix{Float64}:
 0.5  1.0
 1.5  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/generic.jl#L232-L250">source</a></section></article><h2 id="BLAS-functions"><a class="docs-heading-anchor" href="#BLAS-functions">BLAS functions</a><a id="BLAS-functions-1"></a><a class="docs-heading-anchor-permalink" href="#BLAS-functions" title="Permalink"></a></h2><p>ジュリア（多くの科学計算と同様に）では、密な線形代数操作は <a href="https://www.netlib.org/lapack/">LAPACK library</a> に基づいており、これは基本的な線形代数のビルディングブロックである <a href="https://www.netlib.org/blas/">BLAS</a> の上に構築されています。すべてのコンピュータアーキテクチャに対して利用可能な高度に最適化されたBLASの実装があり、高性能な線形代数ルーチンではBLAS関数を直接呼び出すことが有用な場合があります。</p><p><code>LinearAlgebra.BLAS</code> は、いくつかの BLAS 関数のラッパーを提供します。入力配列のいずれかを上書きする BLAS 関数は、名前が <code>&#39;!&#39;</code> で終わります。通常、BLAS 関数には、<a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>、<a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>、<a href="../base/numbers.html#Base.Complex"><code>ComplexF32</code></a>、および <a href="../base/numbers.html#Base.Complex"><code>ComplexF64</code></a> 配列に対して4つのメソッドが定義されています。</p><h3 id="stdlib-blas-chars"><a class="docs-heading-anchor" href="#stdlib-blas-chars">BLAS character arguments</a><a id="stdlib-blas-chars-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-blas-chars" title="Permalink"></a></h3><p>多くのBLAS関数は、引数が転置されるかどうかを決定する引数（<code>trans</code>）、行列のどの三角形を参照するかを決定する引数（<code>uplo</code>または<code>ul</code>）、三角行列の対角線がすべて1であると仮定できるかどうかを決定する引数（<code>dA</code>）、および行列の乗算のどの側に入力引数が属するかを決定する引数（<code>side</code>）を受け入れます。可能性は次のとおりです：</p><h4 id="stdlib-blas-side"><a class="docs-heading-anchor" href="#stdlib-blas-side">Multiplication order</a><a id="stdlib-blas-side-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-blas-side" title="Permalink"></a></h4><table><tr><th style="text-align: left"><code>side</code></th><th style="text-align: left">Meaning</th></tr><tr><td style="text-align: left"><code>&#39;L&#39;</code></td><td style="text-align: left">The argument goes on the <em>left</em> side of a matrix-matrix operation.</td></tr><tr><td style="text-align: left"><code>&#39;R&#39;</code></td><td style="text-align: left">The argument goes on the <em>right</em> side of a matrix-matrix operation.</td></tr></table><h4 id="stdlib-blas-uplo"><a class="docs-heading-anchor" href="#stdlib-blas-uplo">Triangle referencing</a><a id="stdlib-blas-uplo-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-blas-uplo" title="Permalink"></a></h4><table><tr><th style="text-align: left"><code>uplo</code>/<code>ul</code></th><th style="text-align: left">Meaning</th></tr><tr><td style="text-align: left"><code>&#39;U&#39;</code></td><td style="text-align: left">Only the <em>upper</em> triangle of the matrix will be used.</td></tr><tr><td style="text-align: left"><code>&#39;L&#39;</code></td><td style="text-align: left">Only the <em>lower</em> triangle of the matrix will be used.</td></tr></table><h4 id="stdlib-blas-trans"><a class="docs-heading-anchor" href="#stdlib-blas-trans">Transposition operation</a><a id="stdlib-blas-trans-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-blas-trans" title="Permalink"></a></h4><table><tr><th style="text-align: left"><code>trans</code>/<code>tX</code></th><th style="text-align: left">Meaning</th></tr><tr><td style="text-align: left"><code>&#39;N&#39;</code></td><td style="text-align: left">The input matrix <code>X</code> is not transposed or conjugated.</td></tr><tr><td style="text-align: left"><code>&#39;T&#39;</code></td><td style="text-align: left">The input matrix <code>X</code> will be transposed.</td></tr><tr><td style="text-align: left"><code>&#39;C&#39;</code></td><td style="text-align: left">The input matrix <code>X</code> will be conjugated and transposed.</td></tr></table><h4 id="stdlib-blas-diag"><a class="docs-heading-anchor" href="#stdlib-blas-diag">Unit diagonal</a><a id="stdlib-blas-diag-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-blas-diag" title="Permalink"></a></h4><table><tr><th style="text-align: left"><code>diag</code>/<code>dX</code></th><th style="text-align: left">Meaning</th></tr><tr><td style="text-align: left"><code>&#39;N&#39;</code></td><td style="text-align: left">The diagonal values of the matrix <code>X</code> will be read.</td></tr><tr><td style="text-align: left"><code>&#39;U&#39;</code></td><td style="text-align: left">The diagonal of the matrix <code>X</code> is assumed to be all ones.</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS" href="#LinearAlgebra.BLAS"><code>LinearAlgebra.BLAS</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>BLASサブルーチンへのインターフェース。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.set_num_threads" href="#LinearAlgebra.BLAS.set_num_threads"><code>LinearAlgebra.BLAS.set_num_threads</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_num_threads(n::Integer)
set_num_threads(::Nothing)</code></pre><p>BLASライブラリが使用するスレッドの数を<code>n::Integer</code>に設定します。</p><p>また、<code>nothing</code>を受け入れます。この場合、juliaはデフォルトのスレッド数を推測しようとします。<code>nothing</code>を渡すことは推奨されず、主に歴史的な理由から存在します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.get_num_threads" href="#LinearAlgebra.BLAS.get_num_threads"><code>LinearAlgebra.BLAS.get_num_threads</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_threads()</code></pre><p>BLASライブラリが使用しているスレッドの数を取得します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>get_num_threads</code>は少なくともJulia 1.6が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L144-L151">source</a></section></article><p>BLAS関数は、最初に提案された時期、入力パラメータの種類、および操作の複雑さに応じて、3つのグループ、つまり3つのレベルに分けることができます。</p><h3 id="Level-1-BLAS-functions"><a class="docs-heading-anchor" href="#Level-1-BLAS-functions">Level 1 BLAS functions</a><a id="Level-1-BLAS-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Level-1-BLAS-functions" title="Permalink"></a></h3><p>レベル1 BLAS関数は[(Lawson, 1979)][Lawson-1979]で初めて提案され、スカラーとベクトルの間の演算を定義します。</p><p>[Lawson-1979]: https://dl.acm.org/doi/10.1145/355841.355847</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.rot!" href="#LinearAlgebra.BLAS.rot!"><code>LinearAlgebra.BLAS.rot!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rot!(n, X, incx, Y, incy, c, s)</code></pre><p><code>X</code>を<code>c*X + s*Y</code>で上書きし、<code>Y</code>を<code>-conj(s)*X + c*Y</code>で上書きします。これは、ストライド<code>incx</code>を持つ配列<code>X</code>の最初の<code>n</code>要素と、ストライド<code>incy</code>を持つ配列<code>Y</code>の最初の<code>n</code>要素に対して行われます。<code>X</code>と<code>Y</code>を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>rot!</code>は少なくともJulia 1.5が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L220-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.scal!" href="#LinearAlgebra.BLAS.scal!"><code>LinearAlgebra.BLAS.scal!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scal!(n, a, X, incx)
scal!(a, X)</code></pre><p>配列 <code>X</code> の最初の <code>n</code> 要素を <code>a*X</code> で上書きします。ストライドは <code>incx</code> です。<code>X</code> を返します。</p><p><code>n</code> と <code>incx</code> が指定されていない場合、<code>length(X)</code> と <code>stride(X,1)</code> が使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L250-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.scal" href="#LinearAlgebra.BLAS.scal"><code>LinearAlgebra.BLAS.scal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scal(n, a, X, incx)
scal(a, X)</code></pre><p>配列 <code>X</code> の最初の <code>n</code> 要素をストライド <code>incx</code> で <code>a</code> でスケーリングします。</p><p><code>n</code> と <code>incx</code> が指定されていない場合は、<code>length(X)</code> と <code>stride(X,1)</code> が使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L260-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.blascopy!" href="#LinearAlgebra.BLAS.blascopy!"><code>LinearAlgebra.BLAS.blascopy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blascopy!(n, X, incx, Y, incy)</code></pre><p>配列 <code>X</code> の <code>n</code> 要素をストライド <code>incx</code> で配列 <code>Y</code> にストライド <code>incy</code> でコピーします。<code>Y</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.dot" href="#LinearAlgebra.BLAS.dot"><code>LinearAlgebra.BLAS.dot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(n, X, incx, Y, incy)</code></pre><p><code>incx</code>のストライドを持つ配列<code>X</code>の<code>n</code>要素と、<code>incy</code>のストライドを持つ配列<code>Y</code>の<code>n</code>要素からなる2つのベクトルのドット積。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BLAS.dot(10, fill(1.0, 10), 1, fill(1.0, 20), 2)
10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L295-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.dotu" href="#LinearAlgebra.BLAS.dotu"><code>LinearAlgebra.BLAS.dotu</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dotu(n, X, incx, Y, incy)</code></pre><p>複素ベクトルの2つのドット関数で、配列 <code>X</code> の <code>n</code> 要素とストライド <code>incx</code>、配列 <code>Y</code> の <code>n</code> 要素とストライド <code>incy</code> から構成されています。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BLAS.dotu(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
-10.0 + 10.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L324-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.dotc" href="#LinearAlgebra.BLAS.dotc"><code>LinearAlgebra.BLAS.dotc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dotc(n, X, incx, U, incy)</code></pre><p>2つの複素ベクトルのためのドット関数で、ストライド <code>incx</code> を持つ配列 <code>X</code> の <code>n</code> 要素と、ストライド <code>incy</code> を持つ配列 <code>U</code> の <code>n</code> 要素から成り、最初のベクトルを共役にします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BLAS.dotc(10, fill(1.0im, 10), 1, fill(1.0+im, 20), 2)
10.0 - 10.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L309-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.nrm2" href="#LinearAlgebra.BLAS.nrm2"><code>LinearAlgebra.BLAS.nrm2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nrm2(n, X, incx)</code></pre><p>配列 <code>X</code> の <code>n</code> 要素からなるベクトルの 2-ノルムで、ストライドは <code>incx</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BLAS.nrm2(4, fill(1.0, 8), 2)
2.0

julia&gt; BLAS.nrm2(1, fill(1.0, 8), 2)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L405-L418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.asum" href="#LinearAlgebra.BLAS.asum"><code>LinearAlgebra.BLAS.asum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asum(n, X, incx)</code></pre><p>配列 <code>X</code> の最初の <code>n</code> 要素の絶対値の合計を、ストライド <code>incx</code> で計算します。</p><p>実数配列の場合、絶対値はそのままの値です。複素数配列の場合、絶対値は実部の絶対値と虚部の絶対値の合計です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BLAS.asum(5, fill(1.0im, 10), 2)
5.0

julia&gt; BLAS.asum(2, fill(1.0im, 10), 5)
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L442-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.iamax" href="#LinearAlgebra.BLAS.iamax"><code>LinearAlgebra.BLAS.iamax</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iamax(n, dx, incx)
iamax(dx)</code></pre><p><code>dx</code>の最大絶対値を持つ要素のインデックスを見つけます。<code>n</code>は<code>dx</code>の長さで、<code>incx</code>はストライドです。<code>n</code>と<code>incx</code>が指定されていない場合、デフォルト値<code>n=length(dx)</code>および<code>incx=stride1(dx)</code>が仮定されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L622-L628">source</a></section></article><h3 id="Level-2-BLAS-functions"><a class="docs-heading-anchor" href="#Level-2-BLAS-functions">Level 2 BLAS functions</a><a id="Level-2-BLAS-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Level-2-BLAS-functions" title="Permalink"></a></h3><p>レベル2 BLAS関数は[(Dongarra, 1988)][Dongarra-1988]で発表され、行列-ベクトル演算を定義しています。</p><p>[Dongarra-1988]: https://dl.acm.org/doi/10.1145/42288.42291</p><p><strong>ベクトルを返す</strong></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemv!" href="#LinearAlgebra.BLAS.gemv!"><code>LinearAlgebra.BLAS.gemv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemv!(tA, alpha, A, x, beta, y)</code></pre><p>ベクトル <code>y</code> を <code>alpha*A*x + beta*y</code> または <code>alpha*A&#39;x + beta*y</code> に更新します <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>。<code>alpha</code> と <code>beta</code> はスカラーです。更新された <code>y</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L688-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemv-NTuple{4, Any}" href="#LinearAlgebra.BLAS.gemv-NTuple{4, Any}"><code>LinearAlgebra.BLAS.gemv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemv(tA, alpha, A, x)</code></pre><p><code>alpha*A*x</code> または <code>alpha*A&#39;x</code> を <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> に従って返します。<code>alpha</code> はスカラーです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L697-L702">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemv-Tuple{Any, Any, Any}" href="#LinearAlgebra.BLAS.gemv-Tuple{Any, Any, Any}"><code>LinearAlgebra.BLAS.gemv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemv(tA, A, x)</code></pre><p><code>A*x</code> または <code>A&#39;x</code> を <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> に従って返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L705-L709">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gbmv!" href="#LinearAlgebra.BLAS.gbmv!"><code>LinearAlgebra.BLAS.gbmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gbmv!(trans, m, kl, ku, alpha, A, x, beta, y)</code></pre><p>ベクトル <code>y</code> を <code>alpha*A*x + beta*y</code> または <code>alpha*A&#39;*x + beta*y</code> に更新します。これは <a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従います。行列 <code>A</code> は、<code>kl</code> の下対角線と <code>ku</code> の上対角線を持つ、次元 <code>m</code> と <code>size(A,2)</code> の一般的なバンド行列です。<code>alpha</code> と <code>beta</code> はスカラーです。更新された <code>y</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L714-L720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gbmv" href="#LinearAlgebra.BLAS.gbmv"><code>LinearAlgebra.BLAS.gbmv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gbmv(trans, m, kl, ku, alpha, A, x)</code></pre><p><code>alpha*A*x</code> または <code>alpha*A&#39;*x</code> を <a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従って返します。行列 <code>A</code> は、<code>kl</code> の下三角成分と <code>ku</code> の上三角成分を持つ、次元 <code>m</code> と <code>size(A,2)</code> の一般的なバンド行列であり、<code>alpha</code> はスカラーです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L723-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hemv!" href="#LinearAlgebra.BLAS.hemv!"><code>LinearAlgebra.BLAS.hemv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hemv!(ul, alpha, A, x, beta, y)</code></pre><p>ベクトル <code>y</code> を <code>alpha*A*x + beta*y</code> として更新します。<code>A</code> はエルミート行列であると仮定します。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。<code>alpha</code> と <code>beta</code> はスカラーです。更新された <code>y</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L851-L857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hemv-NTuple{4, Any}" href="#LinearAlgebra.BLAS.hemv-NTuple{4, Any}"><code>LinearAlgebra.BLAS.hemv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hemv(ul, alpha, A, x)</code></pre><p>返す <code>alpha*A*x</code>。<code>A</code> はエルミート行列であると仮定されます。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角部分のみが使用されます。<code>alpha</code> はスカラーです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L898-L904">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hemv-Tuple{Any, Any, Any}" href="#LinearAlgebra.BLAS.hemv-Tuple{Any, Any, Any}"><code>LinearAlgebra.BLAS.hemv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hemv(ul, A, x)</code></pre><p><code>A*x</code>を返します。<code>A</code>はエルミート行列であると仮定されます。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角部分のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L907-L912">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hpmv!" href="#LinearAlgebra.BLAS.hpmv!"><code>LinearAlgebra.BLAS.hpmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hpmv!(uplo, α, AP, x, β, y)</code></pre><p>ベクトル <code>y</code> を <code>α*A*x + β*y</code> として更新します。ここで、<code>A</code> はパック形式 <code>AP</code> で提供されるエルミート行列です。</p><p><code>uplo = &#39;U&#39;</code> の場合、配列 AP はエルミート行列の上三角部分を列ごとに順番に格納している必要があります。したがって、<code>AP[1]</code> には <code>A[1, 1]</code> が含まれ、<code>AP[2]</code> と <code>AP[3]</code> にはそれぞれ <code>A[1, 2]</code> と <code>A[2, 2]</code> が含まれます。</p><p><code>uplo = &#39;L&#39;</code> の場合、配列 AP はエルミート行列の下三角部分を列ごとに順番に格納している必要があります。したがって、<code>AP[1]</code> には <code>A[1, 1]</code> が含まれ、<code>AP[2]</code> と <code>AP[3]</code> にはそれぞれ <code>A[2, 1]</code> と <code>A[3, 1]</code> が含まれます。</p><p>スカラー入力 <code>α</code> と <code>β</code> は複素数または実数でなければなりません。</p><p>配列入力 <code>x</code>、<code>y</code> および <code>AP</code> はすべて <code>ComplexF32</code> または <code>ComplexF64</code> 型でなければなりません。</p><p>更新された <code>y</code> を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>hpmv!</code> は少なくとも Julia 1.5 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L981-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.symv!" href="#LinearAlgebra.BLAS.symv!"><code>LinearAlgebra.BLAS.symv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symv!(ul, alpha, A, x, beta, y)</code></pre><p>ベクトル <code>y</code> を <code>alpha*A*x + beta*y</code> として更新します。<code>A</code> は対称であると仮定されます。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。<code>alpha</code> と <code>beta</code> はスカラーです。更新された <code>y</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L775-L781">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.symv-NTuple{4, Any}" href="#LinearAlgebra.BLAS.symv-NTuple{4, Any}"><code>LinearAlgebra.BLAS.symv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symv(ul, alpha, A, x)</code></pre><p>返す <code>alpha*A*x</code>。<code>A</code> は対称であると仮定されます。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。<code>alpha</code> はスカラーです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L833-L839">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.symv-Tuple{Any, Any, Any}" href="#LinearAlgebra.BLAS.symv-Tuple{Any, Any, Any}"><code>LinearAlgebra.BLAS.symv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symv(ul, A, x)</code></pre><p><code>A*x</code>を返します。<code>A</code>は対称であると仮定されます。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L842-L847">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.sbmv!" href="#LinearAlgebra.BLAS.sbmv!"><code>LinearAlgebra.BLAS.sbmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sbmv!(uplo, k, alpha, A, x, beta, y)</code></pre><p>ベクトル <code>y</code> を <code>alpha*A*x + beta*y</code> として更新します。ここで、<code>A</code> は引数 <code>A</code> に格納された <code>k</code> 個の上対角線を持つ対称バンド行列で、次数は <code>size(A,2)</code> です。<code>A</code> のストレージレイアウトは、<a href="https://www.netlib.org/lapack/explore-html/">https://www.netlib.org/lapack/explore-html/</a> の参照 BLAS モジュール、レベル-2 BLAS で説明されています。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> 三角形のみが使用されます。</p><p>更新された <code>y</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1062-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.sbmv-NTuple{5, Any}" href="#LinearAlgebra.BLAS.sbmv-NTuple{5, Any}"><code>LinearAlgebra.BLAS.sbmv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sbmv(uplo, k, alpha, A, x)</code></pre><p><code>alpha*A*x</code>を返します。ここで、<code>A</code>は引数<code>A</code>に格納された<code>k</code>の上部対角線を持つ順序<code>size(A,2)</code>の対称バンド行列です。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a>三角形のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1044-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.sbmv-NTuple{4, Any}" href="#LinearAlgebra.BLAS.sbmv-NTuple{4, Any}"><code>LinearAlgebra.BLAS.sbmv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sbmv(uplo, k, A, x)</code></pre><p><code>A*x</code>を返します。ここで、<code>A</code>は引数<code>A</code>に格納された<code>k</code>個の上対角線を持つ順対称バンド行列で、順序は<code>size(A,2)</code>です。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a>三角形のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1053-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.spmv!" href="#LinearAlgebra.BLAS.spmv!"><code>LinearAlgebra.BLAS.spmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spmv!(uplo, α, AP, x, β, y)</code></pre><p>ベクトル <code>y</code> を <code>α*A*x + β*y</code> として更新します。ここで、<code>A</code> はパック形式 <code>AP</code> で提供される対称行列です。</p><p><code>uplo = &#39;U&#39;</code> の場合、配列 AP は対称行列の上三角部分を列ごとに順番に含む必要があります。したがって、<code>AP[1]</code> には <code>A[1, 1]</code> が含まれ、<code>AP[2]</code> と <code>AP[3]</code> にはそれぞれ <code>A[1, 2]</code> と <code>A[2, 2]</code> が含まれます。</p><p><code>uplo = &#39;L&#39;</code> の場合、配列 AP は対称行列の下三角部分を列ごとに順番に含む必要があります。したがって、<code>AP[1]</code> には <code>A[1, 1]</code> が含まれ、<code>AP[2]</code> と <code>AP[3]</code> にはそれぞれ <code>A[2, 1]</code> と <code>A[3, 1]</code> が含まれます。</p><p>スカラー入力 <code>α</code> と <code>β</code> は実数でなければなりません。</p><p>配列入力 <code>x</code>、<code>y</code> および <code>AP</code> はすべて <code>Float32</code> または <code>Float64</code> 型でなければなりません。</p><p>更新された <code>y</code> を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>spmv!</code> は少なくとも Julia 1.5 を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1141-L1165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trmv!" href="#LinearAlgebra.BLAS.trmv!"><code>LinearAlgebra.BLAS.trmv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trmv!(ul, tA, dA, A, b)</code></pre><p><code>op(A)*b</code>を返します。ここで、<code>op</code>は<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>によって決定されます。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a>は対角値が読み取られるか、すべて1であると仮定されるかを決定します。乗算は<code>b</code>に対してインプレースで行われます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1287-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trmv" href="#LinearAlgebra.BLAS.trmv"><code>LinearAlgebra.BLAS.trmv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trmv(ul, tA, dA, A, b)</code></pre><p><code>op(A)*b</code>を返します。ここで、<code>op</code>は<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>によって決定されます。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a>は、対角値が読み取られるか、すべて1であると仮定されるかを決定します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1277-L1284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trsv!" href="#LinearAlgebra.BLAS.trsv!"><code>LinearAlgebra.BLAS.trsv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trsv!(ul, tA, dA, A, b)</code></pre><p><code>b</code>を<code>A*x = b</code>の解で上書きするか、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>および<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>によって決定される他の2つのバリアントのいずれかで上書きします。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a>は対角値が読み取られるか、すべて1であると仮定されるかを決定します。更新された<code>b</code>を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1334-L1342">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trsv" href="#LinearAlgebra.BLAS.trsv"><code>LinearAlgebra.BLAS.trsv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trsv(ul, tA, dA, A, b)</code></pre><p><code>A*x = b</code> の解を返すか、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> と <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> によって決定される他の2つのバリアントのいずれかを返します。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a> は対角値が読み取られるか、すべて1であると仮定されるかを決定します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1345-L1352">source</a></section></article><p><strong>行列を返す</strong></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.ger!" href="#LinearAlgebra.BLAS.ger!"><code>LinearAlgebra.BLAS.ger!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ger!(alpha, x, y, A)</code></pre><p>ベクトル <code>x</code> と <code>y</code> を用いて行列 <code>A</code> のランク-1 更新を行います。式は <code>alpha*x*y&#39; + A</code> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1391-L1395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.her!" href="#LinearAlgebra.BLAS.her!"><code>LinearAlgebra.BLAS.her!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">her!(uplo, alpha, x, A)</code></pre><p>複素配列専用のメソッド。ベクトル <code>x</code> を用いてエルミート行列 <code>A</code> のランク1更新を行います。更新は <code>alpha*x*x&#39; + A</code> です。<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> は <code>A</code> のどちらの三角形が更新されるかを制御します。<code>A</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1490-L1496">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.syr!" href="#LinearAlgebra.BLAS.syr!"><code>LinearAlgebra.BLAS.syr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syr!(uplo, alpha, x, A)</code></pre><p>ベクトル <code>x</code> を用いて対称行列 <code>A</code> のランク1更新を行います。これは <code>alpha*x*transpose(x) + A</code> です。<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> は <code>A</code> のどちらの三角形が更新されるかを制御します。<code>A</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1458-L1463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.spr!" href="#LinearAlgebra.BLAS.spr!"><code>LinearAlgebra.BLAS.spr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spr!(uplo, α, x, AP)</code></pre><p>行列 <code>A</code> を <code>A+α*x*x&#39;</code> として更新します。ここで、<code>A</code> はパック形式の対称行列であり、<code>x</code> はベクトルです。</p><p><code>uplo = &#39;U&#39;</code> の場合、配列 AP は対称行列の上三角部分を列ごとに順番に格納している必要があります。したがって、<code>AP[1]</code> には <code>A[1, 1]</code> が含まれ、<code>AP[2]</code> と <code>AP[3]</code> にはそれぞれ <code>A[1, 2]</code> と <code>A[2, 2]</code> が含まれます。</p><p><code>uplo = &#39;L&#39;</code> の場合、配列 AP は対称行列の下三角部分を列ごとに順番に格納している必要があります。したがって、<code>AP[1]</code> には <code>A[1, 1]</code> が含まれ、<code>AP[2]</code> と <code>AP[3]</code> にはそれぞれ <code>A[2, 1]</code> と <code>A[3, 1]</code> が含まれます。</p><p>スカラー入力 <code>α</code> は実数でなければなりません。</p><p>配列入力 <code>x</code> と <code>AP</code> はすべて <code>Float32</code> または <code>Float64</code> 型でなければなりません。更新された <code>AP</code> を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p><code>spr!</code> は少なくとも Julia 1.8 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1213-L1236">source</a></section></article><h3 id="Level-3-BLAS-functions"><a class="docs-heading-anchor" href="#Level-3-BLAS-functions">Level 3 BLAS functions</a><a id="Level-3-BLAS-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Level-3-BLAS-functions" title="Permalink"></a></h3><p>レベル3 BLAS関数は[(Dongarra, 1990)][Dongarra-1990]で発表され、行列-行列演算を定義します。</p><p>[Dongarra-1990]: https://dl.acm.org/doi/10.1145/77626.79170</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemmt!" href="#LinearAlgebra.BLAS.gemmt!"><code>LinearAlgebra.BLAS.gemmt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemmt!(uplo, tA, tB, alpha, A, B, beta, C)</code></pre><p>指定された <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の <code>C</code> の下三角または上三角部分を <code>alpha*A*B + beta*C</code> または <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> と <code>tB</code> に応じた他のバリアントで更新します。更新された <code>C</code> を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>gemmt!</code> は少なくとも Julia 1.11 を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1522-L1531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemmt-NTuple{6, Any}" href="#LinearAlgebra.BLAS.gemmt-NTuple{6, Any}"><code>LinearAlgebra.BLAS.gemmt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemmt(uplo, tA, tB, alpha, A, B)</code></pre><p>指定された <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の <code>A*B</code> の下三角または上三角部分、または <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> と <code>tB</code> に応じた他の3つのバリアントを返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>gemmt</code> は少なくとも Julia 1.11 を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1584-L1591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemmt-NTuple{5, Any}" href="#LinearAlgebra.BLAS.gemmt-NTuple{5, Any}"><code>LinearAlgebra.BLAS.gemmt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemmt(uplo, tA, tB, A, B)</code></pre><p>指定された <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の <code>A*B</code> の下三角または上三角部分、または <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> と <code>tB</code> に応じた他の3つのバリアントを返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>gemmt</code> は少なくとも Julia 1.11 を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1594-L1601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemm!" href="#LinearAlgebra.BLAS.gemm!"><code>LinearAlgebra.BLAS.gemm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemm!(tA, tB, alpha, A, B, beta, C)</code></pre><p><code>C</code>を<code>alpha*A*B + beta*C</code>または<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>と<code>tB</code>に応じた他の3つのバリアントに従って更新します。更新された<code>C</code>を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1604-L1609">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemm-NTuple{5, Any}" href="#LinearAlgebra.BLAS.gemm-NTuple{5, Any}"><code>LinearAlgebra.BLAS.gemm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemm(tA, tB, alpha, A, B)</code></pre><p><code>alpha*A*B</code> または <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> と <code>tB</code> に応じた他の3つのバリアントを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1664-L1668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.gemm-NTuple{4, Any}" href="#LinearAlgebra.BLAS.gemm-NTuple{4, Any}"><code>LinearAlgebra.BLAS.gemm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemm(tA, tB, A, B)</code></pre><p><code>A*B</code> または <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> と <code>tB</code> に応じた他の3つのバリアントを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1671-L1675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.symm!" href="#LinearAlgebra.BLAS.symm!"><code>LinearAlgebra.BLAS.symm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symm!(side, ul, alpha, A, B, beta, C)</code></pre><p><code>C</code>を<code>alpha*A*B + beta*C</code>または<code>alpha*B*A + beta*C</code>として更新します。これは<a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a>に従います。<code>A</code>は対称であると仮定されます。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。更新された<code>C</code>を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1762-L1768">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.symm-NTuple{5, Any}" href="#LinearAlgebra.BLAS.symm-NTuple{5, Any}"><code>LinearAlgebra.BLAS.symm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symm(side, ul, alpha, A, B)</code></pre><p><code>alpha*A*B</code> または <code>alpha*B*A</code> を <a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a> に従って返します。<code>A</code> は対称であると仮定されます。<code>A</code> のみ <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形が使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1744-L1750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.symm-NTuple{4, Any}" href="#LinearAlgebra.BLAS.symm-NTuple{4, Any}"><code>LinearAlgebra.BLAS.symm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symm(side, ul, A, B)</code></pre><p><a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a> に従って <code>A*B</code> または <code>B*A</code> を返します。<code>A</code> は対称であると仮定されます。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1753-L1759">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hemm!" href="#LinearAlgebra.BLAS.hemm!"><code>LinearAlgebra.BLAS.hemm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hemm!(side, ul, alpha, A, B, beta, C)</code></pre><p><code>C</code>を<code>alpha*A*B + beta*C</code>または<code>alpha*B*A + beta*C</code>として更新します。これは<a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a>に従います。<code>A</code>はエルミート行列であると仮定します。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。更新された<code>C</code>を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1851-L1857">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hemm-NTuple{5, Any}" href="#LinearAlgebra.BLAS.hemm-NTuple{5, Any}"><code>LinearAlgebra.BLAS.hemm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hemm(side, ul, alpha, A, B)</code></pre><p><code>alpha*A*B</code> または <code>alpha*B*A</code> を <a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a> に従って返します。<code>A</code> はエルミート行列であると仮定します。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1834-L1840">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.hemm-NTuple{4, Any}" href="#LinearAlgebra.BLAS.hemm-NTuple{4, Any}"><code>LinearAlgebra.BLAS.hemm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hemm(side, ul, A, B)</code></pre><p><a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a> に従って <code>A*B</code> または <code>B*A</code> を返します。<code>A</code> はエルミート行列であると仮定されます。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1843-L1848">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.syrk!" href="#LinearAlgebra.BLAS.syrk!"><code>LinearAlgebra.BLAS.syrk!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syrk!(uplo, trans, alpha, A, beta, C)</code></pre><p>対称行列 <code>C</code> のランク-k 更新を <code>alpha*A*transpose(A) + beta*C</code> または <code>alpha*transpose(A)*A + beta*C</code> の形で行います。これは <a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従います。<code>C</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> 三角形のみが使用されます。<code>C</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1862-L1868">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.syrk" href="#LinearAlgebra.BLAS.syrk"><code>LinearAlgebra.BLAS.syrk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syrk(uplo, trans, alpha, A)</code></pre><p><code>A</code>の上三角または下三角を、<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a>に従って返します。<code>alpha*A*transpose(A)</code>または<code>alpha*transpose(A)*A</code>を、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a>に従って返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1871-L1878">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.herk!" href="#LinearAlgebra.BLAS.herk!"><code>LinearAlgebra.BLAS.herk!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">herk!(uplo, trans, alpha, A, beta, C)</code></pre><p>複素配列専用のメソッド。エルミート行列 <code>C</code> のランク-k 更新を <code>alpha*A*A&#39; + beta*C</code> または <code>alpha*A&#39;*A + beta*C</code> の形で行います。これは <a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従います。<code>C</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> 三角部分のみが更新されます。<code>C</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1922-L1928">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.herk" href="#LinearAlgebra.BLAS.herk"><code>LinearAlgebra.BLAS.herk</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">herk(uplo, trans, alpha, A)</code></pre><p>複素配列専用のメソッドです。<a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従って、<code>alpha*A*A&#39;</code> または <code>alpha*A&#39;*A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> 三角行列を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L1931-L1936">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.syr2k!" href="#LinearAlgebra.BLAS.syr2k!"><code>LinearAlgebra.BLAS.syr2k!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syr2k!(uplo, trans, alpha, A, B, beta, C)</code></pre><p>対称行列 <code>C</code> のランク-2k 更新を <code>alpha*A*transpose(B) + alpha*B*transpose(A) + beta*C</code> または <code>alpha*transpose(A)*B + alpha*transpose(B)*A + beta*C</code> として行います。これは <a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従います。<code>C</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> 三角形のみが使用されます。<code>C</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2019-L2027">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.syr2k" href="#LinearAlgebra.BLAS.syr2k"><code>LinearAlgebra.BLAS.syr2k</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syr2k(uplo, trans, alpha, A, B)</code></pre><p><a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の三角行列 <code>alpha*A*transpose(B) + alpha*B*transpose(A)</code> または <code>alpha*transpose(A)*B + alpha*transpose(B)*A</code> を、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従って返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2030-L2037">source</a></section><section><div><pre><code class="language-julia hljs">syr2k(uplo, trans, A, B)</code></pre><p><a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の三角行列を返します <code>A*transpose(B) + B*transpose(A)</code> または <code>transpose(A)*B + transpose(B)*A</code>、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従って。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2043-L2048">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.her2k!" href="#LinearAlgebra.BLAS.her2k!"><code>LinearAlgebra.BLAS.her2k!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">her2k!(uplo, trans, alpha, A, B, beta, C)</code></pre><p>エルミート行列 <code>C</code> のランク-2k 更新を <code>alpha*A*B&#39; + alpha*B*A&#39; + beta*C</code> または <code>alpha*A&#39;*B + alpha*B&#39;*A + beta*C</code> の形で行います。これは <a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従います。スカラー <code>beta</code> は実数でなければなりません。<code>C</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> 三角形のみが使用されます。<code>C</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2093-L2100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.her2k" href="#LinearAlgebra.BLAS.her2k"><code>LinearAlgebra.BLAS.her2k</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">her2k(uplo, trans, alpha, A, B)</code></pre><p><a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の三角行列を返します。これは <code>alpha*A*B&#39; + alpha*B*A&#39;</code> または <code>alpha*A&#39;*B + alpha*B&#39;*A</code> であり、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に応じて異なります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2103-L2108">source</a></section><section><div><pre><code class="language-julia hljs">her2k(uplo, trans, A, B)</code></pre><p><a href="LinearAlgebra.html#stdlib-blas-uplo"><code>uplo</code></a> の三角行列を返します <code>A*B&#39; + B*A&#39;</code> または <code>A&#39;*B + B&#39;*A</code>、<a href="LinearAlgebra.html#stdlib-blas-trans"><code>trans</code></a> に従って。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2111-L2116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trmm!" href="#LinearAlgebra.BLAS.trmm!"><code>LinearAlgebra.BLAS.trmm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trmm!(side, ul, tA, dA, alpha, A, B)</code></pre><p><code>B</code>を<code>alpha*A*B</code>または<a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a>と<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>によって決定される他の3つのバリアントのいずれかで更新します。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a>は対角値が読み取られるか、すべて1であると仮定されるかを決定します。更新された<code>B</code>を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2121-L2130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trmm" href="#LinearAlgebra.BLAS.trmm"><code>LinearAlgebra.BLAS.trmm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trmm(side, ul, tA, dA, alpha, A, B)</code></pre><p><code>alpha*A*B</code> または <a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a> と <a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a> によって決定される他の3つのバリアントのいずれかを返します。<code>A</code> の <a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a> 三角形のみが使用されます。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a> は対角値が読み取られるか、すべてが1であると仮定されるかを決定します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2133-L2141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trsm!" href="#LinearAlgebra.BLAS.trsm!"><code>LinearAlgebra.BLAS.trsm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trsm!(side, ul, tA, dA, alpha, A, B)</code></pre><p><code>B</code>を<code>A*X = alpha*B</code>の解で上書きするか、<a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a>と<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>によって決定される他の3つのバリアントのいずれかで上書きします。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a>は、対角値が読み取られるか、すべて1であると見なされるかを決定します。更新された<code>B</code>を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2144-L2153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.BLAS.trsm" href="#LinearAlgebra.BLAS.trsm"><code>LinearAlgebra.BLAS.trsm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trsm(side, ul, tA, dA, alpha, A, B)</code></pre><p><code>A*X = alpha*B</code>の解を返すか、<a href="LinearAlgebra.html#stdlib-blas-side"><code>side</code></a>と<a href="LinearAlgebra.html#stdlib-blas-trans"><code>tA</code></a>によって決定される他の3つのバリアントのいずれかを返します。<code>A</code>の<a href="LinearAlgebra.html#stdlib-blas-uplo"><code>ul</code></a>三角形のみが使用されます。<a href="LinearAlgebra.html#stdlib-blas-diag"><code>dA</code></a>は、対角値が読み取られるか、すべて1であると見なされるかを決定します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/blas.jl#L2156-L2164">source</a></section></article><h2 id="man-linalg-lapack-functions"><a class="docs-heading-anchor" href="#man-linalg-lapack-functions">LAPACK functions</a><a id="man-linalg-lapack-functions-1"></a><a class="docs-heading-anchor-permalink" href="#man-linalg-lapack-functions" title="Permalink"></a></h2><p><code>LinearAlgebra.LAPACK</code>は、線形代数のためのいくつかのLAPACK関数のラッパーを提供します。入力配列の1つを上書きする関数は、名前が<code>&#39;!&#39;</code>で終わります。</p><p>通常、関数には4つのメソッドが定義されており、それぞれ <a href="../base/numbers.html#Core.Float64"><code>Float64</code></a>、<a href="../base/numbers.html#Core.Float32"><code>Float32</code></a>、<code>ComplexF64</code> および <code>ComplexF32</code> 配列に対応しています。</p><p>LAPACK APIはJuliaによって提供されており、将来的に変更される可能性があります。このAPIはユーザー向けではないため、将来のリリースでこの特定の関数セットをサポートまたは非推奨にすることに対するコミットメントはありません。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK" href="#LinearAlgebra.LAPACK"><code>LinearAlgebra.LAPACK</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>LAPACKサブルーチンへのインターフェース。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gbtrf!" href="#LinearAlgebra.LAPACK.gbtrf!"><code>LinearAlgebra.LAPACK.gbtrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gbtrf!(kl, ku, m, AB) -&gt; (AB, ipiv)</code></pre><p>バンド行列 <code>AB</code> のLU因子分解を計算します。<code>kl</code> は非ゼロバンドを含む最初の下対角線、<code>ku</code> はそれを含む最後の上対角線、<code>m</code> は行列 <code>AB</code> の最初の次元です。LU因子分解をインプレースで返し、使用されたピボットのベクトル <code>ipiv</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L199-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gbtrs!" href="#LinearAlgebra.LAPACK.gbtrs!"><code>LinearAlgebra.LAPACK.gbtrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gbtrs!(trans, kl, ku, m, AB, ipiv, B)</code></pre><p>方程式 <code>AB * X = B</code> を解きます。<code>trans</code> は <code>AB</code> の向きを決定します。<code>N</code>（転置なし）、<code>T</code>（転置）、または <code>C</code>（共役転置）のいずれかです。<code>kl</code> は非ゼロバンドを含む最初の下対角線、<code>ku</code> はそれを含む最後の上対角線、<code>m</code> は行列 <code>AB</code> の最初の次元です。<code>ipiv</code> は <code>gbtrf!</code> から返されるピボットのベクトルです。ベクトルまたは行列 <code>X</code> を返し、<code>B</code> をその場で上書きします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gebal!" href="#LinearAlgebra.LAPACK.gebal!"><code>LinearAlgebra.LAPACK.gebal!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gebal!(job, A) -&gt; (ilo, ihi, scale)</code></pre><p>行列 <code>A</code> の固有系またはシュア分解を計算する前に、行列をバランスします。<code>job</code> は <code>N</code>（<code>A</code> は順序変更またはスケーリングされない）、<code>P</code>（<code>A</code> は順序変更のみ）、<code>S</code>（<code>A</code> はスケーリングのみ）、または <code>B</code>（<code>A</code> は順序変更およびスケーリングされる）のいずれかです。<code>A</code> をインプレースで変更し、<code>ilo</code>、<code>ihi</code>、および <code>scale</code> を返します。順序変更が有効な場合、<code>A[i,j] = 0</code> となります（<code>j &gt; i</code> かつ <code>1 &lt; j &lt; ilo</code> または <code>j &gt; ihi</code> の場合）。<code>scale</code> には、実行されたスケーリング/順序変更に関する情報が含まれています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L279-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gebak!" href="#LinearAlgebra.LAPACK.gebak!"><code>LinearAlgebra.LAPACK.gebak!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gebak!(job, side, ilo, ihi, scale, V)</code></pre><p><code>gebal!</code>を使用してバランスされた行列の固有ベクトル<code>V</code>を元の行列のスケールされていない/順序が変更されていない固有ベクトルに変換します。<code>V</code>はインプレースで修正されます。<code>side</code>は<code>L</code>（左固有ベクトルが変換される）または<code>R</code>（右固有ベクトルが変換される）にすることができます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L291-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gebrd!" href="#LinearAlgebra.LAPACK.gebrd!"><code>LinearAlgebra.LAPACK.gebrd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gebrd!(A) -&gt; (A, d, e, tauq, taup)</code></pre><p>行列 <code>A</code> をインプレースで二重対角行列の形 <code>A = QBP&#39;</code> に変換します。返されるのは、二重対角行列 <code>B</code> を含む <code>A</code>、<code>B</code> の対角要素を含む <code>d</code>、<code>B</code> の非対角要素を含む <code>e</code>、<code>Q</code> を表す基本反射体を含む <code>tauq</code>、および <code>P</code> を表す基本反射体を含む <code>taup</code> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L597-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gelqf!" href="#LinearAlgebra.LAPACK.gelqf!"><code>LinearAlgebra.LAPACK.gelqf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gelqf!(A, tau)</code></pre><p>行列 <code>A</code> の <code>LQ</code> 因子分解を計算します。<code>A = LQ</code> です。<code>tau</code> には因子分解の基本反射をパラメータ化するスカラーが含まれています。<code>tau</code> の長さは <code>A</code> の最小次元以上でなければなりません。</p><p><code>A</code> と <code>tau</code> はインプレースで変更されて返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L608-L617">source</a></section><section><div><pre><code class="language-julia hljs">gelqf!(A) -&gt; (A, tau)</code></pre><p>行列 <code>A</code> の <code>LQ</code> 分解を計算します。<code>A = LQ</code>。</p><p>インプレースで変更された <code>A</code> と、分解の基本反射をパラメータ化するスカラーを含む <code>tau</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L716-L723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqlf!" href="#LinearAlgebra.LAPACK.geqlf!"><code>LinearAlgebra.LAPACK.geqlf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geqlf!(A, tau)</code></pre><p><code>A</code>の<code>QL</code>因子分解を計算します。<code>A = QL</code>。<code>tau</code>は因子分解の基本反射体をパラメータ化するスカラーを含みます。<code>tau</code>は<code>A</code>の最小次元以上の長さでなければなりません。</p><p><code>A</code>と<code>tau</code>はインプレースで変更されて返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L620-L628">source</a></section><section><div><pre><code class="language-julia hljs">geqlf!(A) -&gt; (A, tau)</code></pre><p>行列 <code>A</code> の <code>QL</code> 因子分解を計算します。<code>A = QL</code>。</p><p><code>A</code> をインプレースで変更し、因子分解の基本反射をパラメータ化するスカラーを含む <code>tau</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L726-L733">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqrf!" href="#LinearAlgebra.LAPACK.geqrf!"><code>LinearAlgebra.LAPACK.geqrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geqrf!(A, tau)</code></pre><p>行列 <code>A</code> の <code>QR</code> 分解を計算します。<code>A = QR</code> です。<code>tau</code> には分解の基本反射体をパラメータ化するスカラーが含まれています。<code>tau</code> の長さは <code>A</code> の最小次元以上でなければなりません。</p><p><code>A</code> と <code>tau</code> をインプレースで変更して返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L685-L693">source</a></section><section><div><pre><code class="language-julia hljs">geqrf!(A) -&gt; (A, tau)</code></pre><p>行列 <code>A</code> の <code>QR</code> 分解を計算します。<code>A = QR</code>。</p><p>インプレースで変更された <code>A</code> と、分解の基本反射体をパラメータ化するスカラーを含む <code>tau</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L758-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqp3!" href="#LinearAlgebra.LAPACK.geqp3!"><code>LinearAlgebra.LAPACK.geqp3!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geqp3!(A, [jpvt, tau]) -&gt; (A, tau, jpvt)</code></pre><p>行列 <code>A</code> のピボット付き <code>QR</code> 分解を計算します。<code>AP = QR</code> を BLAS レベル 3 を使用して行います。<code>P</code> はピボット行列で、<code>jpvt</code> によって表されます。<code>tau</code> は基本反射体を格納します。引数 <code>jpvt</code> と <code>tau</code> はオプションで、事前に割り当てられた配列を渡すことができます。渡された場合、<code>jpvt</code> は <code>A</code> が <code>(m x n)</code> 行列である場合、長さが <code>n</code> 以上でなければならず、<code>tau</code> は <code>A</code> の最小次元以上の長さでなければなりません。エントリ時に、<code>jpvt[j]</code> がゼロでない場合、<code>A</code> の <code>j</code> 番目の列は <code>AP</code> の先頭に置き換えられます。</p><p><code>A</code>、<code>jpvt</code>、および <code>tau</code> はインプレースで変更されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L631-L644">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gerqf!" href="#LinearAlgebra.LAPACK.gerqf!"><code>LinearAlgebra.LAPACK.gerqf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gerqf!(A, tau)</code></pre><p>行列 <code>A</code> の <code>RQ</code> 因子分解を計算します。<code>A = RQ</code> です。<code>tau</code> には因子分解の基本反射のパラメータとなるスカラーが含まれています。<code>tau</code> の長さは <code>A</code> の最小次元以上でなければなりません。</p><p><code>A</code> と <code>tau</code> はインプレースで変更されて返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L696-L704">source</a></section><section><div><pre><code class="language-julia hljs">gerqf!(A) -&gt; (A, tau)</code></pre><p>行列 <code>A</code> の <code>RQ</code> 因子分解を計算します。すなわち、<code>A = RQ</code> です。</p><p><code>A</code> をその場で修正し、因子分解の基本反射体をパラメータ化するスカラーを含む <code>tau</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L768-L775">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqrt!" href="#LinearAlgebra.LAPACK.geqrt!"><code>LinearAlgebra.LAPACK.geqrt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geqrt!(A, T)</code></pre><p>行列 <code>A</code> のブロック <code>QR</code> 分解を計算します。<code>A = QR</code> です。<code>T</code> には、分解の基本反射をパラメータ化する上三角ブロック反射が含まれています。<code>T</code> の最初の次元はブロックサイズを設定し、1 と <code>n</code> の間でなければなりません。<code>T</code> の2番目の次元は <code>A</code> の最小次元と等しくなければなりません。</p><p><code>A</code> と <code>T</code> はインプレースで変更されて返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L659-L669">source</a></section><section><div><pre><code class="language-julia hljs">geqrt!(A, nb) -&gt; (A, T)</code></pre><p>行列 <code>A</code> のブロック <code>QR</code> 分解を計算します。<code>A = QR</code>。<code>nb</code> はブロックサイズを設定し、<code>A</code> の第二次元である <code>n</code> の間で1以上でなければなりません。</p><p>インプレースで変更された <code>A</code> と、分解の基本反射をパラメータ化する上三角ブロック反射子を含む <code>T</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L736-L745">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geqrt3!" href="#LinearAlgebra.LAPACK.geqrt3!"><code>LinearAlgebra.LAPACK.geqrt3!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geqrt3!(A, T)</code></pre><p>再帰的にブロック <code>QR</code> 分解を計算します。<code>A = QR</code>。<code>T</code> には、分解の基本反射をパラメータ化する上三角ブロック反射が含まれています。<code>T</code> の最初の次元はブロックサイズを設定し、1 と <code>n</code> の間でなければなりません。<code>T</code> の2番目の次元は <code>A</code> の最小次元と等しくなければなりません。</p><p><code>A</code> と <code>T</code> をインプレースで変更して返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L672-L682">source</a></section><section><div><pre><code class="language-julia hljs">geqrt3!(A) -&gt; (A, T)</code></pre><p>行列 <code>A</code> のブロック <code>QR</code> 分解を再帰的に計算します。<code>A = QR</code>。</p><p>インプレースで変更された <code>A</code> と、分解の基本反射をパラメータ化する上三角ブロック反射子を含む <code>T</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L748-L755">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.getrf!" href="#LinearAlgebra.LAPACK.getrf!"><code>LinearAlgebra.LAPACK.getrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getrf!(A, ipiv) -&gt; (A, ipiv, info)</code></pre><p>行列 <code>A</code> のピボット付き <code>LU</code> 分解を計算します。<code>A = LU</code>。<code>ipiv</code> にはピボット情報が含まれ、<code>info</code> には成功を示すコード（<code>info = 0</code>）、<code>U</code> に特異値がある場合のコード（<code>info = i</code>、この場合 <code>U[i,i]</code> は特異）、またはエラーコード（<code>info &lt; 0</code>）が含まれます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L707-L713">source</a></section><section><div><pre><code class="language-julia hljs">getrf!(A) -&gt; (A, ipiv, info)</code></pre><p>行列 <code>A</code> のピボット付き <code>LU</code> 分解を計算します。<code>A = LU</code>。</p><p><code>A</code> をインプレースで変更し、ピボティング情報 <code>ipiv</code> と成功を示す <code>info</code> コードを返します（<code>info = 0</code>）、<code>U</code> に特異値がある場合（<code>info = i</code> の場合、<code>U[i,i]</code> は特異）、またはエラーコード（<code>info &lt; 0</code>）。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L778-L786">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.tzrzf!" href="#LinearAlgebra.LAPACK.tzrzf!"><code>LinearAlgebra.LAPACK.tzrzf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tzrzf!(A) -&gt; (A, tau)</code></pre><p>上三角行列 <code>A</code> をその場で上三角形の形に変換します。変換のための基本反射体のスカラーパラメータ <code>tau</code> とともに <code>A</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L954-L960">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormrz!" href="#LinearAlgebra.LAPACK.ormrz!"><code>LinearAlgebra.LAPACK.ormrz!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ormrz!(side, trans, A, tau, C)</code></pre><p>行列 <code>C</code> を、<code>tzrzf!</code> によって供給された変換からの <code>Q</code> で乗算します。<code>side</code> または <code>trans</code> に応じて、乗算は左側（<code>side = L, Q*C</code>）または右側（<code>side = R, C*Q</code>）で行われ、<code>Q</code> は変更されない（<code>trans = N</code>）、転置される（<code>trans = T</code>）、または共役転置される（<code>trans = C</code>）ことがあります。乗算の結果でインプレースで変更された行列 <code>C</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L942-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gels!" href="#LinearAlgebra.LAPACK.gels!"><code>LinearAlgebra.LAPACK.gels!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gels!(trans, A, B) -&gt; (F, B, ssr)</code></pre><p>線形方程式 <code>A * X = B</code>、<code>transpose(A) * X = B</code>、または <code>adjoint(A) * X = B</code> を QR または LQ 因数分解を使用して解決します。解を持つ行列/ベクトル <code>B</code> をその場で修正します。<code>A</code> はその <code>QR</code> または <code>LQ</code> 因数分解で上書きされます。<code>trans</code> は <code>N</code>（変更なし）、<code>T</code>（転置）、または <code>C</code>（共役転置）のいずれかである可能性があります。<code>gels!</code> は最小ノルム/最小二乗解を検索します。<code>A</code> は過小または過剰に決定されている可能性があります。解は <code>B</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1097-L1106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesv!" href="#LinearAlgebra.LAPACK.gesv!"><code>LinearAlgebra.LAPACK.gesv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gesv!(A, B) -&gt; (B, A, ipiv)</code></pre><p>線形方程式 <code>A * X = B</code> を解きます。ここで <code>A</code> は正方行列で、<code>A</code> の <code>LU</code> 分解を使用します。<code>A</code> はその <code>LU</code> 分解で上書きされ、<code>B</code> は解 <code>X</code> で上書きされます。<code>ipiv</code> には <code>A</code> の <code>LU</code> 分解のピボット情報が含まれています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1109-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.getrs!" href="#LinearAlgebra.LAPACK.getrs!"><code>LinearAlgebra.LAPACK.getrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getrs!(trans, A, ipiv, B)</code></pre><p>線形方程式 <code>A * X = B</code>、<code>transpose(A) * X = B</code>、または <code>adjoint(A) * X = B</code> を正方行列 <code>A</code> に対して解きます。解を持つ行列/ベクトル <code>B</code> をその場で修正します。<code>A</code> は <code>getrf!</code> からの <code>LU</code> 因子分解で、<code>ipiv</code> はピボット情報です。<code>trans</code> は <code>N</code>（変更なし）、<code>T</code>（転置）、または <code>C</code>（共役転置）のいずれかです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1119-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.getri!" href="#LinearAlgebra.LAPACK.getri!"><code>LinearAlgebra.LAPACK.getri!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getri!(A, ipiv)</code></pre><p><code>A</code>の逆行列を計算します。これは<code>getrf!</code>によって見つかった<code>LU</code>因子分解を使用します。<code>ipiv</code>は出力されたピボット情報であり、<code>A</code>は<code>getrf!</code>の<code>LU</code>因子分解を含んでいます。<code>A</code>はその逆行列で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1130-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesvx!" href="#LinearAlgebra.LAPACK.gesvx!"><code>LinearAlgebra.LAPACK.gesvx!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gesvx!(fact, trans, A, AF, ipiv, equed, R, C, B) -&gt; (X, equed, R, C, B, rcond, ferr, berr, work)</code></pre><p>線形方程式 <code>A * X = B</code> (<code>trans = N</code>)、<code>transpose(A) * X = B</code> (<code>trans = T</code>)、または <code>adjoint(A) * X = B</code> (<code>trans = C</code>) を <code>A</code> の <code>LU</code> 因数分解を使用して解きます。<code>fact</code> は <code>E</code> である場合、<code>A</code> は平衡化されて <code>AF</code> にコピーされます; <code>F</code> である場合、<code>AF</code> と <code>ipiv</code> は以前の <code>LU</code> 因数分解からの入力です; または <code>N</code> である場合、<code>A</code> は <code>AF</code> にコピーされ、その後因数分解されます。<code>fact = F</code> の場合、<code>equed</code> は <code>N</code> であり、これは <code>A</code> が平衡化されていないことを意味します; <code>R</code> は <code>A</code> が左から <code>Diagonal(R)</code> で乗算されたことを意味します; <code>C</code> は <code>A</code> が右から <code>Diagonal(C)</code> で乗算されたことを意味します; または <code>B</code> は <code>A</code> が左から <code>Diagonal(R)</code> で、右から <code>Diagonal(C)</code> で乗算されたことを意味します。<code>fact = F</code> で <code>equed = R</code> または <code>B</code> の場合、<code>R</code> の要素はすべて正でなければなりません。<code>fact = F</code> で <code>equed = C</code> または <code>B</code> の場合、<code>C</code> の要素はすべて正でなければなりません。</p><p>解 <code>X</code> を返します; <code>equed</code> は <code>fact</code> が <code>N</code> でない場合の出力であり、実行された平衡化を説明します; <code>R</code> は行の平衡化対角行列; <code>C</code> は列の平衡化対角行列; <code>B</code> はその平衡化された形 <code>Diagonal(R)*B</code> で上書きされる可能性があります（<code>trans = N</code> かつ <code>equed = R,B</code> の場合）または <code>Diagonal(C)*B</code>（<code>trans = T,C</code> かつ <code>equed = C,B</code> の場合）; <code>rcond</code> は平衡化後の <code>A</code> の逆条件数; <code>ferr</code> は <code>X</code> の各解ベクトルの前方誤差境界; <code>berr</code> は <code>X</code> の各解ベクトルの前方誤差境界; および <code>work</code> は逆ピボット成長因子です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1286-L1309">source</a></section><section><div><pre><code class="language-julia hljs">gesvx!(A, B)</code></pre><p><code>gesvx!</code>の非スケーリング、非転置の簡略化。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1313-L1317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gelsd!" href="#LinearAlgebra.LAPACK.gelsd!"><code>LinearAlgebra.LAPACK.gelsd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gelsd!(A, B, rcond) -&gt; (B, rnk)</code></pre><p><code>A * X = B</code> の最小ノルム解を計算します。これは <code>A</code> の <code>SVD</code> 因子分解を見つけ、その後問題を分割して解決します。<code>B</code> は解 <code>X</code> で上書きされます。<code>rcond</code> 以下の特異値はゼロとして扱われます。解は <code>B</code> に返され、<code>A</code> の有効ランクは <code>rnk</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1512-L1520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gelsy!" href="#LinearAlgebra.LAPACK.gelsy!"><code>LinearAlgebra.LAPACK.gelsy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gelsy!(A, B, rcond) -&gt; (B, rnk)</code></pre><p>行列 <code>A * X = B</code> の最小ノルム解を計算します。これは、<code>A</code> の完全な <code>QR</code> 分解を見つけ、その後問題を分割して解決することによって行われます。<code>B</code> は解 <code>X</code> で上書きされます。特異値が <code>rcond</code> 未満の場合はゼロとして扱われます。解は <code>B</code> に返され、<code>A</code> の有効ランクは <code>rnk</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1523-L1531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gglse!" href="#LinearAlgebra.LAPACK.gglse!"><code>LinearAlgebra.LAPACK.gglse!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gglse!(A, c, B, d) -&gt; (X,res)</code></pre><p>方程式 <code>A * x = c</code> を解きます。ここで <code>x</code> は等式制約 <code>B * x = d</code> に従います。式 <code>||c - A*x||^2 = 0</code> を使用して解決します。<code>X</code> と残差の二乗和を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1585-L1591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geev!" href="#LinearAlgebra.LAPACK.geev!"><code>LinearAlgebra.LAPACK.geev!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geev!(jobvl, jobvr, A) -&gt; (W, VL, VR)</code></pre><p>行列 <code>A</code> の固有系を求めます。<code>jobvl = N</code> の場合、<code>A</code> の左固有ベクトルは計算されません。<code>jobvr = N</code> の場合、<code>A</code> の右固有ベクトルは計算されません。<code>jobvl = V</code> または <code>jobvr = V</code> の場合、対応する固有ベクトルが計算されます。固有値は <code>W</code> に、右固有ベクトルは <code>VR</code> に、左固有ベクトルは <code>VL</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1896-L1904">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesdd!" href="#LinearAlgebra.LAPACK.gesdd!"><code>LinearAlgebra.LAPACK.gesdd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gesdd!(job, A) -&gt; (U, S, VT)</code></pre><p>行列 <code>A</code> の特異値分解を見つけます。<code>A = U * S * V&#39;</code> の形で、分割統治法を使用します。<code>job = A</code> の場合、<code>U</code> のすべての列と <code>V&#39;</code> のすべての行が計算されます。<code>job = N</code> の場合、<code>U</code> の列や <code>V&#39;</code> の行は計算されません。<code>job = O</code> の場合、<code>A</code> は (薄い) <code>U</code> の列と (薄い) <code>V&#39;</code> の行で上書きされます。<code>job = S</code> の場合、(薄い) <code>U</code> の列と (薄い) <code>V&#39;</code> の行が計算され、別々に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1907-L1916">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gesvd!" href="#LinearAlgebra.LAPACK.gesvd!"><code>LinearAlgebra.LAPACK.gesvd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gesvd!(jobu, jobvt, A) -&gt; (U, S, VT)</code></pre><p><code>A</code>の特異値分解を見つけます。<code>A = U * S * V&#39;</code>。<code>jobu = A</code>の場合、<code>U</code>のすべての列が計算されます。<code>jobvt = A</code>の場合、<code>V&#39;</code>のすべての行が計算されます。<code>jobu = N</code>の場合、<code>U</code>の列は計算されません。<code>jobvt = N</code>の場合、<code>V&#39;</code>の行は計算されません。<code>jobu = O</code>の場合、<code>A</code>は（薄い）<code>U</code>の列で上書きされます。<code>jobvt = O</code>の場合、<code>A</code>は（薄い）<code>V&#39;</code>の行で上書きされます。<code>jobu = S</code>の場合、（薄い）<code>U</code>の列が計算され、別々に返されます。<code>jobvt = S</code>の場合、（薄い）<code>V&#39;</code>の行が計算され、別々に返されます。<code>jobu</code>と<code>jobvt</code>は両方とも<code>O</code>にすることはできません。</p><p><code>U</code>、<code>S</code>、および<code>Vt</code>を返します。ここで、<code>S</code>は<code>A</code>の特異値です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1919-L1932">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggsvd!" href="#LinearAlgebra.LAPACK.ggsvd!"><code>LinearAlgebra.LAPACK.ggsvd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ggsvd!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p><code>A</code> と <code>B</code> の一般化特異値分解を見つけます。<code>U&#39;*A*Q = D1*R</code> および <code>V&#39;*B*Q = D2*R</code> です。<code>D1</code> の対角には <code>alpha</code> があり、<code>D2</code> の対角には <code>beta</code> が存在します。<code>jobu = U</code> の場合、直交/ユニタリ行列 <code>U</code> が計算されます。<code>jobv = V</code> の場合、直交/ユニタリ行列 <code>V</code> が計算されます。<code>jobq = Q</code> の場合、直交/ユニタリ行列 <code>Q</code> が計算されます。<code>jobu</code>、<code>jobv</code> または <code>jobq</code> が <code>N</code> の場合、その行列は計算されません。この関数は LAPACK バージョン 3.6.0 より前のバージョンでのみ利用可能です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L1935-L1945">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggsvd3!" href="#LinearAlgebra.LAPACK.ggsvd3!"><code>LinearAlgebra.LAPACK.ggsvd3!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ggsvd3!(jobu, jobv, jobq, A, B) -&gt; (U, V, Q, alpha, beta, k, l, R)</code></pre><p><code>A</code>と<code>B</code>の一般化特異値分解を見つけます。<code>U&#39;*A*Q = D1*R</code>および<code>V&#39;*B*Q = D2*R</code>です。<code>D1</code>の対角には<code>alpha</code>があり、<code>D2</code>の対角には<code>beta</code>があります。<code>jobu = U</code>の場合、直交/ユニタリ行列<code>U</code>が計算されます。<code>jobv = V</code>の場合、直交/ユニタリ行列<code>V</code>が計算されます。<code>jobq = Q</code>の場合、直交/ユニタリ行列<code>Q</code>が計算されます。<code>jobu</code>、<code>jobv</code>、または<code>jobq</code>が<code>N</code>の場合、その行列は計算されません。この関数はLAPACK 3.6.0を必要とします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2074-L2083">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.geevx!" href="#LinearAlgebra.LAPACK.geevx!"><code>LinearAlgebra.LAPACK.geevx!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geevx!(balanc, jobvl, jobvr, sense, A) -&gt; (A, w, VL, VR, ilo, ihi, scale, abnrm, rconde, rcondv)</code></pre><p>行列 <code>A</code> の固有系を行列バランシングを用いて求めます。<code>jobvl = N</code> の場合、<code>A</code> の左固有ベクトルは計算されません。<code>jobvr = N</code> の場合、<code>A</code> の右固有ベクトルは計算されません。<code>jobvl = V</code> または <code>jobvr = V</code> の場合、対応する固有ベクトルが計算されます。<code>balanc = N</code> の場合、バランシングは行われません。<code>balanc = P</code> の場合、<code>A</code> は順序が変更されますが、スケーリングは行われません。<code>balanc = S</code> の場合、<code>A</code> はスケーリングされますが、順序は変更されません。<code>balanc = B</code> の場合、<code>A</code> は順序が変更され、スケーリングされます。<code>sense = N</code> の場合、逆条件数は計算されません。<code>sense = E</code> の場合、固有値のみに対して逆条件数が計算されます。<code>sense = V</code> の場合、右固有ベクトルのみに対して逆条件数が計算されます。<code>sense = B</code> の場合、右固有ベクトルと固有ベクトルの両方に対して逆条件数が計算されます。<code>sense = E,B</code> の場合、右および左の固有ベクトルが計算される必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2524-L2540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggev!" href="#LinearAlgebra.LAPACK.ggev!"><code>LinearAlgebra.LAPACK.ggev!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ggev!(jobvl, jobvr, A, B) -&gt; (alpha, beta, vl, vr)</code></pre><p><code>A</code>と<code>B</code>の一般化固有分解を求めます。<code>jobvl = N</code>の場合、左固有ベクトルは計算されません。<code>jobvr = N</code>の場合、右固有ベクトルは計算されません。<code>jobvl = V</code>または<code>jobvr = V</code>の場合、対応する固有ベクトルが計算されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2543-L2550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ggev3!" href="#LinearAlgebra.LAPACK.ggev3!"><code>LinearAlgebra.LAPACK.ggev3!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ggev3!(jobvl, jobvr, A, B) -&gt; (alpha, beta, vl, vr)</code></pre><p><code>A</code> と <code>B</code> の一般化固有分解をブロックアルゴリズムを使用して求めます。<code>jobvl = N</code> の場合、左固有ベクトルは計算されません。<code>jobvr = N</code> の場合、右固有ベクトルは計算されません。<code>jobvl = V</code> または <code>jobvr = V</code> の場合、対応する固有ベクトルが計算されます。この関数は LAPACK 3.6.0 を必要とします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2553-L2561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gtsv!" href="#LinearAlgebra.LAPACK.gtsv!"><code>LinearAlgebra.LAPACK.gtsv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gtsv!(dl, d, du, B)</code></pre><p>方程式 <code>A * X = B</code> を解きます。ここで <code>A</code> は下対角成分が <code>dl</code>、対角成分が <code>d</code>、上対角成分が <code>du</code> の三重対角行列です。</p><p><code>B</code> を解 <code>X</code> で上書きし、それを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2735-L2743">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gttrf!" href="#LinearAlgebra.LAPACK.gttrf!"><code>LinearAlgebra.LAPACK.gttrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gttrf!(dl, d, du) -&gt; (dl, d, du, du2, ipiv)</code></pre><p>三重対角行列の <code>LU</code> 因子分解を見つけます。<code>dl</code> は下対角、<code>d</code> は対角、<code>du</code> は上対角にあります。</p><p><code>dl</code>、<code>d</code>、および <code>du</code> をインプレースで変更し、それらと第二の上対角 <code>du2</code> およびピボットベクトル <code>ipiv</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2746-L2754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gttrs!" href="#LinearAlgebra.LAPACK.gttrs!"><code>LinearAlgebra.LAPACK.gttrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gttrs!(trans, dl, d, du, du2, ipiv, B)</code></pre><p>方程式 <code>A * X = B</code> (<code>trans = N</code>)、<code>transpose(A) * X = B</code> (<code>trans = T</code>)、または <code>adjoint(A) * X = B</code> (<code>trans = C</code>) を <code>gttrf!</code> によって計算された <code>LU</code> 因子分解を使用して解きます。<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L2757-L2763">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.orglq!" href="#LinearAlgebra.LAPACK.orglq!"><code>LinearAlgebra.LAPACK.orglq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orglq!(A, tau, k = length(tau))</code></pre><p><code>gelqf!</code>を<code>A</code>に呼び出した後、<code>LQ</code>因子分解の行列<code>Q</code>を明示的に求めます。<code>gelqf!</code>の出力を使用します。<code>A</code>は<code>Q</code>で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3164-L3169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.orgqr!" href="#LinearAlgebra.LAPACK.orgqr!"><code>LinearAlgebra.LAPACK.orgqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orgqr!(A, tau, k = length(tau))</code></pre><p><code>geqrf!</code>を<code>A</code>に呼び出した後に、<code>QR</code>分解の行列<code>Q</code>を明示的に求めます。<code>geqrf!</code>の出力を使用します。<code>A</code>は<code>Q</code>で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3172-L3177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.orgql!" href="#LinearAlgebra.LAPACK.orgql!"><code>LinearAlgebra.LAPACK.orgql!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orgql!(A, tau, k = length(tau))</code></pre><p><code>geqlf!</code>を<code>A</code>に呼び出した後、<code>QL</code>因子分解の行列<code>Q</code>を明示的に求めます。<code>geqlf!</code>の出力を使用します。<code>A</code>は<code>Q</code>で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3180-L3185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.orgrq!" href="#LinearAlgebra.LAPACK.orgrq!"><code>LinearAlgebra.LAPACK.orgrq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orgrq!(A, tau, k = length(tau))</code></pre><p><code>gerqf!</code>を<code>A</code>に対して呼び出した後に、<code>RQ</code>因子分解の行列<code>Q</code>を明示的に求めます。<code>gerqf!</code>の出力を使用します。<code>A</code>は<code>Q</code>で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3188-L3193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormlq!" href="#LinearAlgebra.LAPACK.ormlq!"><code>LinearAlgebra.LAPACK.ormlq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ormlq!(side, trans, A, tau, C)</code></pre><p><code>Q * C</code> を計算します（<code>trans = N</code>）、<code>transpose(Q) * C</code>（<code>trans = T</code>）、<code>adjoint(Q) * C</code>（<code>trans = C</code>）で <code>side = L</code> の場合、または <code>side = R</code> の場合は <code>gelqf!</code> を使用して計算された <code>A</code> の <code>LQ</code> 分解からの <code>Q</code> を使用して同等の右側の乗算を行います。<code>C</code> は上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3196-L3203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormqr!" href="#LinearAlgebra.LAPACK.ormqr!"><code>LinearAlgebra.LAPACK.ormqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ormqr!(side, trans, A, tau, C)</code></pre><p><code>Q * C</code> を計算します（<code>trans = N</code>）、<code>transpose(Q) * C</code>（<code>trans = T</code>）、<code>adjoint(Q) * C</code>（<code>trans = C</code>）は <code>side = L</code> の場合、または <code>side = R</code> の場合は同等の右側の乗算を行います。<code>A</code> の <code>QR</code> 因数分解から得られた <code>Q</code> を使用し、<code>geqrf!</code> を用いて計算されます。<code>C</code> は上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3206-L3213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormql!" href="#LinearAlgebra.LAPACK.ormql!"><code>LinearAlgebra.LAPACK.ormql!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ormql!(side, trans, A, tau, C)</code></pre><p><code>Q * C</code> を計算します（<code>trans = N</code>）、<code>transpose(Q) * C</code>（<code>trans = T</code>）、<code>adjoint(Q) * C</code>（<code>trans = C</code>）で <code>side = L</code> または <code>side = R</code> の場合は <code>A</code> の <code>geqlf!</code> を使用して計算された <code>QL</code> 因子分解からの <code>Q</code> を使用します。<code>C</code> は上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3216-L3223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ormrq!" href="#LinearAlgebra.LAPACK.ormrq!"><code>LinearAlgebra.LAPACK.ormrq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ormrq!(side, trans, A, tau, C)</code></pre><p><code>Q * C</code> を計算します（<code>trans = N</code>）、<code>transpose(Q) * C</code>（<code>trans = T</code>）、<code>adjoint(Q) * C</code>（<code>trans = C</code>）は <code>side = L</code> の場合、または <code>side = R</code> の場合は <code>gerqf!</code> を使用して計算された <code>A</code> の <code>RQ</code> 因数分解からの <code>Q</code> を使用して同等の右側の乗算を行います。<code>C</code> は上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3226-L3233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gemqrt!" href="#LinearAlgebra.LAPACK.gemqrt!"><code>LinearAlgebra.LAPACK.gemqrt!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gemqrt!(side, trans, V, T, C)</code></pre><p><code>Q * C</code> を計算します（<code>trans = N</code>）、<code>transpose(Q) * C</code>（<code>trans = T</code>）、<code>adjoint(Q) * C</code>（<code>trans = C</code>）を <code>side = L</code> の場合、または <code>geqrt!</code> を使用して計算された <code>A</code> の <code>QR</code> 分解からの <code>Q</code> を使用して <code>side = R</code> の場合の同等の右側の乗算を行います。<code>C</code> は上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3236-L3243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.posv!" href="#LinearAlgebra.LAPACK.posv!"><code>LinearAlgebra.LAPACK.posv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">posv!(uplo, A, B) -&gt; (A, B)</code></pre><p><code>A * X = B</code> の解を見つけます。ここで <code>A</code> は対称またはエルミートの正定値行列です。<code>uplo = U</code> の場合、<code>A</code> の上三角コレスキー分解が計算されます。<code>uplo = L</code> の場合、<code>A</code> の下三角コレスキー分解が計算されます。<code>A</code> はそのコレスキー分解で上書きされます。<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3379-L3387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.potrf!" href="#LinearAlgebra.LAPACK.potrf!"><code>LinearAlgebra.LAPACK.potrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">potrf!(uplo, A)</code></pre><p>正定行列 <code>A</code> のコレスキー分解（<code>uplo = U</code> の場合は上三角、<code>uplo = L</code> の場合は下三角）を計算します。<code>A</code> は上書きされ、情報コードと共に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3390-L3396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.potri!" href="#LinearAlgebra.LAPACK.potri!"><code>LinearAlgebra.LAPACK.potri!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">potri!(uplo, A)</code></pre><p>正定行列 <code>A</code> の逆行列を計算します。これは、(uplo = U の場合は上三角、uplo = L の場合は下三角の) コレスキー分解を見つけるために <code>potrf!</code> を呼び出した後に行われます。</p><p><code>A</code> はその逆行列で上書きされ、返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3399-L3407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.potrs!" href="#LinearAlgebra.LAPACK.potrs!"><code>LinearAlgebra.LAPACK.potrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">potrs!(uplo, A, B)</code></pre><p><code>A * X = B</code> の解を求めます。ここで、<code>A</code> は <code>potrf!</code> によって計算されたコレスキー分解を持つ対称またはエルミートの正定値行列です。<code>uplo = U</code> の場合、<code>A</code> の上三角コレスキー分解が計算されました。<code>uplo = L</code> の場合、<code>A</code> の下三角コレスキー分解が計算されました。<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3410-L3418">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.pstrf!" href="#LinearAlgebra.LAPACK.pstrf!"><code>LinearAlgebra.LAPACK.pstrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pstrf!(uplo, A, tol) -&gt; (A, piv, rank, info)</code></pre><p>正定行列 <code>A</code> の（<code>uplo = U</code> の場合は上三角、<code>uplo = L</code> の場合は下三角）ピボット付きコレスキー分解を、ユーザーが設定した許容誤差 <code>tol</code> で計算します。<code>A</code> はそのコレスキー分解で上書きされます。</p><p><code>A</code>、ピボット <code>piv</code>、<code>A</code> のランク、および <code>info</code> コードを返します。<code>info = 0</code> の場合、因子分解は成功しました。<code>info = i &gt; 0</code> の場合、<code>A</code> は不定またはランク不足です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3421-L3431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.ptsv!" href="#LinearAlgebra.LAPACK.ptsv!"><code>LinearAlgebra.LAPACK.ptsv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ptsv!(D, E, B)</code></pre><p>正定三重対角行列 <code>A</code> に対して <code>A * X = B</code> を解きます。<code>D</code> は <code>A</code> の対角成分で、<code>E</code> は副対角成分です。<code>B</code> は解 <code>X</code> で上書きされ、返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3488-L3494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.pttrf!" href="#LinearAlgebra.LAPACK.pttrf!"><code>LinearAlgebra.LAPACK.pttrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pttrf!(D, E)</code></pre><p>正定三対角行列のLDLt因子分解を計算します。<code>D</code>は対角成分、<code>E</code>は非対角成分です。<code>D</code>と<code>E</code>は上書きされ、返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3497-L3503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.pttrs!" href="#LinearAlgebra.LAPACK.pttrs!"><code>LinearAlgebra.LAPACK.pttrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pttrs!(D, E, B)</code></pre><p>正定三対角行列 <code>A</code> に対して <code>A * X = B</code> を解きます。ここで、対角成分は <code>D</code>、非対角成分は <code>E</code> です。<code>A</code> の LDLt 因子分解を <code>pttrf!</code> を使用して計算した後、<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3570-L3576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trtri!" href="#LinearAlgebra.LAPACK.trtri!"><code>LinearAlgebra.LAPACK.trtri!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trtri!(uplo, diag, A)</code></pre><p>上三角行列 <code>A</code> の逆行列を求めます（<code>uplo = U</code> の場合は上、<code>uplo = L</code> の場合は下）。<code>diag = N</code> の場合、<code>A</code> は単位でない対角要素を持ちます。<code>diag = U</code> の場合、<code>A</code> のすべての対角要素は1です。<code>A</code> はその逆行列で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3640-L3647">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trtrs!" href="#LinearAlgebra.LAPACK.trtrs!"><code>LinearAlgebra.LAPACK.trtrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trtrs!(uplo, trans, diag, A, B)</code></pre><p><code>A * X = B</code> を解きます（<code>trans = N</code>）、<code>transpose(A) * X = B</code>（<code>trans = T</code>）、または <code>adjoint(A) * X = B</code>（<code>trans = C）</code>、(上三角行列の場合は <code>uplo = U</code>、下三角行列の場合は <code>uplo = L</code>) の行列 <code>A</code> に対して。<code>diag = N</code> の場合、<code>A</code> は非単位対角要素を持ちます。<code>diag = U</code> の場合、<code>A</code> のすべての対角要素は1です。<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3650-L3658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trcon!" href="#LinearAlgebra.LAPACK.trcon!"><code>LinearAlgebra.LAPACK.trcon!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trcon!(norm, uplo, diag, A)</code></pre><p>三角行列 <code>A</code> の逆条件数を求めます（<code>uplo = U</code> の場合は上三角、<code>uplo = L</code> の場合は下三角）。<code>diag = N</code> の場合、<code>A</code> は単位でない対角要素を持ちます。<code>diag = U</code> の場合、<code>A</code> のすべての対角要素は1です。<code>norm = I</code> の場合、条件数は無限大ノルムで求められます。<code>norm = O</code> または <code>1</code> の場合、条件数は1ノルムで求められます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3935-L3943">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trevc!" href="#LinearAlgebra.LAPACK.trevc!"><code>LinearAlgebra.LAPACK.trevc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trevc!(side, howmny, select, T, VL = similar(T), VR = similar(T))</code></pre><p>上三角行列 <code>T</code> の固有系を求めます。<code>side = R</code> の場合、右固有ベクトルが計算されます。<code>side = L</code> の場合、左固有ベクトルが計算されます。<code>side = B</code> の場合、両方のセットが計算されます。<code>howmny = A</code> の場合、すべての固有ベクトルが見つかります。<code>howmny = B</code> の場合、すべての固有ベクトルが見つかり、<code>VL</code> と <code>VR</code> を使用して逆変換されます。<code>howmny = S</code> の場合、<code>select</code> に対応する値の固有ベクトルのみが計算されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3946-L3956">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trrfs!" href="#LinearAlgebra.LAPACK.trrfs!"><code>LinearAlgebra.LAPACK.trrfs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trrfs!(uplo, trans, diag, A, B, X, Ferr, Berr) -&gt; (Ferr, Berr)</code></pre><p><code>A * X = B</code> の解の誤差を推定します（<code>trans = N</code>）、<code>transpose(A) * X = B</code>（<code>trans = T</code>）、<code>adjoint(A) * X = B</code>（<code>trans = C</code>）で <code>side = L</code> の場合、または <code>trtrs!</code> を使用して <code>X</code> を計算した後の右側の <code>side = R</code> <code>X * A</code> の同等の方程式。<code>uplo = U</code> の場合、<code>A</code> は上三角行列です。<code>uplo = L</code> の場合、<code>A</code> は下三角行列です。<code>diag = N</code> の場合、<code>A</code> は単位でない対角要素を持ちます。<code>diag = U</code> の場合、<code>A</code> のすべての対角要素は1です。<code>Ferr</code> と <code>Berr</code> はオプションの入力です。<code>Ferr</code> は前方誤差で、<code>Berr</code> は後方誤差であり、それぞれ成分ごとです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L3960-L3971">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.stev!" href="#LinearAlgebra.LAPACK.stev!"><code>LinearAlgebra.LAPACK.stev!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stev!(job, dv, ev) -&gt; (dv, Zmat)</code></pre><p>対称トリディアゴナル行列の固有系を計算します。<code>dv</code>は対角成分、<code>ev</code>は非対角成分です。<code>job = N</code>の場合、固有値のみが見つかり、<code>dv</code>に返されます。<code>job = V</code>の場合、固有ベクトルも見つかり、<code>Zmat</code>に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L4154-L4161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.stebz!" href="#LinearAlgebra.LAPACK.stebz!"><code>LinearAlgebra.LAPACK.stebz!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stebz!(range, order, vl, vu, il, iu, abstol, dv, ev) -&gt; (dv, iblock, isplit)</code></pre><p>対称トリディアゴナル行列の固有値を計算します。<code>dv</code> は対角成分、<code>ev</code> は非対角成分です。<code>range = A</code> の場合、すべての固有値が見つかります。<code>range = V</code> の場合、半開区間 <code>(vl, vu]</code> 内の固有値が見つかります。<code>range = I</code> の場合、インデックスが <code>il</code> と <code>iu</code> の間にある固有値が見つかります。<code>order = B</code> の場合、固有値はブロック内で順序付けられます。<code>order = E</code> の場合、すべてのブロック間で順序付けられます。<code>abstol</code> は収束のための許容誤差として設定できます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L4164-L4174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.stegr!" href="#LinearAlgebra.LAPACK.stegr!"><code>LinearAlgebra.LAPACK.stegr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stegr!(jobz, range, dv, ev, vl, vu, il, iu) -&gt; (w, Z)</code></pre><p>対称三重対角行列の固有値（<code>jobz = N</code>）または固有値と固有ベクトル（<code>jobz = V</code>）を計算します。<code>dv</code>が対角成分、<code>ev</code>が非対角成分です。<code>range = A</code>の場合、すべての固有値が見つかります。<code>range = V</code>の場合、半開区間<code>(vl, vu]</code>内の固有値が見つかります。<code>range = I</code>の場合、インデックスが<code>il</code>と<code>iu</code>の間の固有値が見つかります。固有値は<code>w</code>に、固有ベクトルは<code>Z</code>に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L4177-L4187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.stein!" href="#LinearAlgebra.LAPACK.stein!"><code>LinearAlgebra.LAPACK.stein!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stein!(dv, ev_in, w_in, iblock_in, isplit_in)</code></pre><p>対称トリディアゴナル行列の固有ベクトルを計算します。<code>dv</code>は対角成分、<code>ev_in</code>は非対角成分です。<code>w_in</code>は対応する固有ベクトルを見つけるための入力固有値を指定します。<code>iblock_in</code>は<code>w_in</code>の固有値に対応するサブ行列を指定します。<code>isplit_in</code>はサブ行列ブロック間の分割点を指定します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L4190-L4198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.syconv!" href="#LinearAlgebra.LAPACK.syconv!"><code>LinearAlgebra.LAPACK.syconv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syconv!(uplo, A, ipiv) -&gt; (A, work)</code></pre><p>対称行列 <code>A</code>（三角行列に因数分解されたもの）を二つの行列 <code>L</code> と <code>D</code> に変換します。<code>uplo = U</code> の場合、<code>A</code> は上三角行列です。<code>uplo = L</code> の場合、下三角行列です。<code>ipiv</code> は三角因数分解からのピボットベクトルです。<code>A</code> は <code>L</code> と <code>D</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5193-L5201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.sysv!" href="#LinearAlgebra.LAPACK.sysv!"><code>LinearAlgebra.LAPACK.sysv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>対称行列 <code>A</code> に対する <code>A * X = B</code> の解を見つけます。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。<code>B</code> は解 <code>X</code> で上書きされます。<code>A</code> はそのバンチ-カウフマン因子分解で上書きされます。<code>ipiv</code> には因子分解に関するピボット情報が含まれています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5204-L5212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.sytrf!" href="#LinearAlgebra.LAPACK.sytrf!"><code>LinearAlgebra.LAPACK.sytrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sytrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>対称行列 <code>A</code> のバンチ-カウフマン因子分解を計算します。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。</p><p>因子分解によって上書きされた <code>A</code>、ピボットベクトル <code>ipiv</code>、およびエラーコード <code>info</code>（非負整数）を返します。<code>info</code> が正の場合、行列は特異であり、因子分解の対角部分は位置 <code>info</code> で正確にゼロになります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5215-L5226">source</a></section><section><div><pre><code class="language-julia hljs">sytrf!(uplo, A, ipiv) -&gt; (A, ipiv, info)</code></pre><p>対称行列 <code>A</code> のバンチ-カウフマン因子分解を計算します。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。</p><p>因子分解によって上書きされた <code>A</code>、ピボットベクトル <code>ipiv</code>、およびエラーコード <code>info</code> を返します。<code>info</code> が非負の整数である場合、<code>info</code> が正の場合、行列は特異であり、因子分解の対角部分は位置 <code>info</code> で正確にゼロです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5229-L5240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.sytri!" href="#LinearAlgebra.LAPACK.sytri!"><code>LinearAlgebra.LAPACK.sytri!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sytri!(uplo, A, ipiv)</code></pre><p>対称行列 <code>A</code> の逆行列を <code>sytrf!</code> の結果を使用して計算します。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。<code>A</code> はその逆行列で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5243-L5249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.sytrs!" href="#LinearAlgebra.LAPACK.sytrs!"><code>LinearAlgebra.LAPACK.sytrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sytrs!(uplo, A, ipiv, B)</code></pre><p>対称行列 <code>A</code> に対して <code>A * X = B</code> の方程式を <code>sytrf!</code> の結果を使用して解きます。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5252-L5259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.hesv!" href="#LinearAlgebra.LAPACK.hesv!"><code>LinearAlgebra.LAPACK.hesv!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hesv!(uplo, A, B) -&gt; (B, A, ipiv)</code></pre><p>エルミート行列 <code>A</code> に対する <code>A * X = B</code> の解を見つけます。<code>uplo = U</code> の場合、<code>A</code> の上半分が保存されます。<code>uplo = L</code> の場合、下半分が保存されます。<code>B</code> は解 <code>X</code> で上書きされます。<code>A</code> はそのバンチ-カウフマン因子分解で上書きされます。<code>ipiv</code> には因子分解に関するピボッティング情報が含まれています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5263-L5271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.hetrf!" href="#LinearAlgebra.LAPACK.hetrf!"><code>LinearAlgebra.LAPACK.hetrf!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hetrf!(uplo, A) -&gt; (A, ipiv, info)</code></pre><p>エルミート行列 <code>A</code> のバンチ-カウフマン因子分解を計算します。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。</p><p>因子分解によって上書きされた <code>A</code>、ピボットベクトル <code>ipiv</code>、およびエラーコード <code>info</code> を返します。<code>info</code> が非負の整数で、正の値の場合、行列は特異であり、因子分解の対角部分は位置 <code>info</code> で正確にゼロになります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5274-L5285">source</a></section><section><div><pre><code class="language-julia hljs">hetrf!(uplo, A, ipiv) -&gt; (A, ipiv, info)</code></pre><p>エルミート行列 <code>A</code> のバンチ-カウフマン因子分解を計算します。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。</p><p>因子分解によって上書きされた <code>A</code>、ピボットベクトル <code>ipiv</code>、および非負整数のエラーコード <code>info</code> を返します。<code>info</code> が正の場合、行列は特異であり、因子分解の対角部分は位置 <code>info</code> で正確にゼロになります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5288-L5299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.hetri!" href="#LinearAlgebra.LAPACK.hetri!"><code>LinearAlgebra.LAPACK.hetri!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hetri!(uplo, A, ipiv)</code></pre><p>エルミート行列 <code>A</code> の逆行列を <code>sytrf!</code> の結果を使用して計算します。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。<code>A</code> はその逆行列で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5302-L5308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.hetrs!" href="#LinearAlgebra.LAPACK.hetrs!"><code>LinearAlgebra.LAPACK.hetrs!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hetrs!(uplo, A, ipiv, B)</code></pre><p>エルミート行列 <code>A</code> に対して <code>A * X = B</code> の方程式を <code>sytrf!</code> の結果を使用して解きます。<code>uplo = U</code> の場合、<code>A</code> の上半分が格納されます。<code>uplo = L</code> の場合、下半分が格納されます。<code>B</code> は解 <code>X</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5311-L5318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.syev!" href="#LinearAlgebra.LAPACK.syev!"><code>LinearAlgebra.LAPACK.syev!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syev!(jobz, uplo, A)</code></pre><p>対称行列 <code>A</code> の固有値（<code>jobz = N</code>）または固有値と固有ベクトル（<code>jobz = V</code>）を求めます。<code>uplo = U</code> の場合、<code>A</code> の上三角が使用されます。<code>uplo = L</code> の場合、<code>A</code> の下三角が使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5738-L5744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.syevr!" href="#LinearAlgebra.LAPACK.syevr!"><code>LinearAlgebra.LAPACK.syevr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syevr!(jobz, range, uplo, A, vl, vu, il, iu, abstol) -&gt; (W, Z)</code></pre><p>対称行列 <code>A</code> の固有値（<code>jobz = N</code>）または固有値と固有ベクトル（<code>jobz = V</code>）を求めます。<code>uplo = U</code> の場合、<code>A</code> の上三角部分が使用されます。<code>uplo = L</code> の場合、<code>A</code> の下三角部分が使用されます。<code>range = A</code> の場合、すべての固有値が求められます。<code>range = V</code> の場合、半開区間 <code>(vl, vu]</code> 内の固有値が求められます。<code>range = I</code> の場合、インデックスが <code>il</code> と <code>iu</code> の間にある固有値が求められます。<code>abstol</code> は収束のための許容誤差として設定できます。</p><p>固有値は <code>W</code> に、固有ベクトルは <code>Z</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5747-L5759">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.syevd!" href="#LinearAlgebra.LAPACK.syevd!"><code>LinearAlgebra.LAPACK.syevd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syevd!(jobz, uplo, A)</code></pre><p>対称行列 <code>A</code> の固有値（<code>jobz = N</code>）または固有値と固有ベクトル（<code>jobz = V</code>）を求めます。<code>uplo = U</code> の場合、<code>A</code> の上三角が使用されます。<code>uplo = L</code> の場合、<code>A</code> の下三角が使用されます。</p><p><code>syev!</code> によって使用される QR 反復法や、<code>syevr!</code> によって使用される複数の比較的堅牢な表現の代わりに、分割統治法を使用します。異なる手法の精度と性能の比較については、James W. Demmel らによる SIAM J. Sci. Comput. 30, 3, 1508 (2008) を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5763-L5774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.sygvd!" href="#LinearAlgebra.LAPACK.sygvd!"><code>LinearAlgebra.LAPACK.sygvd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sygvd!(itype, jobz, uplo, A, B) -&gt; (w, A, B)</code></pre><p>対称行列 <code>A</code> と対称正定値行列 <code>B</code> の一般化固有値（<code>jobz = N</code>）または固有値と固有ベクトル（<code>jobz = V</code>）を求めます。<code>uplo = U</code> の場合、<code>A</code> と <code>B</code> の上三角が使用されます。<code>uplo = L</code> の場合、<code>A</code> と <code>B</code> の下三角が使用されます。<code>itype = 1</code> の場合、解くべき問題は <code>A * x = lambda * B * x</code> です。<code>itype = 2</code> の場合、解くべき問題は <code>A * B * x = lambda * x</code> です。<code>itype = 3</code> の場合、解くべき問題は <code>B * A * x = lambda * x</code> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5777-L5788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.bdsqr!" href="#LinearAlgebra.LAPACK.bdsqr!"><code>LinearAlgebra.LAPACK.bdsqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bdsqr!(uplo, d, e_, Vt, U, C) -&gt; (d, Vt, U, C)</code></pre><p>バイディアゴナル行列の特異値分解を計算します。対角に <code>d</code>、副対角に <code>e_</code> が配置されています。<code>uplo = U</code> の場合、<code>e_</code> は上対角線です。<code>uplo = L</code> の場合、<code>e_</code> は下対角線です。オプションで、<code>Q&#39; * C</code> の積も計算できます。</p><p>特異値は <code>d</code> に返され、行列 <code>C</code> は <code>Q&#39; * C</code> で上書きされます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5841-L5850">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.bdsdc!" href="#LinearAlgebra.LAPACK.bdsdc!"><code>LinearAlgebra.LAPACK.bdsdc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bdsdc!(uplo, compq, d, e_) -&gt; (d, e, u, vt, q, iq)</code></pre><p>バイディアゴナル行列の特異値分解を計算します。対角に <code>d</code>、オフ対角に <code>e_</code> を持ち、分割統治法を使用します。<code>uplo = U</code> の場合、<code>e_</code> は上対角線です。<code>uplo = L</code> の場合、<code>e_</code> は下対角線です。<code>compq = N</code> の場合、特異値のみが求められます。<code>compq = I</code> の場合、特異値とベクトルが求められます。<code>compq = P</code> の場合、特異値とベクトルがコンパクトな形で求められます。実数型のみに対応しています。</p><p>特異値は <code>d</code> に返され、<code>compq = P</code> の場合、コンパクトな特異ベクトルは <code>iq</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5912-L5924">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gecon!" href="#LinearAlgebra.LAPACK.gecon!"><code>LinearAlgebra.LAPACK.gecon!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gecon!(normtype, A, anorm)</code></pre><p>行列 <code>A</code> の逆条件数を求めます。<code>normtype = I</code> の場合、条件数は無限大ノルムで求められます。<code>normtype = O</code> または <code>1</code> の場合、条件数は1ノルムで求められます。<code>A</code> は <code>getrf!</code> の結果でなければならず、<code>anorm</code> は関連するノルムにおける <code>A</code> のノルムです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L5999-L6006">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gehrd!" href="#LinearAlgebra.LAPACK.gehrd!"><code>LinearAlgebra.LAPACK.gehrd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gehrd!(ilo, ihi, A) -&gt; (A, tau)</code></pre><p>行列 <code>A</code> をヘッセンベルグ形式に変換します。もし <code>A</code> が <code>gebal!</code> でバランスされている場合、<code>ilo</code> と <code>ihi</code> は <code>gebal!</code> の出力です。そうでない場合、<code>ilo = 1</code> および <code>ihi = size(A,2)</code> であるべきです。<code>tau</code> には因子分解の基本反射体が含まれています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L6050-L6057">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.orghr!" href="#LinearAlgebra.LAPACK.orghr!"><code>LinearAlgebra.LAPACK.orghr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orghr!(ilo, ihi, A, tau)</code></pre><p>明示的に <code>gehrd!</code> からの直交/ユニタリ行列 <code>Q</code> を求めます。<code>ilo</code>、<code>ihi</code>、<code>A</code>、および <code>tau</code> は <code>gehrd!</code> への入力/出力に対応している必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L6100-L6105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gees!" href="#LinearAlgebra.LAPACK.gees!"><code>LinearAlgebra.LAPACK.gees!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gees!(jobvs, A) -&gt; (A, vs, w)</code></pre><p>行列 <code>A</code> の固有値（<code>jobvs = N</code>）または固有値とシュルベクトル（<code>jobvs = V</code>）を計算します。<code>A</code> はそのシュル形式で上書きされます。</p><p><code>A</code>、シュルベクトルを含む <code>vs</code>、および固有値を含む <code>w</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L6723-L6731">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gges!" href="#LinearAlgebra.LAPACK.gges!"><code>LinearAlgebra.LAPACK.gges!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gges!(jobvsl, jobvsr, A, B) -&gt; (A, B, alpha, beta, vsl, vsr)</code></pre><p>一般化固有値、一般化シュア形式、左シュアベクトル（<code>jobsvl = V</code>）、または右シュアベクトル（<code>jobvsr = V</code>）を <code>A</code> と <code>B</code> のために計算します。</p><p>一般化固有値は <code>alpha</code> と <code>beta</code> に返されます。左シュアベクトルは <code>vsl</code> に、右シュアベクトルは <code>vsr</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L6735-L6744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.gges3!" href="#LinearAlgebra.LAPACK.gges3!"><code>LinearAlgebra.LAPACK.gges3!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gges3!(jobvsl, jobvsr, A, B) -&gt; (A, B, alpha, beta, vsl, vsr)</code></pre><p>一般化固有値、一般化シュール形式、左シュールベクトル（<code>jobsvl = V</code>）、または右シュールベクトル（<code>jobvsr = V</code>）をブロックアルゴリズムを使用して <code>A</code> と <code>B</code> のために計算します。この関数は LAPACK 3.6.0 を必要とします。</p><p>一般化固有値は <code>alpha</code> と <code>beta</code> に返されます。左シュールベクトルは <code>vsl</code> に、右シュールベクトルは <code>vsr</code> に返されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L6747-L6756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trexc!" href="#LinearAlgebra.LAPACK.trexc!"><code>LinearAlgebra.LAPACK.trexc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trexc!(compq, ifst, ilst, T, Q) -&gt; (T, Q)
trexc!(ifst, ilst, T, Q) -&gt; (T, Q)</code></pre><p>行列のシュア分解 <code>T</code> を再配置し、行インデックス <code>ifst</code> の <code>T</code> の対角ブロックを行インデックス <code>ilst</code> に移動します。<code>compq = V</code> の場合、シュアベクトル <code>Q</code> が再配置されます。<code>compq = N</code> の場合は変更されません。4引数のメソッドは、<code>compq = V</code> で5引数のメソッドを呼び出します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L7067-L7075">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trsen!" href="#LinearAlgebra.LAPACK.trsen!"><code>LinearAlgebra.LAPACK.trsen!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">行列のシュア分解を再順序付けし、オプションで逆条件数を求めます。`job = N` の場合、条件数は求められません。`job = E` の場合、この固有値のクラスターの条件数のみが求められます。`job = V` の場合、不変部分空間の条件数のみが求められます。`job = B` の場合、クラスターと部分空間の条件数が求められます。`compq = V` の場合、シュアベクトル `Q` が更新されます。`compq = N` の場合、シュアベクトルは変更されません。`select` は、どの固有値がクラスターに含まれるかを決定します。3引数メソッドは、`job = N` および `compq = V` で5引数メソッドを呼び出します。

`T`、`Q`、再順序付けされた固有値 `w`、固有値のクラスターの条件数 `s`、および不変部分空間の条件数 `sep` を返します。</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L7078-L7095">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.tgsen!" href="#LinearAlgebra.LAPACK.tgsen!"><code>LinearAlgebra.LAPACK.tgsen!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tgsen!(select, S, T, Q, Z) -&gt; (S, T, alpha, beta, Q, Z)</code></pre><p>一般化シュア分解のベクトルを再配置します。<code>select</code>は各クラスター内の固有値を指定します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L7098-L7103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.trsyl!" href="#LinearAlgebra.LAPACK.trsyl!"><code>LinearAlgebra.LAPACK.trsyl!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trsyl!(transa, transb, A, B, C, isgn=1) -&gt; (C, scale)</code></pre><p>シルベスター行列方程式 <code>A * X +/- X * B = scale*C</code> を解きます。ここで <code>A</code> と <code>B</code> はどちらも準上三角行列です。<code>transa = N</code> の場合、<code>A</code> は変更されません。<code>transa = T</code> の場合、<code>A</code> は転置されます。<code>transa = C</code> の場合、<code>A</code> は共役転置されます。同様に <code>transb</code> と <code>B</code> にも適用されます。<code>isgn = 1</code> の場合、方程式 <code>A * X + X * B = scale * C</code> が解かれます。<code>isgn = -1</code> の場合、方程式 <code>A * X - X * B = scale * C</code> が解かれます。</p><p><code>X</code>（<code>C</code> を上書き）と <code>scale</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L7140-L7151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.LAPACK.hseqr!" href="#LinearAlgebra.LAPACK.hseqr!"><code>LinearAlgebra.LAPACK.hseqr!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hseqr!(job, compz, ilo, ihi, H, Z) -&gt; (H, Z, w)</code></pre><p>行列をヘッセンベルグ形式に減少させたときのすべての固有値と（オプションで）シュール因子分解を計算します。<code>H</code>が<code>gebal!</code>でバランスされている場合、<code>ilo</code>と<code>ihi</code>は<code>gebal!</code>の出力です。そうでない場合、<code>ilo = 1</code>および<code>ihi = size(H,2)</code>とする必要があります。<code>tau</code>には因子分解の基本反射体が含まれています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/stdlib/LinearAlgebra/src/lapack.jl#L6252-L6260">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-ACM832"><a class="tag is-link" href="#citeref-ACM832">ACM832</a>Davis, Timothy A. (2004b). Algorithm 832: UMFPACK V4.3–-an Unsymmetric-Pattern Multifrontal Method. ACM Trans. Math. Softw., 30(2), 196–199. <a href="https://doi.org/10.1145/992200.992206">doi:10.1145/992200.992206</a></li><li class="footnote" id="footnote-ACM887"><a class="tag is-link" href="#citeref-ACM887">ACM887</a>Chen, Y., Davis, T. A., Hager, W. W., &amp; Rajamanickam, S. (2008). Algorithm 887: CHOLMOD, Supernodal Sparse Cholesky Factorization and Update/Downdate. ACM Trans. Math. Softw., 35(3). <a href="https://doi.org/10.1145/1391989.1391995">doi:10.1145/1391989.1391995</a></li><li class="footnote" id="footnote-DavisHager2009"><a class="tag is-link" href="#citeref-DavisHager2009">DavisHager2009</a>Davis, Timothy A., &amp; Hager, W. W. (2009). Dynamic Supernodes in Sparse Cholesky Update/Downdate and Triangular Solves. ACM Trans. Math. Softw., 35(4). <a href="https://doi.org/10.1145/1462173.1462176">doi:10.1145/1462173.1462176</a></li><li class="footnote" id="footnote-Bischof1987"><a class="tag is-link" href="#citeref-Bischof1987">Bischof1987</a>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. <a href="https://doi.org/10.1137/0908009">doi:10.1137/0908009</a></li><li class="footnote" id="footnote-Schreiber1989"><a class="tag is-link" href="#citeref-Schreiber1989">Schreiber1989</a>R Schreiber and C Van Loan, &quot;A storage-efficient WY representation for products of Householder transformations&quot;, SIAM J Sci Stat Comput 10 (1989), 53-57. <a href="https://doi.org/10.1137/0910005">doi:10.1137/0910005</a></li><li class="footnote" id="footnote-ACM933"><a class="tag is-link" href="#citeref-ACM933">ACM933</a>Foster, L. V., &amp; Davis, T. A. (2013). Algorithm 933: Reliable Calculation of Numerical Rank, Null Space Bases, Pseudoinverse Solutions, and Basic Solutions Using SuitesparseQR. ACM Trans. Math. Softw., 40(1). <a href="https://doi.org/10.1145/2513109.2513116">doi:10.1145/2513109.2513116</a></li><li class="footnote" id="footnote-Bunch1977"><a class="tag is-link" href="#citeref-Bunch1977">Bunch1977</a>J R Bunch と L Kaufman, 一部の安定した方法による慣性の計算と対称線形システムの解法, Mathematics of Computation 31:137 (1977), 163-179. <a href="https://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/">url</a>.</li><li class="footnote" id="footnote-issue8859"><a class="tag is-link" href="#citeref-issue8859">issue8859</a>Issue 8859, &quot;Fix least squares&quot;, <a href="https://github.com/JuliaLang/julia/pull/8859">https://github.com/JuliaLang/julia/pull/8859</a></li><li class="footnote" id="footnote-B96"><a class="tag is-link" href="#citeref-B96">B96</a>Åke Björck, &quot;Numerical Methods for Least Squares Problems&quot;,  SIAM Press, Philadelphia, 1996, &quot;Other Titles in Applied Mathematics&quot;, Vol. 51. <a href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></li><li class="footnote" id="footnote-S84"><a class="tag is-link" href="#citeref-S84">S84</a>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></li><li class="footnote" id="footnote-KY88"><a class="tag is-link" href="#citeref-KY88">KY88</a>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a href="https://doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></li><li class="footnote" id="footnote-H05"><a class="tag is-link" href="#citeref-H05">H05</a>Nicholas J. Higham, &quot;The squaring and scaling method for the matrix exponential revisited&quot;, SIAM Journal on Matrix Analysis and Applications, 26(4), 2005, 1179-1193. <a href="https://doi.org/10.1137/090768539">doi:10.1137/090768539</a></li><li class="footnote" id="footnote-BH83"><a class="tag is-link" href="#citeref-BH83">BH83</a>Åke Björck and Sven Hammarling, &quot;A Schur method for the square root of a matrix&quot;, Linear Algebra and its Applications, 52-53, 1983, 127-140. <a href="https://doi.org/10.1016/0024-3795(83)80010-X">doi:10.1016/0024-3795(83)80010-X</a></li><li class="footnote" id="footnote-H87"><a class="tag is-link" href="#citeref-H87">H87</a>Nicholas J. Higham, &quot;Computing real square roots of a real matrix&quot;, Linear Algebra and its Applications, 88-89, 1987, 405-430. <a href="https://doi.org/10.1016/0024-3795(87)90118-2">doi:10.1016/0024-3795(87)90118-2</a></li><li class="footnote" id="footnote-S03"><a class="tag is-link" href="#citeref-S03">S03</a>Matthew I. Smith, &quot;A Schur Algorithm for Computing Matrix pth Roots&quot;, SIAM Journal on Matrix Analysis and Applications, vol. 24, 2003, pp. 971–989. <a href="https://doi.org/10.1137/s0895479801392697">doi:10.1137/S0895479801392697</a></li><li class="footnote" id="footnote-AH16_1"><a class="tag is-link" href="#citeref-AH16_1">AH16_1</a>Mary Aprahamian と Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></li><li class="footnote" id="footnote-AH16_2"><a class="tag is-link" href="#citeref-AH16_2">AH16_2</a>Mary Aprahamian と Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></li><li class="footnote" id="footnote-AH16_3"><a class="tag is-link" href="#citeref-AH16_3">AH16_3</a>Mary Aprahamian と Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></li><li class="footnote" id="footnote-AH16_4"><a class="tag is-link" href="#citeref-AH16_4">AH16_4</a>Mary Aprahamian と Nicholas J. Higham, &quot;行列の逆三角関数と逆双曲線関数: 理論とアルゴリズム&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></li><li class="footnote" id="footnote-AH16_5"><a class="tag is-link" href="#citeref-AH16_5">AH16_5</a>Mary Aprahamian and Nicholas J. Higham, &quot;Matrix Inverse Trigonometric and Inverse Hyperbolic Functions: Theory and Algorithms&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></li><li class="footnote" id="footnote-AH16_6"><a class="tag is-link" href="#citeref-AH16_6">AH16_6</a>Mary Aprahamian と Nicholas J. Higham, &quot;行列の逆三角関数と逆双曲線関数: 理論とアルゴリズム&quot;, MIMS EPrint: 2016.4. <a href="https://doi.org/10.1137/16M1057577">https://doi.org/10.1137/16M1057577</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Libdl.html">« Dynamic Linker</a><a class="docs-footer-nextpage" href="Logging.html">Logging »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 27 May 2025 09:22">Tuesday 27 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
