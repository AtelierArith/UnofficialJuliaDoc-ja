<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrays · The Julia Language</title><meta name="title" content="Arrays · The Julia Language"/><meta property="og:title" content="Arrays · The Julia Language"/><meta property="twitter:title" content="Arrays · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/memory-management.html">Memory Management and Garbage Collection</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li><li><a class="tocitem" href="../manual/worldage.html">The World Age mechanism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Essentials</a></li><li><a class="tocitem" href="collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="math.html">Mathematics</a></li><li><a class="tocitem" href="numbers.html">Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li class="is-active"><a class="tocitem" href="arrays.html">Arrays</a><ul class="internal"><li><a class="tocitem" href="#Constructors-and-Types"><span>Constructors and Types</span></a></li><li><a class="tocitem" href="#Basic-functions"><span>Basic functions</span></a></li><li><a class="tocitem" href="#Broadcast-and-vectorization"><span>Broadcast and vectorization</span></a></li><li><a class="tocitem" href="#Indexing-and-assignment"><span>Indexing and assignment</span></a></li><li><a class="tocitem" href="#Views-(SubArrays-and-other-view-types)"><span>Views (SubArrays and other view types)</span></a></li><li><a class="tocitem" href="#Concatenation-and-permutation"><span>Concatenation and permutation</span></a></li><li><a class="tocitem" href="#Array-functions"><span>Array functions</span></a></li><li><a class="tocitem" href="#Combinatorics"><span>Combinatorics</span></a></li></ul></li><li><a class="tocitem" href="parallel.html">Tasks</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="constants.html">Constants</a></li><li><a class="tocitem" href="file.html">Filesystem</a></li><li><a class="tocitem" href="io-network.html">I/O and Network</a></li><li><a class="tocitem" href="punctuation.html">Punctuation</a></li><li><a class="tocitem" href="sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="c.html">C Interface</a></li><li><a class="tocitem" href="libc.html">C Standard Library</a></li><li><a class="tocitem" href="stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/JuliaSyntaxHighlighting.html">Julia Syntax Highlighting</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="arrays.html">Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="arrays.html">Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/arrays.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="lib-arrays"><a class="docs-heading-anchor" href="#lib-arrays">Arrays</a><a id="lib-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#lib-arrays" title="Permalink"></a></h1><h2 id="Constructors-and-Types"><a class="docs-heading-anchor" href="#Constructors-and-Types">Constructors and Types</a><a id="Constructors-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-and-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.AbstractArray" href="#Core.AbstractArray"><code>Core.AbstractArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractArray{T,N}</code></pre><p>型 <code>T</code> の要素を持つ <code>N</code> 次元配列（または配列のような型）のスーパタイプ。 <a href="arrays.html#Core.Array"><code>Array</code></a> および他の型はこれのサブタイプです。 <a href="../manual/interfaces.html#man-interface-array"><code>AbstractArray</code> インターフェース</a> に関するマニュアルのセクションを参照してください。</p><p>関連情報: <a href="arrays.html#Base.AbstractVector"><code>AbstractVector</code></a>, <a href="arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a>, <a href="collections.html#Base.eltype"><code>eltype</code></a>, <a href="arrays.html#Base.ndims"><code>ndims</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractVector" href="#Base.AbstractVector"><code>Base.AbstractVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractVector{T}</code></pre><p>要素の型が <code>T</code> である一次元配列（または配列に似た型）のスーパークラス。 <a href="arrays.html#Core.AbstractArray"><code>AbstractArray{T,1}</code></a> のエイリアスです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractMatrix" href="#Base.AbstractMatrix"><code>Base.AbstractMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMatrix{T}</code></pre><p>要素の型が <code>T</code> である二次元配列（または配列のような型）のスーパークラス。 <a href="arrays.html#Core.AbstractArray"><code>AbstractArray{T,2}</code></a> のエイリアスです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractVecOrMat" href="#Base.AbstractVecOrMat"><code>Base.AbstractVecOrMat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractVecOrMat{T}</code></pre><p><a href="arrays.html#Base.AbstractVector"><code>AbstractVector{T}</code></a> と <a href="arrays.html#Base.AbstractMatrix"><code>AbstractMatrix{T}</code></a> のユニオン型。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Array" href="#Core.Array"><code>Core.Array</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Array{T,N} &lt;: AbstractArray{T,N}</code></pre><p>型 <code>T</code> の要素を持つ <code>N</code> 次元密な配列。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Array-Tuple{UndefInitializer, Any}" href="#Core.Array-Tuple{UndefInitializer, Any}"><code>Core.Array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Array{T}(undef, dims)
Array{T,N}(undef, dims)</code></pre><p>型 <code>T</code> の要素を含む初期化されていない <code>N</code> 次元の <a href="arrays.html#Core.Array"><code>Array</code></a> を構築します。<code>N</code> は <code>Array{T,N}(undef, dims)</code> のように明示的に指定することも、<code>dims</code> の長さまたは数によって決定されることもあります。<code>dims</code> はタプルまたは各次元の長さに対応する整数引数の系列である場合があります。ランク <code>N</code> が明示的に指定された場合、それは <code>dims</code> の長さまたは数と一致しなければなりません。ここで <a href="arrays.html#Core.undef"><code>undef</code></a> は <a href="arrays.html#Core.UndefInitializer"><code>UndefInitializer</code></a> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Array{Float64, 2}(undef, 2, 3) # N が明示的に指定されている
2×3 Matrix{Float64}:
 6.90198e-310  6.90198e-310  6.90198e-310
 6.90198e-310  6.90198e-310  0.0

julia&gt; B = Array{Float64}(undef, 4) # N が入力によって決定される
4-element Vector{Float64}:
   2.360075077e-314
 NaN
   2.2671131793e-314
   2.299821756e-314

julia&gt; similar(B, 2, 4, 1) # typeof(B) を使用し、指定されたサイズを使う
2×4×1 Array{Float64, 3}:
[:, :, 1] =
 2.26703e-314  2.26708e-314  0.0           2.80997e-314
 0.0           2.26703e-314  2.26708e-314  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2962-L2994">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Array-Tuple{Nothing, Any}" href="#Core.Array-Tuple{Nothing, Any}"><code>Core.Array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Array{T}(nothing, dims)
Array{T,N}(nothing, dims)</code></pre><p><code>T</code>型の要素を含む<code>N</code>次元の<a href="arrays.html#Core.Array"><code>Array</code></a>を構築し、<a href="constants.html#Core.nothing"><code>nothing</code></a>エントリで初期化します。要素型<code>T</code>はこれらの値を保持できる必要があります。すなわち、<code>Nothing &lt;: T</code>です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Array{Union{Nothing, String}}(nothing, 2)
2-element Vector{Union{Nothing, String}}:
 nothing
 nothing

julia&gt; Array{Union{Nothing, Int}}(nothing, 2, 3)
2×3 Matrix{Union{Nothing, Int64}}:
 nothing  nothing  nothing
 nothing  nothing  nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2997-L3017">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Array-Tuple{Missing, Any}" href="#Core.Array-Tuple{Missing, Any}"><code>Core.Array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Array{T}(missing, dims)
Array{T,N}(missing, dims)</code></pre><p><code>T</code>型の要素を含む<code>N</code>次元の<a href="arrays.html#Core.Array"><code>Array</code></a>を構築し、<a href="../manual/missing.html#missing"><code>missing</code></a>エントリで初期化します。要素型<code>T</code>はこれらの値を保持できる必要があります。すなわち、<code>Missing &lt;: T</code>です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Array{Union{Missing, String}}(missing, 2)
2-element Vector{Union{Missing, String}}:
 missing
 missing

julia&gt; Array{Union{Missing, Int}}(missing, 2, 3)
2×3 Matrix{Union{Missing, Int64}}:
 missing  missing  missing
 missing  missing  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3021-L3041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.UndefInitializer" href="#Core.UndefInitializer"><code>Core.UndefInitializer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UndefInitializer</code></pre><p>配列初期化に使用されるシングルトン型で、配列コンストラクタ呼び出し元が初期化されていない配列を希望していることを示します。<code>undef</code>[@ref]のエイリアスである<code>UndefInitializer()</code>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Array{Float64, 1}(UndefInitializer(), 3)
3-element Vector{Float64}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3044-L3059">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.undef" href="#Core.undef"><code>Core.undef</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">undef</code></pre><p><code>UndefInitializer()</code>のエイリアスで、配列初期化に使用されるシングルトン型<a href="arrays.html#Core.UndefInitializer"><code>UndefInitializer</code></a>のインスタンスを構築します。これは、配列コンストラクタ呼び出し元が初期化されていない配列を希望していることを示します。</p><p>関連情報: <a href="../manual/missing.html#missing"><code>missing</code></a>, <a href="arrays.html#Base.similar"><code>similar</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Array{Float64, 1}(undef, 3)
3-element Vector{Float64}:
 2.2752528595e-314
 2.202942107e-314
 2.275252907e-314</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3062-L3079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Vector" href="#Base.Vector"><code>Base.Vector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Vector{T} &lt;: AbstractVector{T}</code></pre><p>要素の型が <code>T</code> の一次元密な配列で、数学的なベクトルを表すためにしばしば使用されます。 <a href="arrays.html#Core.Array"><code>Array{T,1}</code></a> のエイリアスです。</p><p>ベクトルを作成するための <a href="arrays.html#Base.empty"><code>empty</code></a>、<a href="arrays.html#Base.similar"><code>similar</code></a>、および <a href="numbers.html#Base.zero"><code>zero</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Vector-Tuple{UndefInitializer, Any}" href="#Base.Vector-Tuple{UndefInitializer, Any}"><code>Base.Vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Vector{T}(undef, n)</code></pre><p>長さ <code>n</code> の初期化されていない <a href="arrays.html#Base.Vector"><code>Vector{T}</code></a> を構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Vector{Float64}(undef, 3)
3-element Vector{Float64}:
 6.90966e-310
 6.90966e-310
 6.90966e-310</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2858-L2871">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Vector-Tuple{Nothing, Any}" href="#Base.Vector-Tuple{Nothing, Any}"><code>Base.Vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Vector{T}(nothing, m)</code></pre><p>長さ <code>m</code> の <a href="arrays.html#Base.Vector"><code>Vector{T}</code></a> を構築し、<a href="constants.html#Core.nothing"><code>nothing</code></a> エントリで初期化します。要素型 <code>T</code> はこれらの値を保持できる必要があります。すなわち、<code>Nothing &lt;: T</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Vector{Union{Nothing, String}}(nothing, 2)
2-element Vector{Union{Nothing, String}}:
 nothing
 nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2874-L2888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Vector-Tuple{Missing, Any}" href="#Base.Vector-Tuple{Missing, Any}"><code>Base.Vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Vector{T}(missing, m)</code></pre><p>長さ <code>m</code> の <a href="arrays.html#Base.Vector"><code>Vector{T}</code></a> を構築し、<a href="../manual/missing.html#missing"><code>missing</code></a> エントリで初期化します。要素型 <code>T</code> はこれらの値を保持できる必要があります。すなわち、<code>Missing &lt;: T</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Vector{Union{Missing, String}}(missing, 2)
2-element Vector{Union{Missing, String}}:
 missing
 missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2891-L2905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matrix{T} &lt;: AbstractMatrix{T}</code></pre><p>要素の型が <code>T</code> の二次元密な配列で、数学的な行列を表すためにしばしば使用されます。 <a href="arrays.html#Core.Array"><code>Array{T,2}</code></a> のエイリアスです。</p><p>行列を作成するための <a href="arrays.html#Base.fill"><code>fill</code></a>、<a href="arrays.html#Base.zeros"><code>zeros</code></a>、<a href="arrays.html#Core.undef"><code>undef</code></a>、および <a href="arrays.html#Base.similar"><code>similar</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{UndefInitializer, Any, Any}" href="#Base.Matrix-Tuple{UndefInitializer, Any, Any}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matrix{T}(undef, m, n)</code></pre><p>サイズ <code>m</code>×<code>n</code> の初期化されていない <a href="arrays.html#Base.Matrix"><code>Matrix{T}</code></a> を構築します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Matrix{Float64}(undef, 2, 3)
2×3 Matrix{Float64}:
 2.36365e-314  2.28473e-314    5.0e-324
 2.26704e-314  2.26711e-314  NaN

julia&gt; similar(ans, Int32, 2, 2)
2×2 Matrix{Int32}:
 490537216  1277177453
         1  1936748399</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2908-L2925">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{Nothing, Any, Any}" href="#Base.Matrix-Tuple{Nothing, Any, Any}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matrix{T}(nothing, m, n)</code></pre><p>サイズ <code>m</code>×<code>n</code> の <a href="arrays.html#Base.Matrix"><code>Matrix{T}</code></a> を構築し、<a href="constants.html#Core.nothing"><code>nothing</code></a> エントリで初期化します。要素型 <code>T</code> はこれらの値を保持できる必要があります。すなわち、<code>Nothing &lt;: T</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Matrix{Union{Nothing, String}}(nothing, 2, 3)
2×3 Matrix{Union{Nothing, String}}:
 nothing  nothing  nothing
 nothing  nothing  nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2928-L2942">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix-Tuple{Missing, Any, Any}" href="#Base.Matrix-Tuple{Missing, Any, Any}"><code>Base.Matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Matrix{T}(missing, m, n)</code></pre><p>サイズ <code>m</code>×<code>n</code> の <a href="arrays.html#Base.Matrix"><code>Matrix{T}</code></a> を作成し、<a href="../manual/missing.html#missing"><code>missing</code></a> エントリで初期化します。要素型 <code>T</code> はこれらの値を保持できる必要があります。すなわち、<code>Missing &lt;: T</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Matrix{Union{Missing, String}}(missing, 2, 3)
2×3 Matrix{Union{Missing, String}}:
 missing  missing  missing
 missing  missing  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2945-L2959">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.VecOrMat" href="#Base.VecOrMat"><code>Base.VecOrMat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VecOrMat{T}</code></pre><p><a href="arrays.html#Base.Vector"><code>Vector{T}</code></a> と <a href="arrays.html#Base.Matrix"><code>Matrix{T}</code></a> のユニオン型で、関数が行列またはベクトルのいずれかを受け入れることを可能にします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Vector{Float64} &lt;: VecOrMat{Float64}
true

julia&gt; Matrix{Float64} &lt;: VecOrMat{Float64}
true

julia&gt; Array{Float64, 3} &lt;: VecOrMat{Float64}
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L73-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.DenseArray" href="#Core.DenseArray"><code>Core.DenseArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseArray{T, N} &lt;: AbstractArray{T,N}</code></pre><p><code>N</code>次元の密な配列で、要素の型は <code>T</code> です。密な配列の要素は、メモリ内に連続して格納されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.DenseVector" href="#Base.DenseVector"><code>Base.DenseVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseVector{T}</code></pre><p>要素の型が <code>T</code> の一次元 <a href="arrays.html#Core.DenseArray"><code>DenseArray</code></a>。<code>DenseArray{T,1}</code> のエイリアスです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.DenseMatrix" href="#Base.DenseMatrix"><code>Base.DenseMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseMatrix{T}</code></pre><p>要素の型が <code>T</code> の二次元 <a href="arrays.html#Core.DenseArray"><code>DenseArray</code></a>。<code>DenseArray{T,2}</code> のエイリアスです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.DenseVecOrMat" href="#Base.DenseVecOrMat"><code>Base.DenseVecOrMat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DenseVecOrMat{T}</code></pre><p><a href="arrays.html#Base.DenseVector"><code>DenseVector{T}</code></a> と <a href="arrays.html#Base.DenseMatrix"><code>DenseMatrix{T}</code></a> のユニオン型。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.StridedArray" href="#Base.StridedArray"><code>Base.StridedArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StridedArray{T, N}</code></pre><p>共通の配列型のハードコーディングされた <a href="base.html#Core.Union"><code>Union</code></a> で、<a href="../manual/interfaces.html#man-interface-strided-arrays">ストライド配列インターフェース</a> に従い、要素の型は <code>T</code> で次元は <code>N</code> です。</p><p>もし <code>A</code> が <code>StridedArray</code> であれば、その要素はメモリ内にオフセットで格納され、次元間で異なる場合がありますが、次元内では一定です。例えば、<code>A</code> は次元 1 でストライド 2 を持ち、次元 2 でストライド 3 を持つ可能性があります。次元 <code>d</code> に沿って <code>A</code> をインクリメントすると、メモリ内で [<code>stride(A, d)</code>] スロット分ジャンプします。ストライド配列は特に重要で便利であり、時には BLAS のような外国語ライブラリにポインタとして直接渡すことができます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3643-L3655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.StridedVector" href="#Base.StridedVector"><code>Base.StridedVector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StridedVector{T}</code></pre><p>要素の型が <code>T</code> の一次元 <a href="arrays.html#Base.StridedArray"><code>StridedArray</code></a> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3658-L3662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.StridedMatrix" href="#Base.StridedMatrix"><code>Base.StridedMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StridedMatrix{T}</code></pre><p>要素の型が <code>T</code> の二次元 <a href="arrays.html#Base.StridedArray"><code>StridedArray</code></a> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3665-L3669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.StridedVecOrMat" href="#Base.StridedVecOrMat"><code>Base.StridedVecOrMat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StridedVecOrMat{T}</code></pre><p>要素の型が <code>T</code> の <a href="arrays.html#Base.StridedVector"><code>StridedVector</code></a> と <a href="arrays.html#Base.StridedMatrix"><code>StridedMatrix</code></a> のユニオン型。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3672-L3676">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.GenericMemory" href="#Core.GenericMemory"><code>Core.GenericMemory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericMemory{kind::Symbol, T, addrspace=Core.CPU} &lt;: DenseVector{T}</code></pre><p>固定サイズの <a href="arrays.html#Base.DenseVector"><code>DenseVector{T}</code></a>。</p><p><code>kind</code> は現在 <code>:not_atomic</code> または <code>:atomic</code> のいずれかに設定できます。 <code>:atomic</code> が意味する詳細については、<a href="multi-threading.html#Core.AtomicMemory"><code>AtomicMemory</code></a> を参照してください。</p><p><code>addrspace</code> は現在 <code>Core.CPU</code> にのみ設定できます。これは、GPUなどの他のシステムによる拡張を許可するように設計されており、次のような値を定義する可能性があります：</p><pre><code class="language-julia hljs">module CUDA
const Generic = bitcast(Core.AddrSpace{CUDA}, 0)
const Global = bitcast(Core.AddrSpace{CUDA}, 1)
end</code></pre><p>これらの他のアドレス空間の正確な意味は特定のバックエンドによって定義されますが、ユーザーがCPU上でこれらにアクセスしようとするとエラーになります。</p><div class="admonition is-compat" id="Julia-1.11-2c5b98ef32e2c8bb"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-2c5b98ef32e2c8bb" title="Permalink"></a></header><div class="admonition-body"><p>この型はJulia 1.11以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/genericmemory.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Memory" href="#Core.Memory"><code>Core.Memory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Memory{T} == GenericMemory{:not_atomic, T, Core.CPU}</code></pre><p>固定サイズの <a href="arrays.html#Base.DenseVector"><code>DenseVector{T}</code></a>。</p><div class="admonition is-compat" id="Julia-1.11-9a5a35769c7a5fc3"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-9a5a35769c7a5fc3" title="Permalink"></a></header><div class="admonition-body"><p>この型はJulia 1.11以降を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/genericmemory.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.memoryref" href="#Core.memoryref"><code>Core.memoryref</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">memoryref(::GenericMemory, index::Integer)
memoryref(::GenericMemoryRef, index::Integer)</code></pre><p>メモリオブジェクトとオフセットインデックス（1ベース、負の値も可）から<code>GenericMemoryRef</code>を構築します。これは常に境界内のオブジェクトを返し、そうでない場合（インデックスが基盤となるメモリの境界を超えるシフトを引き起こす場合）にはエラーをスローします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2847-L2855">source</a></section><section><div><pre><code class="language-julia hljs">memoryref(::GenericMemory)</code></pre><p>メモリオブジェクトから <code>GenericMemoryRef</code> を構築します。これは失敗することはありませんが、結果として得られるメモリは、メモリが空である場合にのみ、範囲外を指します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L2839-L2844">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Slices" href="#Base.Slices"><code>Base.Slices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Slices{P,SM,AX,S,N} &lt;: AbstractSlices{S,N}</code></pre><p>指定された次元に対する親配列へのスライスの<code>AbstractArray</code>であり、他の次元からすべてのデータを選択するビューを返します。</p><p>これらは通常、<a href="arrays.html#Base.eachslice"><code>eachslice</code></a>、<a href="arrays.html#Base.eachcol"><code>eachcol</code></a>または<a href="arrays.html#Base.eachrow"><code>eachrow</code></a>によって構築されるべきです。</p><p><a href="arrays.html#Base.parent"><code>parent(s::Slices)</code></a>は親配列を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/slicearray.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.RowSlices" href="#Base.RowSlices"><code>Base.RowSlices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RowSlices{M,AX,S}</code></pre><p>行列の行スライスのベクトルである<a href="arrays.html#Base.Slices"><code>Slices</code></a>の特別なケースであり、<a href="arrays.html#Base.eachrow"><code>eachrow</code></a>によって構築されます。</p><p><a href="arrays.html#Base.parent"><code>parent</code></a>を使用して、基になる行列を取得できます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/slicearray.jl#L207-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ColumnSlices" href="#Base.ColumnSlices"><code>Base.ColumnSlices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ColumnSlices{M,AX,S}</code></pre><p><a href="arrays.html#Base.Slices"><code>Slices</code></a> の特別なケースで、行列の列スライスのベクトルであり、<a href="arrays.html#Base.eachcol"><code>eachcol</code></a> によって構築されます。</p><p><a href="arrays.html#Base.parent"><code>parent</code></a> を使用して、基になる行列を取得できます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/slicearray.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{Type, Vararg{Any}}" href="#Base.getindex-Tuple{Type, Vararg{Any}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(type[, elements...])</code></pre><p>指定された型の1次元配列を構築します。これは通常、<code>Type[]</code>という構文で呼び出されます。要素の値は<code>Type[a,b,c,...]</code>を使用して指定できます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Int8[1, 2, 3]
3-element Vector{Int8}:
 1
 2
 3

julia&gt; getindex(Int8, 1, 2, 3)
3-element Vector{Int8}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L381-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zeros([T=Float64,] dims::Tuple)
zeros([T=Float64,] dims...)</code></pre><p>要素型 <code>T</code> のすべてのゼロからなる <code>Array</code> を、<code>dims</code> で指定されたサイズで作成します。詳細は <a href="arrays.html#Base.fill"><code>fill</code></a>、<a href="arrays.html#Base.ones"><code>ones</code></a>、<a href="numbers.html#Base.zero"><code>zero</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zeros(1)
1-element Vector{Float64}:
 0.0

julia&gt; zeros(Int8, 2, 3)
2×3 Matrix{Int8}:
 0  0  0
 0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L546-L564">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ones([T=Float64,] dims::Tuple)
ones([T=Float64,] dims...)</code></pre><p>指定されたサイズ <code>dims</code> のすべての要素が1の、要素型 <code>T</code> の <code>Array</code> を作成します。 <a href="arrays.html#Base.fill"><code>fill</code></a> や <a href="arrays.html#Base.zeros"><code>zeros</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ones(1,2)
1×2 Matrix{Float64}:
 1.0  1.0

julia&gt; ones(ComplexF64, 2, 3)
2×3 Matrix{ComplexF64}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L567-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.BitArray" href="#Base.BitArray"><code>Base.BitArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BitArray{N} &lt;: AbstractArray{Bool, N}</code></pre><p>スペース効率の良い <code>N</code> 次元ブール配列で、各ブール値に対して1ビットのみを使用します。</p><p><code>BitArray</code> は、64の値を8バイトごとにパックし、<code>Array{Bool, N}</code> に対して8倍のスペース効率を実現し、いくつかの操作が64の値に対して一度に動作することを可能にします。</p><p>デフォルトでは、Juliaはブール要素を生成する <a href="../manual/arrays.html#Broadcasting">broadcasting</a> 操作（<code>.==</code> のようなドット比較を含む）や、関数 <a href="arrays.html#Base.trues"><code>trues</code></a> および <a href="arrays.html#Base.falses"><code>falses</code></a> から <code>BitArrays</code> を返します。</p><div class="admonition is-info" id="Note-ba39178bb94fd365"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ba39178bb94fd365" title="Permalink"></a></header><div class="admonition-body"><p>パックされたストレージ形式のため、少なくとも1つの要素が書き込みである <code>BitArray</code> の要素への同時アクセスはスレッドセーフではありません。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/bitarray.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.BitArray-Tuple{UndefInitializer, Vararg{Integer}}" href="#Base.BitArray-Tuple{UndefInitializer, Vararg{Integer}}"><code>Base.BitArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BitArray(undef, dims::Integer...)
BitArray{N}(undef, dims::NTuple{N,Int})</code></pre><p>与えられた次元を持つ未定義の <a href="arrays.html#Base.BitArray"><code>BitArray</code></a> を構築します。 <a href="arrays.html#Core.Array"><code>Array</code></a> コンストラクタと同様に動作します。 <a href="arrays.html#Core.undef"><code>undef</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BitArray(undef, 2, 2)
2×2 BitMatrix:
 0  0
 0  0

julia&gt; BitArray(undef, (3, 1))
3×1 BitMatrix:
 0
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/bitarray.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.BitArray-Tuple{Any}" href="#Base.BitArray-Tuple{Any}"><code>Base.BitArray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BitArray(itr)</code></pre><p>与えられたイテラブルオブジェクトによって生成された<a href="arrays.html#Base.BitArray"><code>BitArray</code></a>を構築します。形状は<code>itr</code>オブジェクトから推測されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BitArray([1 0; 0 1])
2×2 BitMatrix:
 1  0
 0  1

julia&gt; BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitMatrix:
 0  1  0
 1  0  0

julia&gt; BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitVector:
 0
 1
 0
 1
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/bitarray.jl#L549-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.trues" href="#Base.trues"><code>Base.trues</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trues(dims)</code></pre><p>すべての値が <code>true</code> に設定された <code>BitArray</code> を作成します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trues(2,3)
2×3 BitMatrix:
 1  1  1
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/bitarray.jl#L409-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.falses" href="#Base.falses"><code>Base.falses</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">falses(dims)</code></pre><p>すべての値が <code>false</code> に設定された <code>BitArray</code> を作成します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; falses(2,3)
2×3 BitMatrix:
 0  0  0
 0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/bitarray.jl#L390-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill" href="#Base.fill"><code>Base.fill</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill(value, dims::Tuple)
fill(value, dims...)</code></pre><p>サイズ <code>dims</code> の配列を作成し、すべての位置を <code>value</code> に設定します。</p><p>例えば、<code>fill(1.0, (5,5))</code> は、5×5 の浮動小数点数の配列を返し、配列のすべての位置に <code>1.0</code> が入ります。</p><p>次元の長さ <code>dims</code> は、タプルまたは引数のシーケンスとして指定できます。<code>N</code> 長のタプルまたは <code>value</code> に続く <code>N</code> の引数は、<code>N</code> 次元の配列を指定します。したがって、ゼロ次元の配列を作成し、その唯一の位置を <code>x</code> に設定する一般的な慣用句は <code>fill(x)</code> です。</p><p>返された配列のすべての位置は、渡された <code>value</code> に設定されており、したがって <a href="base.html#Core.:==="><code>===</code></a> です。これは、<code>value</code> 自体が変更されると、<code>fill</code> された配列のすべての要素がその変更を反映することを意味します。なぜなら、それらは <em>まだ</em> その <code>value</code> だからです。<code>fill(1.0, (5,5))</code> では、<code>value</code> <code>1.0</code> は不変であり、変更できないため、問題はありませんが、配列のような可変値では予期しない結果になることがあります。例えば、<code>fill([], 3)</code> は、返されたベクトルのすべての3つの位置に <em>まったく同じ</em> 空の配列を配置します：</p><pre><code class="language-julia-repl hljs">julia&gt; v = fill([], 3)
3-element Vector{Vector{Any}}:
 []
 []
 []

julia&gt; v[1] === v[2] === v[3]
true

julia&gt; value = v[1]
Any[]

julia&gt; push!(value, 867_5309)
1-element Vector{Any}:
 8675309

julia&gt; v
3-element Vector{Vector{Any}}:
 [8675309]
 [8675309]
 [8675309]</code></pre><p>多くの独立した内部配列を作成するには、代わりに <a href="../manual/arrays.html#man-comprehensions">comprehension</a> を使用してください。これにより、ループの各反復で新しく異なる配列が作成されます：</p><pre><code class="language-julia-repl hljs">julia&gt; v2 = [[] for _ in 1:3]
3-element Vector{Vector{Any}}:
 []
 []
 []

julia&gt; v2[1] === v2[2] === v2[3]
false

julia&gt; push!(v2[1], 8675309)
1-element Vector{Any}:
 8675309

julia&gt; v2
3-element Vector{Vector{Any}}:
 [8675309]
 []
 []</code></pre><p>関連情報: <a href="arrays.html#Base.fill!"><code>fill!</code></a>, <a href="arrays.html#Base.zeros"><code>zeros</code></a>, <a href="arrays.html#Base.ones"><code>ones</code></a>, <a href="arrays.html#Base.similar"><code>similar</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fill(1.0, (2,3))
2×3 Matrix{Float64}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; fill(42)
0-dimensional Array{Int64, 0}:
42

julia&gt; A = fill(zeros(2), 2) # 両方の要素を同じ [0.0, 0.0] ベクトルに設定
2-element Vector{Vector{Float64}}:
 [0.0, 0.0]
 [0.0, 0.0]

julia&gt; A[1][1] = 42; # 塗りつぶされた値を [42.0, 0.0] に変更

julia&gt; A # A[1] と A[2] はまったく同じベクトル
2-element Vector{Vector{Float64}}:
 [42.0, 0.0]
 [42.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L442-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill!" href="#Base.fill!"><code>Base.fill!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill!(A, x)</code></pre><p>配列 <code>A</code> を値 <code>x</code> で埋めます。<code>x</code> がオブジェクト参照の場合、すべての要素は同じオブジェクトを参照します。<code>fill!(A, Foo())</code> は <code>Foo()</code> を一度評価した結果で埋められた <code>A</code> を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(2,3)
2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2.)
2×3 Matrix{Float64}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A
3-element Vector{Vector{Int64}}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia&gt; x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())
3-element Vector{Int64}:
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L1150-L1181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.empty" href="#Base.empty"><code>Base.empty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">empty(a::AbstractDict, [index_type=keytype(a)], [value_type=valtype(a)])</code></pre><p>空の <code>AbstractDict</code> コンテナを作成し、<code>index_type</code> 型のインデックスと <code>value_type</code> 型の値を受け入れることができます。第二および第三の引数はオプションで、入力の <code>keytype</code> と <code>valtype</code> にそれぞれデフォルト設定されています。（2つの型のうち1つだけが指定された場合、それは <code>value_type</code> と見なされ、<code>index_type</code> は <code>keytype(a)</code> にデフォルト設定されます）。</p><p>カスタム <code>AbstractDict</code> サブタイプは、与えられたインデックスおよび値の型に最適な辞書型を返すために、3引数のシグネチャに特化することができます。デフォルトは空の <code>Dict</code> を返すことです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractdict.jl#L182-L193">source</a></section><section><div><pre><code class="language-julia hljs">empty(v::AbstractVector, [eltype])</code></pre><p><code>v</code>に似た空のベクトルを作成し、オプションで<code>eltype</code>を変更します。</p><p>参照: <a href="collections.html#Base.empty!"><code>empty!</code></a>, <a href="collections.html#Base.isempty"><code>isempty</code></a>, <a href="arrays.html#Base.isassigned"><code>isassigned</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; empty([1.0, 2.0, 3.0])
Float64[]

julia&gt; empty([1.0, 2.0, 3.0], String)
String[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L869-L885">source</a></section><section><div><pre><code class="language-julia hljs">empty(x::Tuple)</code></pre><p>空のタプル <code>()</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/tuple.jl#L684-L688">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar" href="#Base.similar"><code>Base.similar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar(A::AbstractSparseMatrixCSC{Tv,Ti}, [::Type{TvNew}, ::Type{TiNew}, m::Integer, n::Integer]) where {Tv,Ti}</code></pre><p>与えられた要素型、インデックス型、およびサイズに基づいて、指定されたソース <code>SparseMatrixCSC</code> に基づいて初期化されていない可変配列を作成します。新しいスパース行列は、出力行列の次元が異なる場合を除いて、元のスパース行列の構造を維持します。</p><p>出力行列は、入力と同じ位置にゼロを持ちますが、非ゼロの位置には初期化されていない値を持ちます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SparseArrays.jl/blob/5d674dc7bd90156cf8ecea4e143b69b5a5b7640d/src/sparsematrix.jl#L708-L719">source</a></section><section><div><pre><code class="language-julia hljs">similar(storagetype, axes)</code></pre><p>指定された <code>storagetype</code> に類似した初期化されていない可変配列を作成しますが、最後の引数で指定された <code>axes</code> を持ちます。</p><p><strong>例</strong>:</p><pre><code class="language-julia hljs">similar(Array{Int}, axes(A))</code></pre><p>は、<code>Array{Int}</code> のように「動作する」配列を作成します（実際にその配列に基づいている可能性があります）が、インデックスは <code>A</code> と同じになります。<code>A</code> が従来のインデックス付けを持つ場合、これは <code>Array{Int}(undef, size(A))</code> と同じになりますが、<code>A</code> が非従来のインデックス付けを持つ場合、結果のインデックスは <code>A</code> に一致します。</p><pre><code class="language-julia hljs">similar(BitArray, (axes(A, 2),))</code></pre><p>は、<code>A</code> の列のインデックスに一致する1次元の論理配列を作成します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L843-L864">source</a></section><section><div><pre><code class="language-julia hljs">similar(array, [element_type=eltype(array)], [dims=size(array)])</code></pre><p>指定された要素型とサイズを持つ初期化されていない可変配列を、指定されたソース配列に基づいて作成します。第二引数と第三引数はどちらもオプションで、指定された配列の <code>eltype</code> と <code>size</code> にデフォルト設定されています。次元は、単一のタプル引数として指定するか、一連の整数引数として指定できます。</p><p>カスタム <code>AbstractArray</code> サブタイプは、指定された要素型と次元に最も適した配列型を返すことを選択できます。このメソッドを特化しない場合、デフォルトは <code>Array{element_type}(undef, dims...)</code> です。</p><p>例えば、<code>similar(1:10, 1, 4)</code> は初期化されていない <code>Array{Int,2}</code> を返します。なぜなら、範囲は可変でもなく、2次元をサポートしていないからです：</p><pre><code class="language-julia-repl hljs">julia&gt; similar(1:10, 1, 4)
1×4 Matrix{Int64}:
 4419743872  4374413872  4419743888  0</code></pre><p>逆に、<code>similar(trues(10,10), 2)</code> は2つの要素を持つ初期化されていない <code>BitVector</code> を返します。なぜなら、<code>BitArray</code> は可変であり、1次元配列をサポートできるからです：</p><pre><code class="language-julia-repl hljs">julia&gt; similar(trues(10,10), 2)
2-element BitVector:
 0
 0</code></pre><p>ただし、<code>BitArray</code> は <a href="numbers.html#Core.Bool"><code>Bool</code></a> 型の要素しか格納できないため、異なる要素型を要求すると、通常の <code>Array</code> が作成されます：</p><pre><code class="language-julia-repl hljs">julia&gt; similar(falses(10), Float64, 2, 4)
2×4 Matrix{Float64}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314</code></pre><p>参照： <a href="arrays.html#Core.undef"><code>undef</code></a>, <a href="arrays.html#Base.isassigned"><code>isassigned</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L777-L819">source</a></section></article><h2 id="Basic-functions"><a class="docs-heading-anchor" href="#Basic-functions">Basic functions</a><a id="Basic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ndims" href="#Base.ndims"><code>Base.ndims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ndims(A::AbstractArray) -&gt; Integer</code></pre><p><code>A</code>の次元数を返します。</p><p>関連: <a href="arrays.html#Base.size"><code>size</code></a>, <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (3,4,5));

julia&gt; ndims(A)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L259-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(A::AbstractArray, [dim])</code></pre><p><code>A</code>の次元を含むタプルを返します。オプションで、特定の次元を指定することで、その次元の長さを取得できます。</p><p><code>size</code>は非標準インデックスを持つ配列に対して定義されていない場合があるため、その場合は<a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>が役立つかもしれません。カスタムインデックスを持つ配列に関するマニュアルの章を参照してください。<a href="../devdocs/offset-arrays.html#man-custom-indices">arrays with custom indices</a>。</p><p>関連: <a href="collections.html#Base.length"><code>length</code></a>, <a href="arrays.html#Base.ndims"><code>ndims</code></a>, <a href="arrays.html#Base.eachindex"><code>eachindex</code></a>, <a href="base.html#Base.sizeof-Tuple{Type}"><code>sizeof</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (2,3,4));

julia&gt; size(A)
(2, 3, 4)

julia&gt; size(A, 2)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L20-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.axes-Tuple{Any}" href="#Base.axes-Tuple{Any}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axes(A)</code></pre><p>配列 <code>A</code> の有効なインデックスのタプルを返します。</p><p>参照: <a href="arrays.html#Base.size"><code>size</code></a>, <a href="collections.html#Base.keys"><code>keys</code></a>, <a href="arrays.html#Base.eachindex"><code>eachindex</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L80-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.axes-Tuple{AbstractArray, Any}" href="#Base.axes-Tuple{AbstractArray, Any}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">axes(A, d)</code></pre><p>配列 <code>A</code> の次元 <code>d</code> に沿った有効なインデックスの範囲を返します。</p><p>他にも <a href="arrays.html#Base.size"><code>size</code></a> や、<a href="../devdocs/offset-arrays.html#man-custom-indices">カスタムインデックスを持つ配列</a>に関するマニュアルの章を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A, 2)
Base.OneTo(6)

julia&gt; axes(A, 4) == 1:1  # ndims(A) より大きいすべての次元 d はサイズ 1
true</code></pre><p><strong>使用上の注意</strong></p><p>各インデックスは <code>AbstractUnitRange{&lt;:Integer}</code> でなければなりませんが、同時にカスタムインデックスを使用する型であることもできます。例えば、サブセットが必要な場合は、<code>begin</code>/<code>end</code> や <a href="collections.html#Base.firstindex"><code>firstindex</code></a>/<a href="collections.html#Base.lastindex"><code>lastindex</code></a> のような一般化されたインデクシング構文を使用してください：</p><pre><code class="language-julia hljs">ix = axes(v, 1)
ix[2:end]          # 例えばベクターには機能しますが、一般には失敗する可能性があります
ix[(begin+1):end]  # 一般化されたインデックスには機能します</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L44-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{AbstractArray}" href="#Base.length-Tuple{AbstractArray}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(A::AbstractArray)</code></pre><p>配列内の要素数を返します。デフォルトでは <code>prod(size(A))</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L301-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.keys-Tuple{AbstractArray}" href="#Base.keys-Tuple{AbstractArray}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keys(a::AbstractArray)</code></pre><p><code>a</code>の形状に配置されたすべての有効なインデックスを記述する効率的な配列を返します。</p><p>1次元配列（ベクトル）のキーは整数ですが、他のすべてのN次元配列は<a href="arrays.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a>を使用してその位置を記述します。特に、特別な配列タイプ<a href="arrays.html#Base.LinearIndices"><code>LinearIndices</code></a>と<a href="arrays.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>は、それぞれこれらの整数と<code>CartesianIndex</code>の配列を効率的に表現するために使用されます。</p><p>配列の<code>keys</code>が最も効率的なインデックスタイプでない場合があることに注意してください。最大のパフォーマンスを得るには、代わりに<a href="arrays.html#Base.eachindex"><code>eachindex</code></a>を使用してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; keys([4, 5, 6])
3-element LinearIndices{1, Tuple{Base.OneTo{Int64}}}:
 1
 2
 3

julia&gt; keys([4 5; 6 7])
CartesianIndices((2, 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L140-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachindex" href="#Base.eachindex"><code>Base.eachindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachindex(A...)
eachindex(::IndexStyle, A::AbstractArray...)</code></pre><p><code>AbstractArray</code> <code>A</code> の各インデックスを効率的に訪問するためのイテラブルオブジェクトを作成します。高速な線形インデックスを選択した配列タイプ（<code>Array</code> など）では、これは単に <code>1:length(A)</code> の範囲になります（1ベースのインデックスを使用している場合）。高速な線形インデックスを選択していない配列タイプでは、通常、すべての次元に対して指定されたインデックスで配列に効率的にインデックスを付けるための特別なカートesian範囲が返されます。</p><p>一般に <code>eachindex</code> は任意のイテラブル（文字列や辞書を含む）を受け入れ、任意のインデックスタイプ（例えば、不均等に間隔を空けたインデックスや非整数インデックス）をサポートするイテレータオブジェクトを返します。</p><p><code>A</code> が <code>AbstractArray</code> の場合、<code>eachindex</code> によって返されるインデックスのスタイルを明示的に指定することが可能で、最初の引数として <code>IndexStyle</code> 型の値を渡すことで行います（通常は線形インデックスが必要な場合は <code>IndexLinear()</code>、カートesian範囲が必要な場合は <code>IndexCartesian()</code>）。</p><p>複数の <code>AbstractArray</code> 引数を供給すると、<code>eachindex</code> はすべての引数に対して高速なイテラブルオブジェクトを作成します（通常はすべての入力が高速な線形インデックスを持つ場合は <a href="collections.html#Base.UnitRange"><code>UnitRange</code></a>、そうでない場合は <a href="arrays.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a>）。配列のサイズや次元が異なる場合、<code>DimensionMismatch</code> 例外がスローされます。</p><p>インデックスと値を一緒に反復するために <a href="collections.html#Base.pairs"><code>pairs</code></a><code>(A)</code> を、1次元に沿った有効なインデックスのために <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a><code>(A, 2)</code> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [10 20; 30 40];

julia&gt; for i in eachindex(A) # 線形インデックス
           println(&quot;A[&quot;, i, &quot;] == &quot;, A[i])
       end
A[1] == 10
A[2] == 30
A[3] == 20
A[4] == 40

julia&gt; for i in eachindex(view(A, 1:2, 1:1)) # カートesianインデックス
           println(i)
       end
CartesianIndex(1, 1)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L331-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IndexStyle" href="#Base.IndexStyle"><code>Base.IndexStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IndexStyle(A)
IndexStyle(typeof(A))</code></pre><p><code>IndexStyle</code>は配列<code>A</code>の「ネイティブインデックススタイル」を指定します。新しい<a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a>型を定義する際には、線形インデックス（<a href="arrays.html#Base.IndexLinear"><code>IndexLinear</code></a>を使用）または直交インデックスのいずれかを実装することを選択できます。線形インデックスのみを実装することに決めた場合は、この特性を配列型に設定する必要があります：</p><pre><code class="language-julia hljs">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>デフォルトは<a href="arrays.html#Base.IndexCartesian"><code>IndexCartesian()</code></a>です。</p><p>Juliaの内部インデックス機構は、すべてのインデックス操作を自動的に（かつ目に見えない形で）好ましいスタイルに再計算します。これにより、ユーザーは明示的なメソッドが提供されていない場合でも、任意のインデックススタイルを使用して配列の要素にアクセスできます。</p><p><code>AbstractArray</code>の両方のインデックススタイルを定義した場合、この特性は最もパフォーマンスの良いインデックススタイルを選択するために使用できます。一部のメソッドはその入力に対してこの特性をチェックし、最も効率的なアクセスパターンに応じて異なるアルゴリズムにディスパッチします。特に、<a href="arrays.html#Base.eachindex"><code>eachindex</code></a>はこの特性の設定に依存するイテレータを作成します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L68-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IndexLinear" href="#Base.IndexLinear"><code>Base.IndexLinear</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IndexLinear()</code></pre><p><a href="arrays.html#Base.IndexStyle"><code>IndexStyle</code></a> のサブタイプで、1つの線形インデックスで最適にインデックス付けされる配列を説明するために使用されます。</p><p>線形インデックススタイルは、配列内の位置を記述するために1つの整数インデックスを使用します（多次元配列であっても）および列優先順序を使用して要素に効率的にアクセスします。これは、<code>IndexLinear</code> の配列から <a href="arrays.html#Base.eachindex"><code>eachindex</code></a> を要求すると、たとえそれが多次元であっても、単純な1次元範囲が返されることを意味します。</p><p><code>IndexStyle</code> を <code>IndexLinear</code> として報告するカスタム配列は、単一の <code>Int</code> インデックスでインデックス付け（およびインデックス付き代入）を実装する必要があります。他のすべてのインデックス式 — 多次元アクセスを含む — は線形インデックスに再計算されます。たとえば、<code>A</code> が線形インデックスを持つ <code>2×3</code> のカスタム行列であり、<code>A[1, 3]</code> を参照した場合、これは同等の線形インデックスに再計算され、<code>A[5]</code> が呼び出されます。なぜなら、<code>1 + 2*(3 - 1) = 5</code> だからです。</p><p><a href="arrays.html#Base.IndexCartesian"><code>IndexCartesian</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IndexCartesian" href="#Base.IndexCartesian"><code>Base.IndexCartesian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IndexCartesian()</code></pre><p><a href="arrays.html#Base.IndexStyle"><code>IndexStyle</code></a> のサブタイプで、Cartesianインデックスによって最適にインデックス付けされる配列を説明するために使用されます。これは新しいカスタム <a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a> サブタイプのデフォルトです。</p><p>Cartesianインデックススタイルは、複数の整数インデックスを使用して多次元配列内の位置を説明し、各次元に対して正確に1つのインデックスを持ちます。これは、<code>IndexCartesian</code> の配列から <a href="arrays.html#Base.eachindex"><code>eachindex</code></a> を要求すると、<a href="arrays.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a> の範囲が返されることを意味します。</p><p><code>IndexStyle</code> を <code>IndexCartesian</code> として報告する <code>N</code> 次元のカスタム配列は、正確に <code>N</code> の <code>Int</code> インデックスでインデックス付け（およびインデックス付き代入）を実装する必要があります。他のすべてのインデックス式 — 線形インデックスを含む — は、同等のCartesian位置に再計算されます。たとえば、<code>A</code> がCartesianインデックスを持つ <code>2×3</code> のカスタム行列であり、<code>A[5]</code> を参照した場合、これは同等のCartesianインデックスに再計算され、<code>A[1, 3]</code> が呼び出されます。なぜなら、<code>5 = 1 + 2*(3 - 1)</code> だからです。</p><p>線形インデックスからCartesianインデックスを計算するのは、逆に行くよりもはるかに高コストです。前者の操作は割り算を必要とし — 非常にコストのかかる操作 — 後者は乗算と加算のみを使用し、基本的に無料です。この非対称性は、<code>IndexCartesian</code> 配列で線形インデックスを使用することが、<code>IndexLinear</code> 配列でCartesianインデックスを使用することよりもはるかに高コストであることを意味します。</p><p><a href="arrays.html#Base.IndexLinear"><code>IndexLinear</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L39-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.conj!" href="#Base.conj!"><code>Base.conj!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj!(A)</code></pre><p>配列をその複素共役にインプレースで変換します。</p><p>関連項目 <a href="math.html#Base.conj"><code>conj</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1+im 2-im; 2+2im 3+im]
2×2 Matrix{Complex{Int64}}:
 1+1im  2-1im
 2+2im  3+1im

julia&gt; conj!(A);

julia&gt; A
2×2 Matrix{Complex{Int64}}:
 1-1im  2+1im
 2-2im  3-1im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L162-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.stride" href="#Base.stride"><code>Base.stride</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stride(A, k::Integer)</code></pre><p>次元 <code>k</code> における隣接要素間のメモリ内の距離（要素数）を返します。</p><p>関連情報: <a href="arrays.html#Base.strides"><code>strides</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (3,4,5));

julia&gt; stride(A,2)
3

julia&gt; stride(A,3)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L576-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.strides" href="#Base.strides"><code>Base.strides</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">strides(A)</code></pre><p>各次元のメモリストライドのタプルを返します。</p><p>関連: <a href="arrays.html#Base.stride"><code>stride</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (3,4,5));

julia&gt; strides(A)
(1, 3, 12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L559-L573">source</a></section></article><h2 id="Broadcast-and-vectorization"><a class="docs-heading-anchor" href="#Broadcast-and-vectorization">Broadcast and vectorization</a><a id="Broadcast-and-vectorization-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcast-and-vectorization" title="Permalink"></a></h2><p>次も参照してください <a href="../manual/functions.html#man-vectorized">dot syntax for vectorizing functions</a>; 例えば、<code>f.(args...)</code> は暗黙的に <code>broadcast(f, args...)</code> を呼び出します。配列に対して <code>sin</code> のような関数の「ベクトル化」メソッドに依存するのではなく、<code>sin.(a)</code> を使用して <code>broadcast</code> を介してベクトル化するべきです。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcast" href="#Base.Broadcast.broadcast"><code>Base.Broadcast.broadcast</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">broadcast(f, As...)</code></pre><p>関数 <code>f</code> を配列、タプル、コレクション、<a href="c.html#Core.Ref"><code>Ref</code></a>s および/またはスカラー <code>As</code> に対してブロードキャストします。</p><p>ブロードキャスティングは、コンテナ引数の要素と <code>As</code> 内のスカラー自体に対して関数 <code>f</code> を適用します。シングルトンおよび欠損次元は、他の引数の範囲に一致するように値を仮想的に繰り返すことで拡張されます。デフォルトでは、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>Type</code>、<code>Function</code> などの限られた数の型のみがスカラーと見なされ、<a href="../manual/missing.html#missing"><code>missing</code></a> や <a href="constants.html#Core.nothing"><code>nothing</code></a> のような一般的なシングルトンも含まれます。その他の引数は要素ごとに反復処理されるか、インデックス指定されます。</p><p>結果のコンテナ型は、以下のルールによって決定されます：</p><ul><li>すべての引数がスカラーまたはゼロ次元配列である場合、アンラップされたスカラーを返します。</li><li>1つ以上の引数がタプルであり、他のすべてがスカラーまたはゼロ次元配列である場合、タプルを返します。</li><li>その他の引数の組み合わせはデフォルトで <code>Array</code> を返しますが、カスタムコンテナ型は引数として現れたときに結果をカスタマイズするための独自の実装および昇格のようなルールを定義できます。</li><li>要素型は <a href="collections.html#Base.collect-Tuple{Any}"><code>collect</code></a> と同様の方法で決定されます。</li></ul><p>ブロードキャスティングには特別な構文があります：<code>f.(args...)</code> は <code>broadcast(f, args...)</code> と同等であり、ネストされた <code>f.(g.(args...))</code> 呼び出しは単一のブロードキャストループに融合されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 2, 3, 4, 5]
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; B = [1 2; 3 4; 5 6; 7 8; 9 10]
5×2 Matrix{Int64}:
 1   2
 3   4
 5   6
 7   8
 9  10

julia&gt; broadcast(+, A, B)
5×2 Matrix{Int64}:
  2   3
  5   6
  8   9
 11  12
 14  15

julia&gt; parse.(Int, [&quot;1&quot;, &quot;2&quot;])
2-element Vector{Int64}:
 1
 2

julia&gt; abs.((1, -2))
(1, 2)

julia&gt; broadcast(+, 1.0, (0, -2.0))
(1.0, -1.0)

julia&gt; (+).([[0,2], [1,3]], Ref{Vector{Int}}([1,-1]))
2-element Vector{Vector{Int64}}:
 [1, 1]
 [2, 2]

julia&gt; string.((&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;), &quot;: &quot;, 1:4)
4-element Vector{String}:
 &quot;one: 1&quot;
 &quot;two: 2&quot;
 &quot;three: 3&quot;
 &quot;four: 4&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L755-L831">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcast!" href="#Base.Broadcast.broadcast!"><code>Base.Broadcast.broadcast!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">broadcast!(f, dest, As...)</code></pre><p><a href="arrays.html#Base.Broadcast.broadcast"><code>broadcast</code></a>と同様ですが、<code>broadcast(f, As...)</code>の結果を<code>dest</code>配列に格納します。<code>dest</code>は結果を格納するためだけに使用され、<code>As</code>にリストされていない限り、<code>f</code>に引数を供給することはありません。例えば、<code>broadcast!(f, A, A, B)</code>は<code>A[:] = broadcast(f, A, B)</code>を実行します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0; 0.0]; B = [0.0; 0.0];

julia&gt; broadcast!(+, B, A, (0, -2.0));

julia&gt; B
2-element Vector{Float64}:
  1.0
 -2.0

julia&gt; A
2-element Vector{Float64}:
 1.0
 0.0

julia&gt; broadcast!(+, A, A, (0, -2.0));

julia&gt; A
2-element Vector{Float64}:
  1.0
 -2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L838-L870">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.@__dot__" href="#Base.Broadcast.@__dot__"><code>Base.Broadcast.@__dot__</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@. expr</code></pre><p><code>expr</code>内のすべての関数呼び出しまたは演算子を「ドット呼び出し」に変換します（例：<code>f(x)</code>を<code>f.(x)</code>に変換）。また、<code>expr</code>内のすべての代入を「ドット代入」に変換します（例：<code>+=</code>を<code>.+=</code>に変換）。</p><p><code>expr</code>内の特定の関数呼び出しに対してドットを追加したくない場合は、<code>$</code>でそれらの関数呼び出しをスパイスします。例えば、<code>@. sqrt(abs($sort(x)))</code>は<code>sqrt.(abs.(sort(x)))</code>と同等です（<code>sort</code>にはドットがありません）。</p><p>（<code>@.</code>は<code>@__dot__</code>への呼び出しと同等です。）</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = 1.0:3.0; y = similar(x);

julia&gt; @. y = x + 3 * sin(x)
3-element Vector{Float64}:
 3.5244129544236893
 4.727892280477045
 3.4233600241796016</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L1300-L1324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.BroadcastFunction" href="#Base.Broadcast.BroadcastFunction"><code>Base.Broadcast.BroadcastFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BroadcastFunction{F} &lt;: Function</code></pre><p>演算子の「ドット」バージョンを表し、演算子をその引数に対してブロードキャストします。したがって、<code>BroadcastFunction(op)</code>は機能的に<code>(x...) -&gt; (op).(x...)</code>と同等です。</p><p>ドットの前に演算子を付けて高階関数に渡すだけで作成できます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [[1 3; 2 4], [5 7; 6 8]];

julia&gt; b = [[9 11; 10 12], [13 15; 14 16]];

julia&gt; map(.*, a, b)
2-element Vector{Matrix{Int64}}:
 [9 33; 20 48]
 [65 105; 84 128]

julia&gt; Base.BroadcastFunction(+)(a, b) == a .+ b
true</code></pre><div class="admonition is-compat" id="Julia-1.6-98a34a58b829ed67"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-98a34a58b829ed67" title="Permalink"></a></header><div class="admonition-body"><p><code>BroadcastFunction</code>とスタンドアロンの<code>.op</code>構文は、Julia 1.6以降で利用可能です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L1357-L1382">source</a></section></article><p>カスタムタイプに特化したブロードキャストについては、参照してください。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.BroadcastStyle" href="#Base.Broadcast.BroadcastStyle"><code>Base.Broadcast.BroadcastStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>BroadcastStyle</code>は抽象型であり、ブロードキャスト時のオブジェクトの動作を決定するために使用されるトレイト関数です。<code>BroadcastStyle(typeof(x))</code>は<code>x</code>に関連付けられたスタイルを返します。型のブロードキャスト動作をカスタマイズするには、型/メソッドペアを定義することでスタイルを宣言できます。</p><pre><code class="language-julia hljs">struct MyContainerStyle &lt;: BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:MyContainer}) = MyContainerStyle()</code></pre><p>その後、<code>Broadcasted{MyContainerStyle}</code>に対して動作するメソッド（少なくとも<a href="arrays.html#Base.similar"><code>similar</code></a>）を書く必要があります。また、利用できるいくつかの事前定義された<code>BroadcastStyle</code>のサブタイプもあります。詳細については、<a href="../manual/interfaces.html#man-interfaces-broadcasting">Interfaces chapter</a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.AbstractArrayStyle" href="#Base.Broadcast.AbstractArrayStyle"><code>Base.Broadcast.AbstractArrayStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Broadcast.AbstractArrayStyle{N} &lt;: BroadcastStyle</code> は、<code>AbstractArray</code> 型に関連付けられた任意のスタイルの抽象スーパタイプです。<code>N</code> パラメータは次元数であり、特定の次元数のみをサポートする AbstractArray 型に便利です：</p><pre><code class="language-julia hljs">struct SparseMatrixStyle &lt;: Broadcast.AbstractArrayStyle{2} end
Base.BroadcastStyle(::Type{&lt;:SparseMatrixCSC}) = SparseMatrixStyle()</code></pre><p>任意の次元数をサポートする <code>AbstractArray</code> 型の場合、<code>N</code> は <code>Any</code> に設定できます：</p><pre><code class="language-julia hljs">struct MyArrayStyle &lt;: Broadcast.AbstractArrayStyle{Any} end
Base.BroadcastStyle(::Type{&lt;:MyArray}) = MyArrayStyle()</code></pre><p>複数の <code>AbstractArrayStyle</code> を混ぜて次元数を追跡したい場合、スタイルは <a href="base.html#Base.Val"><code>Val</code></a> コンストラクタをサポートする必要があります：</p><pre><code class="language-julia hljs">struct MyArrayStyleDim{N} &lt;: Broadcast.AbstractArrayStyle{N} end
(::Type{&lt;:MyArrayStyleDim})(::Val{N}) where N = MyArrayStyleDim{N}()</code></pre><p>2つ以上の <code>AbstractArrayStyle</code> サブタイプが競合する場合、ブロードキャスト機構は <code>Array</code> を生成することにフォールバックします。これが望ましくない場合は、出力型を制御するためにバイナリ <a href="arrays.html#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> ルールを定義する必要があります。</p><p>また、<a href="arrays.html#Base.Broadcast.DefaultArrayStyle"><code>Broadcast.DefaultArrayStyle</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L51-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.ArrayStyle" href="#Base.Broadcast.ArrayStyle"><code>Base.Broadcast.ArrayStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Broadcast.ArrayStyle{MyArrayType}()</code> は、ブロードキャスト用にオブジェクトが配列として振る舞うことを示す <a href="arrays.html#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> です。これは、特定の <code>AbstractArray</code> コンテナタイプのための <a href="arrays.html#Base.Broadcast.AbstractArrayStyle"><code>Broadcast.AbstractArrayStyle</code></a> を構築するための簡単な方法を提供します。この方法で作成されたブロードキャストスタイルは、次元の追跡を失います。もしあなたのタイプにとって次元の追跡が重要であれば、独自のカスタム <a href="arrays.html#Base.Broadcast.AbstractArrayStyle"><code>Broadcast.AbstractArrayStyle</code></a> を作成するべきです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.DefaultArrayStyle" href="#Base.Broadcast.DefaultArrayStyle"><code>Base.Broadcast.DefaultArrayStyle</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Broadcast.DefaultArrayStyle{N}()</code> は、ブロードキャストのためにオブジェクトが <code>N</code> 次元配列として振る舞うことを示す <a href="arrays.html#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> です。具体的には、<code>DefaultArrayStyle</code> は特別なスタイルを定義していない任意の <code>AbstractArray</code> 型に使用され、他の <code>broadcast</code> 引数からのオーバーライドがない場合、結果の出力型は <code>Array</code> になります。<code>broadcast</code> に複数の入力がある場合、<code>DefaultArrayStyle</code> は他の任意の <a href="arrays.html#Base.Broadcast.ArrayStyle"><code>Broadcast.ArrayStyle</code></a> に対して「負けます」。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.broadcastable" href="#Base.Broadcast.broadcastable"><code>Base.Broadcast.broadcastable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Broadcast.broadcastable(x)</code></pre><p><code>x</code> または <code>x</code> のようなオブジェクトを返します。これにより <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>、インデックス付けをサポートし、その型が <a href="arrays.html#Base.ndims"><code>ndims</code></a> をサポートします。</p><p><code>x</code> が反復をサポートする場合、返される値は <a href="collections.html#Base.collect-Tuple{Any}"><code>collect(x)</code></a> と同じ <code>axes</code> とインデックス付けの動作を持つべきです。</p><p><code>x</code> が <code>AbstractArray</code> ではないが、<code>axes</code>、インデックス付けをサポートし、その型が <code>ndims</code> をサポートする場合、<code>broadcastable(::typeof(x))</code> は単に自分自身を返すように実装されるかもしれません。さらに、<code>x</code> が独自の <a href="arrays.html#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> を定義している場合、カスタムスタイルに効果を持たせるためには <code>broadcastable</code> メソッドを自分自身を返すように定義しなければなりません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Broadcast.broadcastable([1,2,3]) # 配列はすでに axes とインデックス付けをサポートしているため、`identity` のよう
3-element Vector{Int64}:
 1
 2
 3

julia&gt; Broadcast.broadcastable(Int) # 型は axes、インデックス付け、または反復をサポートしないが、スカラーとして一般的に使用される
Base.RefValue{Type{Int64}}(Int64)

julia&gt; Broadcast.broadcastable(&quot;hello&quot;) # 文字列は反復の一致の慣例を破り、代わりにスカラーのように振る舞う
Base.RefValue{String}(&quot;hello&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L701-L728">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.combine_axes" href="#Base.Broadcast.combine_axes"><code>Base.Broadcast.combine_axes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine_axes(As...) -&gt; Tuple</code></pre><p><code>As</code>内のすべての値に対してブロードキャストを行うための結果の軸を決定します。</p><pre><code class="language-julia-repl hljs">julia&gt; Broadcast.combine_axes([1], [1 2; 3 4; 5 6])
(Base.OneTo(3), Base.OneTo(2))

julia&gt; Broadcast.combine_axes(1, 1, 1)
()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L490-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.combine_styles" href="#Base.Broadcast.combine_styles"><code>Base.Broadcast.combine_styles</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combine_styles(cs...) -&gt; BroadcastStyle</code></pre><p>任意の数の値引数に対して使用する <code>BroadcastStyle</code> を決定します。各引数のスタイルを取得するために <a href="arrays.html#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a> を使用し、スタイルを組み合わせるために <a href="arrays.html#Base.Broadcast.result_style"><code>result_style</code></a> を使用します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Broadcast.combine_styles([1], [1 2; 3 4])
Base.Broadcast.DefaultArrayStyle{2}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L416-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Broadcast.result_style" href="#Base.Broadcast.result_style"><code>Base.Broadcast.result_style</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">result_style(s1::BroadcastStyle[, s2::BroadcastStyle]) -&gt; BroadcastStyle</code></pre><p>1つまたは2つの<code>BroadcastStyle</code>を受け取り、<a href="arrays.html#Base.Broadcast.BroadcastStyle"><code>BroadcastStyle</code></a>を使用して共通の<code>BroadcastStyle</code>を決定します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Broadcast.result_style(Broadcast.DefaultArrayStyle{0}(), Broadcast.DefaultArrayStyle{3}())
Base.Broadcast.DefaultArrayStyle{3}()

julia&gt; Broadcast.result_style(Broadcast.Unknown(), Broadcast.DefaultArrayStyle{1}())
Base.Broadcast.DefaultArrayStyle{1}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/broadcast.jl#L441-L456">source</a></section></article><h2 id="Indexing-and-assignment"><a class="docs-heading-anchor" href="#Indexing-and-assignment">Indexing and assignment</a><a id="Indexing-and-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-and-assignment" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray, Vararg{Any}}" href="#Base.getindex-Tuple{AbstractArray, Vararg{Any}}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(A, inds...)</code></pre><p>インデックス <code>inds</code> によって選択された配列 <code>A</code> のサブセットを返します。</p><p>各インデックスは、<a href="numbers.html#Core.Integer"><code>Integer</code></a>、<a href="arrays.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a>、<a href="collections.html#Base.AbstractRange">range</a>、またはサポートされているインデックスの<a href="../manual/arrays.html#man-multi-dim-arrays">配列</a>など、任意の<a href="../manual/arrays.html#man-supported-index-types">サポートされているインデックスタイプ</a>である可能性があります。特定の次元に沿ってすべての要素を選択するために、<a href="arrays.html#Base.Colon">: </a>を使用することができ、対応するインデックスが <code>true</code> である要素をフィルタリングするために、ブール配列（例：<code>Array{Bool}</code> または <a href="arrays.html#Base.BitArray"><code>BitArray</code></a>）を使用することができます。</p><p><code>inds</code> が複数の要素を選択する場合、この関数は新しく割り当てられた配列を返します。コピーを作成せずに複数の要素にインデックスを付けるには、代わりに <a href="arrays.html#Base.view"><code>view</code></a> を使用してください。</p><p>詳細については、<a href="../manual/arrays.html#man-array-indexing">配列インデックス</a>に関するマニュアルセクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; getindex(A, 1)
1

julia&gt; getindex(A, [2, 1])
2-element Vector{Int64}:
 3
 1

julia&gt; getindex(A, 2:4)
3-element Vector{Int64}:
 3
 2
 4

julia&gt; getindex(A, 2, 1)
3

julia&gt; getindex(A, CartesianIndex(2, 1))
3

julia&gt; getindex(A, :, 2)
2-element Vector{Int64}:
 2
 4

julia&gt; getindex(A, 2, :)
2-element Vector{Int64}:
 3
 4

julia&gt; getindex(A, A .&gt; 2)
2-element Vector{Int64}:
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L1281-L1338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray, Any, Vararg{Any}}" href="#Base.setindex!-Tuple{AbstractArray, Any, Vararg{Any}}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setindex!(A, X, inds...)
A[inds...] = X</code></pre><p>配列 <code>X</code> の値を、<code>inds</code> で指定された <code>A</code> の一部に格納します。構文 <code>A[inds...] = X</code> は <code>(setindex!(A, X, inds...); X)</code> と同等です。</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(2,2);

julia&gt; setindex!(A, [10, 20], [1, 2]);

julia&gt; A[[3, 4]] = [30, 40];

julia&gt; A
2×2 Matrix{Float64}:
 10.0  30.0
 20.0  40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L1417-L1439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.nextind" href="#Base.nextind"><code>Base.nextind</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nextind(A, i)</code></pre><p><code>i</code>の後の<code>A</code>内のインデックスを返します。返されるインデックスは、整数<code>i</code>に対してしばしば<code>i + 1</code>と同等です。この関数は、汎用コードに役立ちます。</p><div class="admonition is-warning" id="Warning-4cc96de4b7451c94"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4cc96de4b7451c94" title="Permalink"></a></header><div class="admonition-body"><p>返されるインデックスは範囲外である可能性があります。<a href="arrays.html#Base.checkbounds"><code>checkbounds</code></a>の使用を検討してください。</p></div></div><p>関連情報: <a href="arrays.html#Base.prevind"><code>prevind</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; nextind(x, 1) # 有効な結果
2

julia&gt; nextind(x, 4) # 無効な結果
5

julia&gt; nextind(x, CartesianIndex(1, 1)) # 有効な結果
CartesianIndex(2, 1)

julia&gt; nextind(x, CartesianIndex(2, 2)) # 無効な結果
CartesianIndex(1, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/tuple.jl#L113-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prevind" href="#Base.prevind"><code>Base.prevind</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prevind(A, i)</code></pre><p><code>A</code>の<code>i</code>の前のインデックスを返します。返されるインデックスは、整数<code>i</code>の場合、しばしば<code>i - 1</code>に相当します。この関数は、汎用コードに役立ちます。</p><div class="admonition is-warning" id="Warning-4cc96de4b7451c94"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-4cc96de4b7451c94" title="Permalink"></a></header><div class="admonition-body"><p>返されるインデックスは範囲外である可能性があります。<a href="arrays.html#Base.checkbounds"><code>checkbounds</code></a>の使用を検討してください。</p></div></div><p>関連情報: <a href="arrays.html#Base.nextind"><code>nextind</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prevind(x, 4) # 有効な結果
3

julia&gt; prevind(x, 1) # 無効な結果
0

julia&gt; prevind(x, CartesianIndex(2, 2)) # 有効な結果
CartesianIndex(1, 2)

julia&gt; prevind(x, CartesianIndex(1, 1)) # 無効な結果
CartesianIndex(2, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/tuple.jl#L79-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractArray, CartesianIndices, AbstractArray, CartesianIndices}" href="#Base.copyto!-Tuple{AbstractArray, CartesianIndices, AbstractArray, CartesianIndices}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -&gt; dest</code></pre><p>範囲 <code>Rsrc</code> の <code>src</code> のブロックを範囲 <code>Rdest</code> の <code>dest</code> のブロックにコピーします。2つの領域のサイズは一致している必要があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(5, 5);

julia&gt; B = [1 2; 3 4];

julia&gt; Ainds = CartesianIndices((2:3, 2:3));

julia&gt; Binds = CartesianIndices(B);

julia&gt; copyto!(A, Ainds, B, Binds)
5×5 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0
 0.0  1.0  2.0  0.0  0.0
 0.0  3.0  4.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L1218-L1242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy!" href="#Base.copy!"><code>Base.copy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy!(dest::AbstractMatrix, src::UniformScaling)</code></pre><p><a href="../stdlib/LinearAlgebra.html#LinearAlgebra.UniformScaling"><code>UniformScaling</code></a> を行列にコピーします。</p><div class="admonition is-compat" id="Julia-1.12-9fb27ed426e518a0"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-9fb27ed426e518a0" title="Permalink"></a></header><div class="admonition-body"><p>このメソッドは Julia 1.12 以降で利用可能です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/LinearAlgebra.jl/blob/24f5e21cf3a560ca560c5a1759ff21ba68382ebd/src/uniformscaling.jl#L407-L414">source</a></section><section><div><pre><code class="language-julia hljs">copy!(dst, src) -&gt; dst</code></pre><p><code>src</code>を<code>dst</code>にインプレースで<a href="base.html#Base.copy"><code>copy</code></a>し、<code>dst</code>内の既存の要素はすべて破棄されます。<code>dst</code>と<code>src</code>が同じ型である場合、呼び出し後に<code>dst == src</code>が成り立つべきです。<code>dst</code>と<code>src</code>がベクトル型である場合、等しいオフセットを持たなければなりません。<code>dst</code>と<code>src</code>が多次元配列である場合、等しい<a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>を持たなければなりません。</p><div class="admonition is-warning" id="Warning-c8dc157b3981446e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-c8dc157b3981446e" title="Permalink"></a></header><div class="admonition-body"><p>いずれかの変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p>関連情報として<a href="c.html#Base.copyto!"><code>copyto!</code></a>も参照してください。</p><div class="admonition is-info" id="Note-ce747fc39142a77"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ce747fc39142a77" title="Permalink"></a></header><div class="admonition-body"><p>ベクトル型で操作する場合、<code>dst</code>と<code>src</code>が同じ長さでない場合、<code>copy</code>の前に<code>dst</code>は<code>length(src)</code>にリサイズされます。</p></div></div><div class="admonition is-compat" id="Julia-1.1-f593492a6c975585"><header class="admonition-header">Julia 1.1<a class="admonition-anchor" href="#Julia-1.1-f593492a6c975585" title="Permalink"></a></header><div class="admonition-body"><p>このメソッドは少なくともJulia 1.1が必要です。Julia 1.0では、このメソッドは<code>Future</code>標準ライブラリから<code>Future.copy!</code>として利用可能です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L892-L913">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isassigned" href="#Base.isassigned"><code>Base.isassigned</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isassigned(array, i) -&gt; Bool</code></pre><p>与えられた配列にインデックス <code>i</code> に関連付けられた値があるかどうかをテストします。インデックスが範囲外であるか、未定義の参照を持つ場合は <code>false</code> を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isassigned(rand(3, 3), 5)
true

julia&gt; isassigned(rand(3, 3), 3 * 3 + 1)
false

julia&gt; mutable struct Foo end

julia&gt; v = similar(rand(3), Foo)
3-element Vector{Foo}:
 #undef
 #undef
 #undef

julia&gt; isassigned(v, 1)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/essentials.jl#L962-L987">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Colon" href="#Base.Colon"><code>Base.Colon</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Colon()</code></pre><p>コロン (:) は、オブジェクト全体や次元を一度にインデックス指定するために使用されます。</p><p>コロンに対して直接定義されている操作は非常に少なく、代わりに <a href="arrays.html#Base.to_indices"><code>to_indices</code></a> によって内部ベクター型 (<code>Base.Slice</code>) に変換され、インデックスのコレクションを表現します。</p><p><code>Colon</code> のシングルトンインスタンスは、範囲を構築するために使用される関数でもあります。詳細は <a href="math.html#Base.::"><code>:</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/essentials.jl#L996-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IteratorsMD.CartesianIndex" href="#Base.IteratorsMD.CartesianIndex"><code>Base.IteratorsMD.CartesianIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartesianIndex(i, j, k...)   -&gt; I
CartesianIndex((i, j, k...)) -&gt; I</code></pre><p>多次元インデックス <code>I</code> を作成します。これは多次元配列 <code>A</code> のインデックス付けに使用できます。特に、<code>A[I]</code> は <code>A[i,j,k...]</code> と同等です。整数と <code>CartesianIndex</code> インデックスを自由に混ぜることができます。例えば、<code>A[Ipre, i, Ipost]</code>（ここで <code>Ipre</code> と <code>Ipost</code> は <code>CartesianIndex</code> インデックスで、<code>i</code> は <code>Int</code>）は、任意の次元の配列の単一の次元に沿って動作するアルゴリズムを書く際に便利な表現です。</p><p><code>CartesianIndex</code> は、<a href="arrays.html#Base.eachindex"><code>eachindex</code></a> によって生成されることがあり、明示的に <a href="arrays.html#Base.IteratorsMD.CartesianIndices"><code>CartesianIndices</code></a> を使用して反復する際には常に生成されます。</p><p><code>I::CartesianIndex</code> は <code>broadcast</code> のための「スカラー」（コンテナではない）として扱われます。<code>CartesianIndex</code> のコンポーネントを反復するには、<code>Tuple(I)</code> を使用してタプルに変換します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(Vector(1:16), (2, 2, 2, 2))
2×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; A[CartesianIndex((1, 1, 1, 1))]
1

julia&gt; A[CartesianIndex((1, 1, 1, 2))]
9

julia&gt; A[CartesianIndex((1, 1, 2, 1))]
5</code></pre><div class="admonition is-compat" id="Julia-1.10-b1cde0d47f441e15"><header class="admonition-header">Julia 1.10<a class="admonition-anchor" href="#Julia-1.10-b1cde0d47f441e15" title="Permalink"></a></header><div class="admonition-body"><p><code>broadcast</code> のための「スカラー」として <code>CartesianIndex</code> を使用するには Julia 1.10 が必要です。以前のリリースでは、<code>Ref(I)</code> を使用してください。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L21-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IteratorsMD.CartesianIndices" href="#Base.IteratorsMD.CartesianIndices"><code>Base.IteratorsMD.CartesianIndices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CartesianIndices(sz::Dims) -&gt; R
CartesianIndices((istart:[istep:]istop, jstart:[jstep:]jstop, ...)) -&gt; R</code></pre><p>整数インデックスの多次元矩形範囲を含む領域 <code>R</code> を定義します。これは、<code>for I in R ... end</code> がネストされたループに相当する <a href="arrays.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a> インデックス <code>I</code> を返す反復の文脈で最も一般的に遭遇します。</p><pre><code class="language-julia hljs">for j = jstart:jstep:jstop
    for i = istart:istep:istop
        ...
    end
end</code></pre><p>したがって、これらは任意の次元で動作するアルゴリズムを書くのに役立ちます。</p><pre><code class="language-julia hljs">CartesianIndices(A::AbstractArray) -&gt; R</code></pre><p>配列から <code>CartesianIndices</code> を構築することは、そのインデックスの範囲を作成する便利な方法です。</p><div class="admonition is-compat" id="Julia-1.6-a83845252835f4e2"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-a83845252835f4e2" title="Permalink"></a></header><div class="admonition-body"><p>ステップ範囲メソッド <code>CartesianIndices((istart:istep:istop, jstart:[jstep:]jstop, ...))</code> は、少なくとも Julia 1.6 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; foreach(println, CartesianIndices((2, 2, 2)))
CartesianIndex(1, 1, 1)
CartesianIndex(2, 1, 1)
CartesianIndex(1, 2, 1)
CartesianIndex(2, 2, 1)
CartesianIndex(1, 1, 2)
CartesianIndex(2, 1, 2)
CartesianIndex(1, 2, 2)
CartesianIndex(2, 2, 2)

julia&gt; CartesianIndices(fill(1, (2,3)))
CartesianIndices((2, 3))</code></pre><p><strong>線形インデックスとカーテシアンインデックスの変換</strong></p><p>線形インデックスからカーテシアンインデックスへの変換は、<code>CartesianIndices</code> が <code>AbstractArray</code> であり、線形にインデックスできるという事実を利用します。</p><pre><code class="language-julia-repl hljs">julia&gt; cartesian = CartesianIndices((1:3, 1:2))
CartesianIndices((1:3, 1:2))

julia&gt; cartesian[4]
CartesianIndex(1, 2)

julia&gt; cartesian = CartesianIndices((1:2:5, 1:2))
CartesianIndices((1:2:5, 1:2))

julia&gt; cartesian[2, 2]
CartesianIndex(3, 2)</code></pre><p><strong>ブロードキャスティング</strong></p><p><code>CartesianIndices</code> は、<code>CartesianIndex</code> とのブロードキャスティング演算（+ と -）をサポートしています。</p><div class="admonition is-compat" id="Julia-1.1-7be283941b783f87"><header class="admonition-header">Julia 1.1<a class="admonition-anchor" href="#Julia-1.1-7be283941b783f87" title="Permalink"></a></header><div class="admonition-body"><p>CartesianIndices のブロードキャスティングには、少なくとも Julia 1.1 が必要です。</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; CIs = CartesianIndices((2:3, 5:6))
CartesianIndices((2:3, 5:6))

julia&gt; CI = CartesianIndex(3, 4)
CartesianIndex(3, 4)

julia&gt; CIs .+ CI
CartesianIndices((5:6, 9:10))</code></pre><p>カーテシアンから線形インデックスへの変換については、<a href="arrays.html#Base.LinearIndices"><code>LinearIndices</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L188-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Dims" href="#Base.Dims"><code>Base.Dims</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dims{N}</code></pre><p><code>N</code> の <code>Int</code> の <code>NTuple</code> で、<a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a> の次元を表すために使用されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.LinearIndices" href="#Base.LinearIndices"><code>Base.LinearIndices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearIndices(A::AbstractArray)</code></pre><p>同じ形状と<a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>を持つ<code>LinearIndices</code>配列を返し、<code>A</code>の各エントリの線形インデックスを保持します。この配列を直交インデックスでインデックス付けすることで、線形インデックスにマッピングできます。</p><p>従来のインデックス付け（インデックスは1から始まる）を持つ配列や任意の多次元配列の場合、線形インデックスは1から<code>length(A)</code>までの範囲になります。しかし、<code>AbstractVector</code>の場合、線形インデックスは<code>axes(A, 1)</code>であり、したがって従来でないインデックス付けを持つベクトルでは1から始まりません。</p><p>この関数を呼び出すことは、線形インデックスを利用するアルゴリズムを書く「安全な」方法です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (5,6,7));

julia&gt; b = LinearIndices(A);

julia&gt; extrema(b)
(1, 210)</code></pre><pre><code class="language-julia hljs">LinearIndices(inds::CartesianIndices) -&gt; R
LinearIndices(sz::Dims) -&gt; R
LinearIndices((istart:istop, jstart:jstop, ...)) -&gt; R</code></pre><p>指定された形状または<a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>を持つ<code>LinearIndices</code>配列を返します。</p><p><strong>例</strong></p><p>このコンストラクタの主な目的は、直交インデックスから線形インデックスへの直感的な変換です：</p><pre><code class="language-julia-repl hljs">julia&gt; linear = LinearIndices((1:3, 1:2))
3×2 LinearIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:
 1  4
 2  5
 3  6

julia&gt; linear[1,2]
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L478-L524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.to_indices" href="#Base.to_indices"><code>Base.to_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_indices(A, I::Tuple)</code></pre><p>タプル <code>I</code> を配列 <code>A</code> にインデックスを付けるためのインデックスのタプルに変換します。</p><p>返されるタプルは、配列 <code>A</code> によってサポートされるスカラーインデックスの <code>Int</code> または <code>AbstractArray</code> のいずれかのみを含む必要があります。処理できない新しいインデックスタイプに遭遇するとエラーが発生します。</p><p>単純なインデックスタイプの場合、各インデックス <code>i</code> を処理するためにエクスポートされていない <code>Base.to_index(A, i)</code> に委ねます。この内部関数は直接呼び出すことを意図していませんが、カスタム配列やインデックスタイプによって <code>Base.to_index</code> を拡張してカスタムインデクシング動作を提供することができます。</p><p>より複雑なインデックスタイプは、インデックスする次元に関するより多くのコンテキストを必要とする場合があります。それらのケースをサポートするために、<code>to_indices(A, I)</code> は <code>to_indices(A, axes(A), I)</code> を呼び出し、与えられたインデックスのタプルと <code>A</code> の次元インデックスを同時に再帰的に走査します。そのため、すべてのインデックスタイプが <code>Base.to_index</code> に伝播することが保証されているわけではありません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(1,2,3,4);

julia&gt; to_indices(A, (1,1,2,2))
(1, 1, 2, 2)

julia&gt; to_indices(A, (1,1,2,20)) # 境界チェックなし
(1, 1, 2, 20)

julia&gt; to_indices(A, (CartesianIndex((1,)), 2, CartesianIndex((3,4)))) # エキゾチックなインデックス
(1, 2, 3, 4)

julia&gt; to_indices(A, ([1,1], 1:2, 3, 4))
([1, 1], 1:2, 3, 4)

julia&gt; to_indices(A, (1,2)) # 形状チェックなし
(1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L319-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.checkbounds" href="#Base.checkbounds"><code>Base.checkbounds</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkbounds(A, I...)</code></pre><p>指定されたインデックス <code>I</code> が与えられた配列 <code>A</code> の範囲内でない場合、エラーをスローします。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L692-L696">source</a></section><section><div><pre><code class="language-julia hljs">checkbounds(Bool, A, I...)</code></pre><p>指定されたインデックス <code>I</code> が与えられた配列 <code>A</code> の範囲内にある場合は <code>true</code> を返します。<code>AbstractArray</code> のサブタイプは、カスタムの範囲チェック動作を提供する必要がある場合、このメソッドを特化すべきですが、多くの場合、<code>A</code> のインデックスと <a href="arrays.html#Base.checkindex"><code>checkindex</code></a> に依存することができます。</p><p>また、<a href="arrays.html#Base.checkindex"><code>checkindex</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(3, 3);

julia&gt; checkbounds(Bool, A, 2)
true

julia&gt; checkbounds(Bool, A, 3, 4)
false

julia&gt; checkbounds(Bool, A, 1:3)
true

julia&gt; checkbounds(Bool, A, 1:3, 2:4)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L652-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.checkindex" href="#Base.checkindex"><code>Base.checkindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">checkindex(Bool, inds::AbstractUnitRange, index)</code></pre><p>与えられた <code>index</code> が <code>inds</code> の範囲内にある場合は <code>true</code> を返します。すべての配列のインデックスとして動作したいカスタム型は、このメソッドを拡張して特化した境界チェックの実装を提供できます。</p><p><a href="arrays.html#Base.checkbounds"><code>checkbounds</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; checkindex(Bool, 1:20, 8)
true

julia&gt; checkindex(Bool, 1:20, 21)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L732-L750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.elsize" href="#Base.elsize"><code>Base.elsize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elsize(type)</code></pre><p>与えられた <code>type</code> 内に格納されている <a href="collections.html#Base.eltype"><code>eltype</code></a> の連続する要素間のメモリストライドをバイト単位で計算します。配列要素が均一な線形ストライドで密に格納されている場合です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.elsize(rand(Float32, 10))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L244-L256">source</a></section></article><p>ほとんどのコードはインデックスに依存しない方法で記述できます（例えば、<a href="arrays.html#Base.eachindex"><code>eachindex</code></a>を参照）。しかし、オフセット軸を明示的にチェックすることが有用な場合もあります：</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.require_one_based_indexing" href="#Base.require_one_based_indexing"><code>Base.require_one_based_indexing</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">require_one_based_indexing(A::AbstractArray)
require_one_based_indexing(A,B...)</code></pre><p>引数のいずれかのインデックスが、任意の軸に沿って <code>1</code> 以外のもので始まる場合、<code>ArgumentError</code> をスローします。詳細は <a href="arrays.html#Base.has_offset_axes"><code>has_offset_axes</code></a> を参照してください。</p><div class="admonition is-compat" id="Julia-1.2-b7c7997bafc21169"><header class="admonition-header">Julia 1.2<a class="admonition-anchor" href="#Julia-1.2-b7c7997bafc21169" title="Permalink"></a></header><div class="admonition-body"><p>この関数は少なくとも Julia 1.2 を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L121-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.has_offset_axes" href="#Base.has_offset_axes"><code>Base.has_offset_axes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_offset_axes(A)
has_offset_axes(A, B, ...)</code></pre><p><code>A</code>のインデックスが任意の軸に沿って1以外の値で始まる場合は<code>true</code>を返します。複数の引数が渡された場合、<code>has_offset_axes(A) || has_offset_axes(B) || ...</code>と同等です。</p><p>関連情報は<a href="arrays.html#Base.require_one_based_indexing"><code>require_one_based_indexing</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L101-L109">source</a></section></article><h2 id="Views-(SubArrays-and-other-view-types)"><a class="docs-heading-anchor" href="#Views-(SubArrays-and-other-view-types)">Views (SubArrays and other view types)</a><a id="Views-(SubArrays-and-other-view-types)-1"></a><a class="docs-heading-anchor-permalink" href="#Views-(SubArrays-and-other-view-types)" title="Permalink"></a></h2><p>「ビュー」は、配列のように機能するデータ構造（<code>AbstractArray</code>のサブタイプ）ですが、基になるデータは実際には別の配列の一部です。</p><p>例えば、<code>x</code> が配列であり、<code>v = @view x[1:10]</code> の場合、<code>v</code> は10要素の配列のように振る舞いますが、そのデータは実際には <code>x</code> の最初の10要素にアクセスしています。ビューに書き込むと、例えば <code>v[3] = 2</code> のように、基になる配列 <code>x</code> に直接書き込まれます（この場合、<code>x[3]</code> を変更します）。</p><p>スライス操作 <code>x[1:10]</code> は、デフォルトでコピーを作成します。 <code>@view x[1:10]</code> は、それをビューに変更します。 <code>@views</code> マクロは、コードの全ブロックに使用することができ（例： <code>@views function foo() .... end</code> または <code>@views begin ... end</code>）、そのブロック内のすべてのスライス操作をビューを使用するように変更します。データのコピーを作成する方が速い場合もあれば、ビューを使用する方が速い場合もあります。これは <a href="../manual/performance-tips.html#man-performance-views">performance tips</a> に記載されています。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.view" href="#Base.view"><code>Base.view</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">view(A, inds...)</code></pre><p><a href="collections.html#Base.getindex"><code>getindex</code></a>と同様ですが、指定されたインデックスまたはインデックスの集合<code>inds</code>に対して親配列<code>A</code>を遅延参照する軽量配列を返します。要素を即座に抽出したり、コピーされた部分集合を構築するのではありません。返された値（しばしば<a href="arrays.html#Base.SubArray"><code>SubArray</code></a>）に対して<a href="collections.html#Base.getindex"><code>getindex</code></a>または<a href="collections.html#Base.setindex!"><code>setindex!</code></a>を呼び出すと、親配列にアクセスまたは変更するためのインデックスがその場で計算されます。<code>view</code>が呼び出された後に親配列の形状が変更されると、動作は未定義になります。なぜなら、親配列に対する境界チェックがないからです。例えば、セグメンテーションフォルトを引き起こす可能性があります。</p><p>一部の不変の親配列（範囲など）は、効率的で互換性のあるセマンティクスを提供する場合、<code>SubArray</code>を返す代わりに新しい配列を再計算することを選択することがあります。</p><div class="admonition is-compat" id="Julia-1.6-462beed1d878272f"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-462beed1d878272f" title="Permalink"></a></header><div class="admonition-body"><p>Julia 1.6以降では、<code>view</code>は<code>AbstractString</code>に対して呼び出すことができ、<code>SubString</code>を返します。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; b = view(A, :, 1)
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 0
 0

julia&gt; A # bを変更したにもかかわらずAが変更されたことに注意
2×2 Matrix{Int64}:
 0  2
 0  4

julia&gt; view(2:5, 2:3) # 型が不変であるため範囲を返す
3:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/subarray.jl#L165-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@view" href="#Base.@view"><code>Base.@view</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@view A[inds...]</code></pre><p>インデックス式 <code>A[inds...]</code> を同等の <a href="arrays.html#Base.view"><code>view</code></a> 呼び出しに変換します。</p><p>これは単一のインデックス式に直接適用でき、特に <code>A[begin, 2:end-1]</code> のような特別な <code>begin</code> または <code>end</code> インデックス構文を含む式に役立ちます（これらは通常の <a href="arrays.html#Base.view"><code>view</code></a> 関数ではサポートされていません）。</p><p><code>@view</code> は通常の代入のターゲットとして使用することはできません（例： <code>@view(A[1, 2:end]) = ...</code>）、また、装飾されていない <a href="../manual/arrays.html#man-indexed-assignment">インデックス代入</a> (<code>A[1, 2:end] = ...</code>) やブロードキャストされたインデックス代入 (<code>A[1, 2:end] .= ...</code>) はコピーを作成しません。しかし、<code>@view(A[1, 2:end]) .+= 1</code> のようなブロードキャストされた代入を<em>更新する</em>ためには便利です。これは <code>@view(A[1, 2:end]) .= @view(A[1, 2:end]) + 1</code> の簡単な構文であり、右辺のインデックス式は <code>@view</code> がなければコピーを作成します。</p><p>非スカラーインデックスに対してビューを使用するためにコードの全ブロックを切り替えるには、<a href="arrays.html#Base.@views"><code>@views</code></a> も参照してください。</p><div class="admonition is-compat" id="Julia-1.5-947016a78a451312"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-947016a78a451312" title="Permalink"></a></header><div class="admonition-body"><p>インデックス式で最初のインデックスを参照するために <code>begin</code> を使用するには、少なくとも Julia 1.5 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; b = @view A[:, 1]
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 0
 0

julia&gt; A
2×2 Matrix{Int64}:
 0  2
 0  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/views.jl#L77-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@views" href="#Base.@views"><code>Base.@views</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@views expression</code></pre><p>与えられた式（<code>begin</code>/<code>end</code> ブロック、ループ、関数などの可能性があります）内のすべての配列スライス操作をビューを返すように変換します。スカラーインデックス、非配列型、および明示的な <a href="collections.html#Base.getindex"><code>getindex</code></a> 呼び出し（<code>array[...]</code> とは対照的に）は影響を受けません。</p><p>同様に、<code>@views</code> は文字列スライスを <a href="strings.html#Base.SubString"><code>SubString</code></a> ビューに変換します。</p><div class="admonition is-info" id="Note-1d1a6ae61ed08db8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1d1a6ae61ed08db8" title="Permalink"></a></header><div class="admonition-body"><p><code>@views</code> マクロは、与えられた <code>expression</code> に明示的に現れる <code>array[...]</code> 式にのみ影響し、そのコードによって呼び出される関数内で発生する配列スライスには影響しません。</p></div></div><div class="admonition is-compat" id="Julia-1.5-c72e2bcd86a6ef04"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-c72e2bcd86a6ef04" title="Permalink"></a></header><div class="admonition-body"><p>インデックス式で <code>begin</code> を使用して最初のインデックスを参照することは、Julia 1.4 で実装されましたが、Julia 1.5 から <code>@views</code> によってのみサポートされました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(3, 3);

julia&gt; @views for row in 1:3
           b = A[row, :] # b はコピーではなくビューです
           b .= row      # 各要素を行インデックスに割り当てる
       end

julia&gt; A
3×3 Matrix{Float64}:
 1.0  1.0  1.0
 2.0  2.0  2.0
 3.0  3.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/views.jl#L211-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parent(A)</code></pre><p>ビューの基になる親オブジェクトを返します。<code>SubArray</code>、<code>SubString</code>、<code>ReshapedArray</code>、または<code>LinearAlgebra.Transpose</code>のタイプのオブジェクトの親は、オブジェクト作成時に<code>view</code>、<code>reshape</code>、<code>transpose</code>などに引数として渡されたものです。入力がラップされたオブジェクトでない場合は、入力自体を返します。入力が複数回ラップされている場合は、最外層のラッパーのみが削除されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; V = view(A, 1:2, :)
2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia&gt; parent(V)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L1484-L1509">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.parentindices" href="#Base.parentindices"><code>Base.parentindices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parentindices(A)</code></pre><p><code>A</code>に対応する<a href="arrays.html#Base.parent"><code>parent</code></a>のインデックスを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4];

julia&gt; V = view(A, 1, :)
2-element view(::Matrix{Int64}, 1, :) with eltype Int64:
 1
 2

julia&gt; parentindices(V)
(1, Base.Slice(Base.OneTo(2)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/subarray.jl#L83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.selectdim" href="#Base.selectdim"><code>Base.selectdim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">selectdim(A, d::Integer, i)</code></pre><p>次元 <code>d</code> のインデックスが <code>i</code> に等しい <code>A</code> のすべてのデータのビューを返します。</p><p><code>i</code> が位置 <code>d</code> にある場合、<code>view(A,:,:,...,i,:,:,...)</code> と同等です。</p><p>参照: <a href="arrays.html#Base.eachslice"><code>eachslice</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3 4; 5 6 7 8]
2×4 Matrix{Int64}:
 1  2  3  4
 5  6  7  8

julia&gt; selectdim(A, 2, 3)
2-element view(::Matrix{Int64}, :, 3) with eltype Int64:
 3
 7

julia&gt; selectdim(A, 2, 3:4)
2×2 view(::Matrix{Int64}, :, 3:4) with eltype Int64:
 3  4
 7  8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L290-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reinterpret" href="#Base.reinterpret"><code>Base.reinterpret</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reinterpret(reshape, T, A::AbstractArray{S}) -&gt; B</code></pre><p><code>A</code>の型解釈を変更し、「チャネル次元」を消費または追加します。</p><p>もし<code>sizeof(T) = n*sizeof(S)</code>で<code>n&gt;1</code>の場合、<code>A</code>の最初の次元はサイズ<code>n</code>でなければならず、<code>B</code>は<code>A</code>の最初の次元を欠きます。逆に、もし<code>sizeof(S) = n*sizeof(T)</code>で<code>n&gt;1</code>の場合、<code>B</code>はサイズ<code>n</code>の新しい最初の次元を持ちます。<code>sizeof(T) == sizeof(S)</code>の場合、次元数は変わりません。</p><div class="admonition is-compat" id="Julia-1.6-988709dd568be78c"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-988709dd568be78c" title="Permalink"></a></header><div class="admonition-body"><p>このメソッドは少なくともJulia 1.6を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; reinterpret(reshape, Complex{Int}, A)    # 結果はベクトルです
2-element reinterpret(reshape, Complex{Int64}, ::Matrix{Int64}) with eltype Complex{Int64}:
 1 + 3im
 2 + 4im

julia&gt; a = [(1,2,3), (4,5,6)]
2-element Vector{Tuple{Int64, Int64, Int64}}:
 (1, 2, 3)
 (4, 5, 6)

julia&gt; reinterpret(reshape, Int, a)             # 結果は行列です
3×2 reinterpret(reshape, Int64, ::Vector{Tuple{Int64, Int64, Int64}}) with eltype Int64:
 1  4
 2  5
 3  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/reinterpretarray.jl#L142-L178">source</a></section><section><div><pre><code class="language-julia hljs">reinterpret(T::DataType, A::AbstractArray)</code></pre><p>与えられた配列と同じバイナリデータを持つ配列のビューを、要素型 <code>T</code> で構築します。</p><p>この関数は、要素が明示的に取得されるまで計算されない「遅延」配列にも適用できます。たとえば、範囲 <code>1:6</code> に対する <code>reinterpret</code> は、密なベクトル <code>collect(1:6)</code> に対するものと同様に動作します：</p><pre><code class="language-julia-repl hljs">julia&gt; reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 reinterpret(Float32, ::Matrix{UInt32}):
 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45

julia&gt; reinterpret(Complex{Int}, 1:6)
3-element reinterpret(Complex{Int64}, ::UnitRange{Int64}):
 1 + 2im
 3 + 4im
 5 + 6im</code></pre><p>パディングビットの位置が <code>T</code> と <code>eltype(A)</code> の間で一致しない場合、結果の配列は読み取り専用または書き込み専用になります。これは、それぞれ無効なビットが書き込まれたり読み取られたりするのを防ぐためです。</p><pre><code class="language-julia-repl hljs">julia&gt; a = reinterpret(Tuple{UInt8, UInt32}, UInt32[1, 2])
1-element reinterpret(Tuple{UInt8, UInt32}, ::Vector{UInt32}):
 (0x01, 0x00000002)

julia&gt; a[1] = 3
ERROR: Padding of type Tuple{UInt8, UInt32} is not compatible with type UInt32.

julia&gt; b = reinterpret(UInt32, Tuple{UInt8, UInt32}[(0x01, 0x00000002)]); # showing will error

julia&gt; b[1]
ERROR: Padding of type UInt32 is not compatible with type Tuple{UInt8, UInt32}.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/reinterpretarray.jl#L30-L67">source</a></section><section><div><pre><code class="language-julia hljs">reinterpret(::Type{Out}, x::In)</code></pre><p>isbits値<code>x</code>のバイナリデータの型解釈をisbits型<code>Out</code>のものに変更します。<code>Out</code>のサイズ（パディングを無視）は、<code>x</code>の型のサイズと同じでなければなりません。例えば、<code>reinterpret(Float32, UInt32(7))</code>は、<code>UInt32(7)</code>に対応する4バイトを<a href="numbers.html#Core.Float32"><code>Float32</code></a>として解釈します。<code>reinterpret(In, reinterpret(Out, x)) === x</code>であることに注意してください。</p><pre><code class="language-julia-repl hljs">julia&gt; reinterpret(Float32, UInt32(7))
1.0f-44

julia&gt; reinterpret(NTuple{2, UInt8}, 0x1234)
(0x34, 0x12)

julia&gt; reinterpret(UInt16, (0x34, 0x12))
0x1234

julia&gt; reinterpret(Tuple{UInt16, UInt8}, (0x01, 0x0203))
(0x0301, 0x02)</code></pre><div class="admonition is-info" id="Note-1de77725a0d3a1fc"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1de77725a0d3a1fc" title="Permalink"></a></header><div class="admonition-body"><p>パディングの扱いは、reinterpret(::DataType, ::AbstractArray)とは異なります。</p></div></div><div class="admonition is-warning" id="Warning-6d266a7a56f6418c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-6d266a7a56f6418c" title="Permalink"></a></header><div class="admonition-body"><p><code>Out</code>のビットのいくつかの組み合わせが無効と見なされ、型のコンストラクタやメソッドによって防止される場合は注意してください。追加の検証なしに予期しない動作が発生する可能性があります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/essentials.jl#L696-L729">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reshape" href="#Base.reshape"><code>Base.reshape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reshape(A, dims...) -&gt; AbstractArray
reshape(A, dims) -&gt; AbstractArray</code></pre><p><code>A</code>と同じデータを持つ配列を返しますが、異なる次元サイズまたは次元数を持ちます。2つの配列は同じ基礎データを共有しているため、結果は<code>A</code>が可変である場合にのみ可変であり、一方の要素を設定すると他方の値が変更されます。</p><p>新しい次元は、引数のリストまたは形状タプルとして指定できます。最大1つの次元は<code>:</code>で指定でき、その場合はその長さが指定されたすべての次元との積が元の配列<code>A</code>の長さに等しくなるように計算されます。要素の総数は変更されてはいけません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Vector(1:16)
16-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia&gt; reshape(A, (4, 4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reshape(A, 2, :)
2×8 Matrix{Int64}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16

julia&gt; reshape(1:6, 2, 3)
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/reshapedarray.jl#L66-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.insertdims" href="#Base.insertdims"><code>Base.insertdims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insertdims(A; dims)</code></pre><p><a href="arrays.html#Base.dropdims"><code>dropdims</code></a> の逆; <code>dims</code> のすべての次元に新しい単一次元を持つ配列を返します。</p><p>繰り返しの次元は禁じられており、<code>dims</code> の最大エントリは <code>ndims(A) + length(dims)</code> 以下でなければなりません。</p><p>結果は <code>A</code> と同じ基礎データを共有し、したがって結果は <code>A</code> が可変である場合にのみ可変であり、一方の要素を設定すると他方の値が変更されます。</p><p>関連項目: <a href="arrays.html#Base.dropdims"><code>dropdims</code></a>, <a href="arrays.html#Base.reshape"><code>reshape</code></a>, <a href="arrays.html#Base.vec"><code>vec</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; insertdims(x, dims=3)
2×3×1 Array{Int64, 3}:
[:, :, 1] =
 1  2  3
 4  5  6

julia&gt; insertdims(x, dims=(1,2,5)) == reshape(x, 1, 1, 2, 3, 1)
true

julia&gt; dropdims(insertdims(x, dims=(1,2,5)), dims=(1,2,5))
2×3 Matrix{Int64}:
 1  2  3
 4  5  6</code></pre><div class="admonition is-compat" id="Julia-1.12-1f3cc90fc81ad494"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-1f3cc90fc81ad494" title="Permalink"></a></header><div class="admonition-body"><p>Julia 1.12 以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L97-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.dropdims" href="#Base.dropdims"><code>Base.dropdims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dropdims(A; dims)</code></pre><p><code>A</code>と同じデータを持つ配列を返しますが、<code>dims</code>で指定された次元が削除されます。<code>size(A,d)</code>は、<code>dims</code>内のすべての<code>d</code>に対して1でなければならず、繰り返しの次元や<code>1:ndims(A)</code>の範囲外の数は許可されていません。</p><p>結果は<code>A</code>と同じ基礎データを共有しており、そのため結果は<code>A</code>が可変である場合にのみ可変であり、一方の要素を設定すると他方の値が変更されます。</p><p>参照: <a href="arrays.html#Base.reshape"><code>reshape</code></a>, <a href="arrays.html#Base.vec"><code>vec</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = reshape(Vector(1:4),(2,2,1,1))
2×2×1×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

julia&gt; b = dropdims(a; dims=3)
2×2×1 Array{Int64, 3}:
[:, :, 1] =
 1  3
 2  4

julia&gt; b[1,1,1] = 5; a
2×2×1×1 Array{Int64, 4}:
[:, :, 1, 1] =
 5  3
 2  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L48-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vec" href="#Base.vec"><code>Base.vec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vec(a::AbstractArray) -&gt; AbstractVector</code></pre><p>配列 <code>a</code> を一次元の列ベクトルとして再形成します。<code>a</code> がすでに <code>AbstractVector</code> の場合は <code>a</code> を返します。結果の配列は <code>a</code> と同じ基礎データを共有するため、<code>a</code> が可変である場合にのみ可変であり、その場合、一方を変更するともう一方も変更されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; vec(a)
6-element Vector{Int64}:
 1
 4
 2
 5
 3
 6

julia&gt; vec(1:3)
1:3</code></pre><p>他にも <a href="arrays.html#Base.reshape"><code>reshape</code></a>, <a href="arrays.html#Base.dropdims"><code>dropdims</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L11-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.SubArray" href="#Base.SubArray"><code>Base.SubArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SubArray{T,N,P,I,L} &lt;: AbstractArray{T,N}</code></pre><p>親配列（型 <code>P</code>）への <code>N</code> 次元のビューで、要素型 <code>T</code> を持ち、インデックスのタプル（型 <code>I</code>）によって制限されています。<code>L</code> は、高速な線形インデックスをサポートする型に対しては true であり、それ以外は false です。</p><p><a href="arrays.html#Base.view"><code>view</code></a> 関数を使用して <code>SubArray</code> を構築します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/subarray.jl#L7-L13">source</a></section></article><h2 id="Concatenation-and-permutation"><a class="docs-heading-anchor" href="#Concatenation-and-permutation">Concatenation and permutation</a><a id="Concatenation-and-permutation-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenation-and-permutation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cat" href="#Base.cat"><code>Base.cat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cat(A...; dims)</code></pre><p>入力配列を <code>dims</code> で指定された次元に沿って連結します。</p><p>次元 <code>d</code> が <code>dims</code> に含まれる場合、出力配列のサイズは <code>sum(size(a,d) for a in A)</code> です。他の次元に沿っては、すべての入力配列が同じサイズである必要があり、それが出力配列のサイズにもなります。</p><p><code>dims</code> が単一の数値の場合、異なる配列はその次元に沿って密に詰められます。<code>dims</code> が複数の次元を含むイテラブルの場合、これらの次元に沿った位置は各入力配列に対して同時に増加し、他の場所はゼロで埋められます。これにより、<code>cat(matrices...; dims=(1,2))</code> のようにブロック対角行列やその高次元の類似物を構築することができます。</p><p>特別なケースとして <code>dims=1</code> は <a href="arrays.html#Base.vcat"><code>vcat</code></a>、<code>dims=2</code> は <a href="arrays.html#Base.hcat"><code>hcat</code></a> です。さらに <a href="arrays.html#Base.hvcat"><code>hvcat</code></a>、<a href="arrays.html#Base.hvncat"><code>hvncat</code></a>、<a href="arrays.html#Base.stack"><code>stack</code></a>、<a href="arrays.html#Base.repeat"><code>repeat</code></a> も参照してください。</p><p>キーワードは <code>Val(dims)</code> も受け入れます。</p><div class="admonition is-compat" id="Julia-1.8-f92c6aa71df7229f"><header class="admonition-header">Julia 1.8<a class="admonition-anchor" href="#Julia-1.8-f92c6aa71df7229f" title="Permalink"></a></header><div class="admonition-body"><p>複数の次元 <code>dims = Val(::Tuple)</code> は Julia 1.8 で追加されました。</p></div></div><p><strong>例</strong></p><p>異なる次元で2つの配列を連結します：</p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3]
1×3 Matrix{Int64}:
 1  2  3

julia&gt; b = [4 5 6]
1×3 Matrix{Int64}:
 4  5  6

julia&gt; cat(a, b; dims=1)
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; cat(a, b; dims=2)
1×6 Matrix{Int64}:
 1  2  3  4  5  6

julia&gt; cat(a, b; dims=(1, 2))
2×6 Matrix{Int64}:
 1  2  3  0  0  0
 0  0  0  4  5  6</code></pre><p><strong>Extended Help</strong></p><p>3D配列を連結します：</p><pre><code class="language-julia-repl hljs">julia&gt; a = ones(2, 2, 3);

julia&gt; b = ones(2, 2, 4);

julia&gt; c = cat(a, b; dims=3);

julia&gt; size(c) == (2, 2, 7)
true</code></pre><p>異なるサイズの配列を連結します：</p><pre><code class="language-julia-repl hljs">julia&gt; cat([1 2; 3 4], [pi, pi], fill(10, 2,3,1); dims=2)  # hcat と同じ
2×6×1 Array{Float64, 3}:
[:, :, 1] =
 1.0  2.0  3.14159  10.0  10.0  10.0
 3.0  4.0  3.14159  10.0  10.0  10.0</code></pre><p>ブロック対角行列を構築します：</p><pre><code class="language-julia hljs">julia&gt; cat(true, trues(2,2), trues(4)&#39;, dims=(1,2))  # ブロック対角
4×7 Matrix{Bool}:
 1  0  0  0  0  0  0
 0  1  1  0  0  0  0
 0  1  1  0  0  0  0
 0  0  0  1  1  1  1</code></pre><pre><code class="language-julia hljs">julia&gt; cat(1, [2], [3;;]; dims=Val(2))
1×3 Matrix{Int64}:
 1  2  3</code></pre><div class="admonition is-info" id="Note-6ac34b87a4a9b641"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6ac34b87a4a9b641" title="Permalink"></a></header><div class="admonition-body"><p><code>cat</code> は2つの文字列を結合しません。<code>*</code> を使用することをお勧めします。</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; a = &quot;aaa&quot;;

julia&gt; b = &quot;bbb&quot;;

julia&gt; cat(a, b; dims=1)
2-element Vector{String}:
 &quot;aaa&quot;
 &quot;bbb&quot;

julia&gt; cat(a, b; dims=2)
1×2 Matrix{String}:
 &quot;aaa&quot;  &quot;bbb&quot;

julia&gt; a * b
&quot;aaabbb&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L2003-L2113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vcat" href="#Base.vcat"><code>Base.vcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcat(A...)</code></pre><p>配列または数値を垂直に連結します。<code>cat</code>(@ref)<code>(A...; dims=1)</code>と同等で、構文<code>[a; b; c]</code>とも同じです。</p><p>大きな配列のベクトルを連結するには、<code>reduce(vcat, A)</code>が<code>A isa AbstractVector{&lt;:AbstractVecOrMat}</code>の場合に効率的な方法を呼び出し、ペアワイズで処理するのではありません。</p><p>他にも<a href="arrays.html#Base.hcat"><code>hcat</code></a>、<a href="iterators.html#Base.Iterators.flatten"><code>Iterators.flatten</code></a>、<a href="arrays.html#Base.stack"><code>stack</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = vcat([1,2], [3,4])
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; v == vcat(1, 2, [3,4])  # 数値を受け入れます
true

julia&gt; v == [1; 2; [3,4]]  # 同じ操作のための構文
true

julia&gt; summary(ComplexF64[1; 2; [3,4]])  # 要素型を指定するための構文
&quot;4-element Vector{ComplexF64}&quot;

julia&gt; vcat(range(1, 2, length=3))  # 遅延範囲を収集します
3-element Vector{Float64}:
 1.0
 1.5
 2.0

julia&gt; two = ([10, 20, 30]&#39;, Float64[4 5 6; 7 8 9])  # 行ベクトルと行列
(adjoint([10, 20, 30]), [4.0 5.0 6.0; 7.0 8.0 9.0])

julia&gt; vcat(two...)
3×3 Matrix{Float64}:
 10.0  20.0  30.0
  4.0   5.0   6.0
  7.0   8.0   9.0

julia&gt; vs = [[1, 2], [3, 4], [5, 6]];

julia&gt; reduce(vcat, vs)  # vcat(vs...)よりも効率的です
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6

julia&gt; ans == collect(Iterators.flatten(vs))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L1889-L1947">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hcat" href="#Base.hcat"><code>Base.hcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hcat(A...)</code></pre><p>配列または数値を水平方向に連結します。<code>cat</code>(@ref)<code>(A...; dims=2)</code>と同等であり、構文<code>[a b c]</code>または<code>[a;; b;; c]</code>とも同じです。</p><p>大きな配列のベクトルに対して、<code>reduce(hcat, A)</code>は<code>A isa AbstractVector{&lt;:AbstractVecOrMat}</code>の場合に効率的なメソッドを呼び出します。ベクトルのベクトルに対しては、これを<code>stack</code>(@ref)<code>(A)</code>と書くこともできます。</p><p>他にも<a href="arrays.html#Base.vcat"><code>vcat</code></a>、<a href="arrays.html#Base.hvcat"><code>hvcat</code></a>があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hcat([1,2], [3,4], [5,6])
2×3 Matrix{Int64}:
 1  3  5
 2  4  6

julia&gt; hcat(1, 2, [30 40], [5, 6, 7]&#39;)  # 数値を受け入れます
1×7 Matrix{Int64}:
 1  2  30  40  5  6  7

julia&gt; ans == [1 2 [30 40] [5, 6, 7]&#39;]  # 同じ操作の構文
true

julia&gt; Float32[1 2 [30 40] [5, 6, 7]&#39;]  # eltypeを指定する構文
1×7 Matrix{Float32}:
 1.0  2.0  30.0  40.0  5.0  6.0  7.0

julia&gt; ms = [zeros(2,2), [1 2; 3 4], [50 60; 70 80]];

julia&gt; reduce(hcat, ms)  # hcat(ms...)よりも効率的
2×6 Matrix{Float64}:
 0.0  0.0  1.0  2.0  50.0  60.0
 0.0  0.0  3.0  4.0  70.0  80.0

julia&gt; stack(ms) |&gt; summary  # 行列のベクトルに対して不一致
&quot;2×2×3 Array{Float64, 3}&quot;

julia&gt; hcat(Int[], Int[], Int[])  # サイズ(0,)の空のベクトル
0×3 Matrix{Int64}

julia&gt; hcat([1.1, 9.9], Matrix(undef, 2, 0))  # 空の2×0行列でのhcat
2×1 Matrix{Any}:
 1.1
 9.9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L1949-L1997">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hvcat" href="#Base.hvcat"><code>Base.hvcat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hvcat(blocks_per_row::Union{Tuple{Vararg{Int}}, Int}, values...)</code></pre><p>1回の呼び出しでの水平および垂直の連結。この関数はブロック行列構文のために呼び出されます。最初の引数は、各ブロック行に連結する引数の数を指定します。最初の引数が単一の整数 <code>n</code> の場合、すべてのブロック行は <code>n</code> のブロック列を持つと仮定されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia&gt; [a b c; d e f]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; hvcat((3,3), a,b,c,d,e,f)
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; [a b; c d; e f]
3×2 Matrix{Int64}:
 1  2
 3  4
 5  6

julia&gt; hvcat((2,2,2), a,b,c,d,e,f)
3×2 Matrix{Int64}:
 1  2
 3  4
 5  6
julia&gt; hvcat((2,2,2), a,b,c,d,e,f) == hvcat(2, a,b,c,d,e,f)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L2151-L2188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hvncat" href="#Base.hvncat"><code>Base.hvncat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hvncat(dim::Int, row_first, values...)
hvncat(dims::Tuple{Vararg{Int}}, row_first, values...)
hvncat(shape::Tuple{Vararg{Tuple}}, row_first, values...)</code></pre><p>多くの <code>values</code> を1回の呼び出しで水平方向、垂直方向、n次元で連結します。</p><p>この関数はブロック行列構文のために呼び出されます。最初の引数は、<code>hvcat</code> に似た連結の形状をタプルのタプルとして指定するか、各軸に沿った要素の数を指定する次元を指定し、出力の次元を決定するために使用されます。<code>dims</code> 形式はよりパフォーマンスが良く、連結操作が各軸に沿った要素の数が同じ場合（例: [a b; c d;;; e f ; g h]）にデフォルトで使用されます。<code>shape</code> 形式は、各軸に沿った要素の数が不均衡な場合（例: [a b ; c]）に使用されます。不均衡な構文は追加の検証オーバーヘッドが必要です。<code>dim</code> 形式は、1次元に沿った連結の最適化です。<code>row_first</code> は <code>values</code> の順序を示します。<code>shape</code> の最初と2番目の要素の意味も <code>row_first</code> に基づいて入れ替えられます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia&gt; [a b c;;; d e f]
1×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  2  3

[:, :, 2] =
 4  5  6

julia&gt; hvncat((2,1,3), false, a,b,c,d,e,f)
2×1×3 Array{Int64, 3}:
[:, :, 1] =
 1
 2

[:, :, 2] =
 3
 4

[:, :, 3] =
 5
 6

julia&gt; [a b;;; c d;;; e f]
1×2×3 Array{Int64, 3}:
[:, :, 1] =
 1  2

[:, :, 2] =
 3  4

[:, :, 3] =
 5  6

julia&gt; hvncat(((3, 3), (3, 3), (6,)), true, a, b, c, d, e, f)
1×3×2 Array{Int64, 3}:
[:, :, 1] =
 1  2  3

[:, :, 2] =
 4  5  6</code></pre><p><strong>引数の構築の例</strong></p><pre><code class="language-julia hljs">[a b c ; d e f ;;;
 g h i ; j k l ;;;
 m n o ; p q r ;;;
 s t u ; v w x]
⇒ dims = (2, 3, 4)

[a b ; c ;;; d ;;;;]
 ___   _     _
 2     1     1 = 各行の要素数 (2, 1, 1)
 _______     _
 3           1 = 各列の要素数 (3, 1)
 _____________
 4             = 各3dスライスの要素数 (4,)
 _____________
 4             = 各4dスライスの要素数 (4,)
⇒ shape = ((2, 1, 1), (3, 1), (4,), (4,)) with `row_first` = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L2255-L2339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.stack" href="#Base.stack"><code>Base.stack</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stack(f, args...; [dims])</code></pre><p>コレクションの各要素に関数を適用し、その結果を <code>stack</code> します。または、いくつかのコレクションを <a href="iterators.html#Base.Iterators.zip"><code>zip</code></a> して一緒に処理します。</p><p>関数はすべて同じサイズの配列（またはタプル、または他のイテレータ）を返す必要があります。これらは結果のスライスとなり、<code>dims</code>（指定されている場合）に沿って、またはデフォルトで最後の次元に沿って区切られます。</p><p>他にも <a href="arrays.html#Base.mapslices"><code>mapslices</code></a>、<a href="arrays.html#Base.eachcol"><code>eachcol</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; stack(c -&gt; (c, c-32), &quot;julia&quot;)
2×5 Matrix{Char}:
 &#39;j&#39;  &#39;u&#39;  &#39;l&#39;  &#39;i&#39;  &#39;a&#39;
 &#39;J&#39;  &#39;U&#39;  &#39;L&#39;  &#39;I&#39;  &#39;A&#39;

julia&gt; stack(eachrow([1 2 3; 4 5 6]), (10, 100); dims=1) do row, n
         vcat(row, row .* n, row ./ n)
       end
2×9 Matrix{Float64}:
 1.0  2.0  3.0   10.0   20.0   30.0  0.1   0.2   0.3
 4.0  5.0  6.0  400.0  500.0  600.0  0.04  0.05  0.06</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L2852-L2878">source</a></section><section><div><pre><code class="language-julia hljs">stack(iter; [dims])</code></pre><p>同じサイズの配列（または他の反復可能なオブジェクト）のコレクションを、1つ以上の新しい次元に沿って配置することによって、1つの大きな配列に結合します。</p><p>デフォルトでは、要素の軸が最初に配置され、<code>size(result) = (size(first(iter))..., size(iter)...)</code> となります。これは <a href="iterators.html#Base.Iterators.flatten"><code>Iterators.flatten</code></a><code>(iter)</code> と同じ順序の要素を持ちます。</p><p>キーワード <code>dims::Integer</code> を使用すると、代わりに <code>iter</code> の <code>i</code> 番目の要素がスライス <a href="arrays.html#Base.selectdim"><code>selectdim</code></a><code>(result, dims, i)</code> となり、<code>size(result, dims) == length(iter)</code> になります。この場合、<code>stack</code> は同じ <code>dims</code> を持つ <a href="arrays.html#Base.eachslice"><code>eachslice</code></a> の動作を逆にします。</p><p>さまざまな <a href="arrays.html#Base.cat"><code>cat</code></a> 関数も配列を結合します。ただし、これらはすべて配列の既存の（おそらく自明な）次元を拡張するのに対し、配列を新しい次元に沿って配置することはありません。また、配列を単一のコレクションではなく、別々の引数として受け取ります。</p><div class="admonition is-compat" id="Julia-1.9-fb1954b8c92f2a40"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-fb1954b8c92f2a40" title="Permalink"></a></header><div class="admonition-body"><p>この関数は少なくとも Julia 1.9 を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vecs = (1:2, [30, 40], Float32[500, 600]);

julia&gt; mat = stack(vecs)
2×3 Matrix{Float32}:
 1.0  30.0  500.0
 2.0  40.0  600.0

julia&gt; mat == hcat(vecs...) == reduce(hcat, collect(vecs))
true

julia&gt; vec(mat) == vcat(vecs...) == reduce(vcat, collect(vecs))
true

julia&gt; stack(zip(1:4, 10:99))  # 任意の反復可能なオブジェクトの反復子を受け入れます
2×4 Matrix{Int64}:
  1   2   3   4
 10  11  12  13

julia&gt; vec(ans) == collect(Iterators.flatten(zip(1:4, 10:99)))
true

julia&gt; stack(vecs; dims=1)  # どの cat 関数とも異なり、vecs[1] の 1 番目の軸は結果の 2 番目の軸です
3×2 Matrix{Float32}:
   1.0    2.0
  30.0   40.0
 500.0  600.0

julia&gt; x = rand(3,4);

julia&gt; x == stack(eachcol(x)) == stack(eachrow(x), dims=1)  # eachslice の逆
true</code></pre><p>高次元の例:</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(5, 7, 11);

julia&gt; E = eachslice(A, dims=2);  # 行列のベクトル

julia&gt; (element = size(first(E)), container = size(E))
(element = (5, 11), container = (7,))

julia&gt; stack(E) |&gt; size
(5, 11, 7)

julia&gt; stack(E) == stack(E; dims=3) == cat(E...; dims=3)
true

julia&gt; A == stack(E; dims=2)
true

julia&gt; M = (fill(10i+j, 2, 3) for i in 1:5, j in 1:7);

julia&gt; (element = size(first(M)), container = size(M))
(element = (2, 3), container = (5, 7))

julia&gt; stack(M) |&gt; size  # すべての次元を保持
(2, 3, 5, 7)

julia&gt; stack(M; dims=1) |&gt; size  # dims=1 に沿った vec(container)
(35, 2, 3)

julia&gt; hvcat(5, M...) |&gt; size  # hvcat は行列を隣接させます
(14, 15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L2759-L2849">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.vect" href="#Base.vect"><code>Base.vect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vect(X...)</code></pre><p>引数の <code>promote_typeof</code> から計算された要素型を持つ <a href="arrays.html#Base.Vector"><code>Vector</code></a> を作成し、引数リストを含みます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Base.vect(UInt8(1), 2.5, 1//2)
3-element Vector{Float64}:
 1.0
 2.5
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L168-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.circshift" href="#Base.circshift"><code>Base.circshift</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circshift(A, shifts)</code></pre><p>データ <code>A</code> を円形にシフト、すなわち回転させます。第二引数は、各次元でのシフト量を指定するタプルまたはベクトル、または最初の次元のみをシフトする整数です。</p><p>生成されたコードは、シフト量がコンパイル時に知られている場合、すなわちコンパイル時定数であるときに最も効率的です。</p><p>参照: <a href="arrays.html#Base.circshift!"><code>circshift!</code></a>, <a href="arrays.html#Base.circcopy!"><code>circcopy!</code></a>, <a href="math.html#Base.bitrotate"><code>bitrotate</code></a>, <a href="math.html#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = reshape(Vector(1:16), (4,4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; circshift(b, (0,2))
4×4 Matrix{Int64}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia&gt; circshift(b, (-1,0))
4×4 Matrix{Int64}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13

julia&gt; a = BitArray([true, true, false, false, true])
5-element BitVector:
 1
 1
 0
 0
 1

julia&gt; circshift(a, 1)
5-element BitVector:
 1
 1
 1
 0
 0

julia&gt; circshift(a, -1)
5-element BitVector:
 1
 0
 0
 1
 1

julia&gt; x = (1, 2, 3, 4, 5)
(1, 2, 3, 4, 5)

julia&gt; circshift(x, 4)
(2, 3, 4, 5, 1)

julia&gt; z = (1, &#39;a&#39;, -7.0, 3)
(1, &#39;a&#39;, -7.0, 3)

julia&gt; circshift(z, -1)
(&#39;a&#39;, -7.0, 3, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L329-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.circshift!" href="#Base.circshift!"><code>Base.circshift!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circshift!(dest, src, shifts)</code></pre><p><code>src</code>のデータを円環的にシフト（回転）し、結果を<code>dest</code>に格納します。<code>shifts</code>は各次元でのシフト量を指定します。</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p>関連情報は<a href="arrays.html#Base.circshift"><code>circshift</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L1247-L1256">source</a></section><section><div><pre><code class="language-julia hljs">circshift!(a::AbstractVector, shift::Integer)</code></pre><p>ベクトル <code>a</code> のデータを <code>shift</code> ポジションだけ円環的にシフトまたは回転します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circshift!([1, 2, 3, 4, 5], 2)
5-element Vector{Int64}:
 4
 5
 1
 2
 3

julia&gt; circshift!([1, 2, 3, 4, 5], -2)
5-element Vector{Int64}:
 3
 4
 5
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L3688-L3712">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.circcopy!" href="#Base.circcopy!"><code>Base.circcopy!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circcopy!(dest, src)</code></pre><p><code>src</code>を<code>dest</code>にコピーし、各次元をその長さでモジュロインデックスします。<code>src</code>と<code>dest</code>は同じサイズでなければなりませんが、インデックスにオフセットを持つことができます。オフセットがある場合、(円形の)ラップアラウンドが発生します。配列が重複するインデックスを持つ場合、重複の領域では<code>dest</code>は<code>src</code>と一致します。</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p>参照: <a href="arrays.html#Base.circshift"><code>circshift</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; src = reshape(Vector(1:16), (4,4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; dest = OffsetArray{Int}(undef, (0:3,2:5));

julia&gt; circcopy!(dest, src)
4×4 OffsetArray(::Matrix{Int64}, 0:3, 2:5) with eltype Int64 with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia&gt; dest[1:3,2:4] == src[1:3,2:4]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L1302-L1336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findall-Tuple{Any}" href="#Base.findall-Tuple{Any}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findall(A)</code></pre><p>ベクトル <code>I</code> を返し、<code>A</code> の <code>true</code> インデックスまたはキーを含みます。<code>A</code> にそのような要素がない場合は、空の配列を返します。他の種類の値を検索するには、最初の引数として述語を渡します。</p><p>インデックスまたはキーは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(A)</code></a> によって返されるものと同じ型です。</p><p>他にも: <a href="arrays.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>, <a href="sort.html#Base.Sort.searchsorted"><code>searchsorted</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true, false, false, true]
4-element Vector{Bool}:
 1
 0
 0
 1

julia&gt; findall(A)
2-element Vector{Int64}:
 1
 4

julia&gt; A = [true false; false true]
2×2 Matrix{Bool}:
 1  0
 0  1

julia&gt; findall(A)
2-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia&gt; findall(falses(3))
Int64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2708-L2747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findall-Tuple{Function, Any}" href="#Base.findall-Tuple{Function, Any}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findall(f::Function, A)</code></pre><p><code>f(A[I])</code> が <code>true</code> を返す <code>A</code> のインデックスまたはキーのベクトル <code>I</code> を返します。<code>A</code> のそのような要素がない場合は、空の配列を返します。</p><p>インデックスまたはキーは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(A)</code></a> によって返されるものと同じ型です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1, 3, 4]
3-element Vector{Int64}:
 1
 3
 4

julia&gt; findall(isodd, x)
2-element Vector{Int64}:
 1
 2

julia&gt; A = [1 2 0; 3 4 0]
2×3 Matrix{Int64}:
 1  2  0
 3  4  0
julia&gt; findall(isodd, A)
2-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)

julia&gt; findall(!iszero, A)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia&gt; d = Dict(:A =&gt; 10, :B =&gt; -1, :C =&gt; 0)
Dict{Symbol, Int64} with 3 entries:
  :A =&gt; 10
  :B =&gt; -1
  :C =&gt; 0

julia&gt; findall(≥(0), d)
2-element Vector{Symbol}:
 :A
 :C
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2648-L2698">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findfirst-Tuple{Any}" href="#Base.findfirst-Tuple{Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findfirst(A)</code></pre><p><code>A</code>の最初の<code>true</code>値のインデックスまたはキーを返します。そのような値が見つからない場合は<code>nothing</code>を返します。他の種類の値を検索するには、最初の引数として述語を渡します。</p><p>インデックスまたはキーは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(A)</code></a>によって返されるものと同じ型です。</p><p>他にも: <a href="arrays.html#Base.findall-Tuple{Any}"><code>findall</code></a>, <a href="arrays.html#Base.findnext-Tuple{Any, Integer}"><code>findnext</code></a>, <a href="arrays.html#Base.findlast-Tuple{Any}"><code>findlast</code></a>, <a href="sort.html#Base.Sort.searchsortedfirst"><code>searchsortedfirst</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [false, false, true, false]
4-element Vector{Bool}:
 0
 0
 1
 0

julia&gt; findfirst(A)
3

julia&gt; findfirst(falses(3)) # 何も返さないが、REPLには表示されない

julia&gt; A = [false false; true false]
2×2 Matrix{Bool}:
 0  0
 1  0

julia&gt; findfirst(A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2316-L2350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findfirst-Tuple{Function, Any}" href="#Base.findfirst-Tuple{Function, Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findfirst(predicate::Function, A)</code></pre><p><code>predicate</code> が <code>true</code> を返す <code>A</code> の最初の要素のインデックスまたはキーを返します。そのような要素がない場合は <code>nothing</code> を返します。</p><p>インデックスまたはキーは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(A)</code></a> によって返されるものと同じ型です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 4, 2, 2]
4-element Vector{Int64}:
 1
 4
 2
 2

julia&gt; findfirst(iseven, A)
2

julia&gt; findfirst(x -&gt; x&gt;10, A) # nothing を返しますが、REPL には表示されません

julia&gt; findfirst(isequal(4), A)
2

julia&gt; A = [1 4; 2 2]
2×2 Matrix{Int64}:
 1  4
 2  2

julia&gt; findfirst(iseven, A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2398-L2432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findlast-Tuple{Any}" href="#Base.findlast-Tuple{Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findlast(A)</code></pre><p><code>A</code>の最後の<code>true</code>値のインデックスまたはキーを返します。<code>A</code>に<code>true</code>値がない場合は<code>nothing</code>を返します。</p><p>インデックスまたはキーは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(A)</code></a>によって返されるものと同じ型です。</p><p>他にも: <a href="arrays.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>, <a href="arrays.html#Base.findprev-Tuple{Any, Integer}"><code>findprev</code></a>, <a href="arrays.html#Base.findall-Tuple{Any}"><code>findall</code></a>があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true, false, true, false]
4-element Vector{Bool}:
 1
 0
 1
 0

julia&gt; findlast(A)
3

julia&gt; A = falses(2,2);

julia&gt; findlast(A) # 何も返さないが、REPLには表示されない

julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; findlast(A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2503-L2538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findlast-Tuple{Function, Any}" href="#Base.findlast-Tuple{Function, Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findlast(predicate::Function, A)</code></pre><p><code>predicate</code>が<code>true</code>を返す<code>A</code>の最後の要素のインデックスまたはキーを返します。そのような要素がない場合は<code>nothing</code>を返します。</p><p>インデックスまたはキーは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(A)</code></a>によって返されるものと同じ型です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 2, 3, 4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; findlast(isodd, A)
3

julia&gt; findlast(x -&gt; x &gt; 5, A) # nothingを返しますが、REPLには表示されません

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; findlast(isodd, A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2594-L2625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findnext-Tuple{Any, Integer}" href="#Base.findnext-Tuple{Any, Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnext(A, i)</code></pre><p><code>A</code>の<code>true</code>要素の<code>i</code>以降の次のインデックスを見つけるか、見つからなければ<code>nothing</code>を返します。</p><p>インデックスは<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(A)</code></a>によって返されるものと同じ型です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [false, false, true, false]
4-element Vector{Bool}:
 0
 0
 1
 0

julia&gt; findnext(A, 1)
3

julia&gt; findnext(A, 4) # nothingを返しますが、REPLには表示されません

julia&gt; A = [false false; true false]
2×2 Matrix{Bool}:
 0  0
 1  0

julia&gt; findnext(A, CartesianIndex(1, 1))
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2282-L2313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findnext-Tuple{Function, Any, Integer}" href="#Base.findnext-Tuple{Function, Any, Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findnext(predicate::Function, A, i)</code></pre><p><code>predicate</code>が<code>true</code>を返す<code>A</code>の要素の<code>i</code>以降の次のインデックスを見つけるか、見つからなければ<code>nothing</code>を返します。これは、<a href="collections.html#Base.getindex"><code>getindex</code></a>、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>、および<a href="arrays.html#Base.nextind"><code>nextind</code></a>をサポートする配列、文字列、およびほとんどの他のコレクションで機能します。</p><p>インデックスは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(A)</code></a>によって返されるものと同じ型です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 4, 2, 2];

julia&gt; findnext(isodd, A, 1)
1

julia&gt; findnext(isodd, A, 2) # nothingを返しますが、REPLには表示されません

julia&gt; A = [1 4; 2 2];

julia&gt; findnext(isodd, A, CartesianIndex(1, 1))
CartesianIndex(1, 1)

julia&gt; findnext(isspace, &quot;a b c&quot;, 3)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2356-L2384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findprev-Tuple{Any, Integer}" href="#Base.findprev-Tuple{Any, Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findprev(A, i)</code></pre><p><code>A</code>の<code>true</code>要素の<code>i</code>の前または<code>i</code>を含む前のインデックスを見つける。見つからない場合は<code>nothing</code>を返す。</p><p>インデックスは<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(A)</code></a>によって返されるものと同じ型である。</p><p>関連: <a href="arrays.html#Base.findnext-Tuple{Any, Integer}"><code>findnext</code></a>, <a href="arrays.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>, <a href="arrays.html#Base.findall-Tuple{Any}"><code>findall</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [false, false, true, true]
4-element Vector{Bool}:
 0
 0
 1
 1

julia&gt; findprev(A, 3)
3

julia&gt; findprev(A, 1) # nothingを返すが、REPLには表示されない

julia&gt; A = [false false; true true]
2×2 Matrix{Bool}:
 0  0
 1  1

julia&gt; findprev(A, CartesianIndex(2, 1))
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2467-L2500">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findprev-Tuple{Function, Any, Integer}" href="#Base.findprev-Tuple{Function, Any, Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findprev(predicate::Function, A, i)</code></pre><p><code>predicate</code> が <code>true</code> を返す <code>A</code> の要素の、<code>i</code> の前または <code>i</code> を含む前のインデックスを見つけます。見つからない場合は <code>nothing</code> を返します。これは、<a href="collections.html#Base.getindex"><code>getindex</code></a>、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a>、および <a href="arrays.html#Base.nextind"><code>nextind</code></a> をサポートする配列、文字列、およびほとんどの他のコレクションで機能します。</p><p>インデックスは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(A)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(A)</code></a> によって返されるものと同じ型です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4, 6, 1, 2]
4-element Vector{Int64}:
 4
 6
 1
 2

julia&gt; findprev(isodd, A, 1) # 何も返さないが、REPL には表示されない

julia&gt; findprev(isodd, A, 3)
3

julia&gt; A = [4 6; 1 2]
2×2 Matrix{Int64}:
 4  6
 1  2

julia&gt; findprev(isodd, A, CartesianIndex(1, 2))
CartesianIndex(2, 1)

julia&gt; findprev(isspace, &quot;a b c&quot;, 3)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2544-L2580">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.permutedims" href="#Base.permutedims"><code>Base.permutedims</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permutedims(v::AbstractVector)</code></pre><p>ベクトル <code>v</code> を <code>1 × length(v)</code> の行行列に変形します。操作が再帰的でないため、<a href="../stdlib/LinearAlgebra.html#Base.transpose"><code>transpose</code></a> とは異なり、特に非数値の値の配列に対して便利です（再帰的な <code>transpose</code> はエラーを引き起こす可能性があります）。</p><p><strong>例</strong></p><p><code>transpose</code> とは異なり、<code>permutedims</code> は文字列などの任意の非数値要素のベクトルに使用できます：</p><pre><code class="language-julia-repl hljs">julia&gt; permutedims([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
1×3 Matrix{String}:
 &quot;a&quot;  &quot;b&quot;  &quot;c&quot;</code></pre><p>数値のベクトルに対しては、<code>permutedims(v)</code> は <code>transpose(v)</code> とほぼ同様に機能しますが、戻り値の型が異なります（<code>LinearAlgebra.Transpose</code> ビューではなく、<a href="arrays.html#Base.reshape"><code>reshape</code></a> を使用しますが、どちらも元の配列 <code>v</code> とメモリを共有します）：</p><pre><code class="language-julia-repl hljs">julia&gt; v = [1, 2, 3, 4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; p = permutedims(v)
1×4 Matrix{Int64}:
 1  2  3  4

julia&gt; r = transpose(v)
1×4 transpose(::Vector{Int64}) with eltype Int64:
 1  2  3  4

julia&gt; p == r
true

julia&gt; typeof(r)
Transpose{Int64, Vector{Int64}}

julia&gt; p[1] = 5; r[2] = 6; # p または r を変更すると v も変わります

julia&gt; v # p と r の両方とメモリを共有
4-element Vector{Int64}:
 5
 6
 3
 4</code></pre><p>しかし、<code>permutedims</code> は、要素が数値行列であるベクトルに対しては <code>transpose</code> とは異なる結果を生成します：</p><pre><code class="language-julia-repl hljs">julia&gt; V = [[[1 2; 3 4]]; [[5 6; 7 8]]]
2-element Vector{Matrix{Int64}}:
 [1 2; 3 4]
 [5 6; 7 8]

julia&gt; permutedims(V)
1×2 Matrix{Matrix{Int64}}:
 [1 2; 3 4]  [5 6; 7 8]

julia&gt; transpose(V)
1×2 transpose(::Vector{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:
 [1 3; 2 4]  [5 7; 6 8]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/permuteddimsarray.jl#L203-L270">source</a></section><section><div><pre><code class="language-julia hljs">permutedims(A::AbstractArray, perm)
permutedims(A::AbstractMatrix)</code></pre><p>配列 <code>A</code> の次元（軸）を入れ替えます。<code>perm</code> は、置換を指定する <code>ndims(A)</code> の整数のタプルまたはベクターです。</p><p><code>A</code> が 2 次元配列（<a href="arrays.html#Base.AbstractMatrix"><code>AbstractMatrix</code></a>）の場合、<code>perm</code> はデフォルトで <code>(2,1)</code> となり、<code>A</code> の 2 つの軸（行と列）を入れ替えます。これは、操作が再帰的でないため、特に数値以外の値の配列（再帰的な <code>transpose</code> がエラーを引き起こす場合）や線形演算子を表さない 2 次元配列に対して便利です。</p><p>1 次元配列については、<a href="arrays.html#Base.permutedims"><code>permutedims(v::AbstractVector)</code></a> を参照してください。これは 1 行の「行列」を返します。</p><p>他にも <a href="arrays.html#Base.permutedims!"><code>permutedims!</code></a>、<a href="arrays.html#Base.PermutedDimsArrays.PermutedDimsArray"><code>PermutedDimsArray</code></a>、<a href="../stdlib/LinearAlgebra.html#Base.transpose"><code>transpose</code></a>、<a href="arrays.html#Base.invperm"><code>invperm</code></a> があります。</p><p><strong>例</strong></p><p><strong>2 次元配列:</strong></p><p><code>transpose</code> とは異なり、<code>permutedims</code> は任意の非数値要素（文字列など）を持つ 2 次元配列の行と列を入れ替えるために使用できます。</p><pre><code class="language-julia-repl hljs">julia&gt; A = [&quot;a&quot; &quot;b&quot; &quot;c&quot;
            &quot;d&quot; &quot;e&quot; &quot;f&quot;]
2×3 Matrix{String}:
 &quot;a&quot;  &quot;b&quot;  &quot;c&quot;
 &quot;d&quot;  &quot;e&quot;  &quot;f&quot;

julia&gt; permutedims(A)
3×2 Matrix{String}:
 &quot;a&quot;  &quot;d&quot;
 &quot;b&quot;  &quot;e&quot;
 &quot;c&quot;  &quot;f&quot;</code></pre><p>また、<code>permutedims</code> は、要素が数値行列である行列に対して <code>transpose</code> とは異なる結果を生成します。</p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4];

julia&gt; b = [5 6; 7 8];

julia&gt; c = [9 10; 11 12];

julia&gt; d = [13 14; 15 16];

julia&gt; X = [[a] [b]; [c] [d]]
2×2 Matrix{Matrix{Int64}}:
 [1 2; 3 4]     [5 6; 7 8]
 [9 10; 11 12]  [13 14; 15 16]

julia&gt; permutedims(X)
2×2 Matrix{Matrix{Int64}}:
 [1 2; 3 4]  [9 10; 11 12]
 [5 6; 7 8]  [13 14; 15 16]

julia&gt; transpose(X)
2×2 transpose(::Matrix{Matrix{Int64}}) with eltype Transpose{Int64, Matrix{Int64}}:
 [1 3; 2 4]  [9 11; 10 12]
 [5 7; 6 8]  [13 15; 14 16]</code></pre><p><strong>多次元配列</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(Vector(1:8), (2,2,2))
2×2×2 Array{Int64, 3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 5  7
 6  8

julia&gt; perm = (3, 1, 2); # 最後の次元を最初に置く

julia&gt; B = permutedims(A, perm)
2×2×2 Array{Int64, 3}:
[:, :, 1] =
 1  2
 5  6

[:, :, 2] =
 3  4
 7  8

julia&gt; A == permutedims(B, invperm(perm)) # 逆置換
true</code></pre><p><code>B = permutedims(A, perm)</code> の各次元 <code>i</code> に対して、その対応する次元は <code>A</code> の <code>perm[i]</code> になります。これは、等式 <code>size(B, i) == size(A, perm[i])</code> が成り立つことを意味します。</p><pre><code class="language-julia-repl hljs">julia&gt; A = randn(5, 7, 11, 13);

julia&gt; perm = [4, 1, 3, 2];

julia&gt; B = permutedims(A, perm);

julia&gt; size(B)
(13, 5, 11, 7)

julia&gt; size(A)[perm] == ans
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/permuteddimsarray.jl#L88-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.permutedims!" href="#Base.permutedims!"><code>Base.permutedims!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permutedims!(dest, src, perm)</code></pre><p>配列 <code>src</code> の次元を入れ替え、その結果を配列 <code>dest</code> に格納します。<code>perm</code> は <code>ndims(src)</code> の長さを持つ順列を指定するベクターです。事前に割り当てられた配列 <code>dest</code> は <code>size(dest) == size(src)[perm]</code> である必要があり、完全に上書きされます。インプレースの入れ替えはサポートされておらず、<code>src</code> と <code>dest</code> が重複するメモリ領域を持つ場合、予期しない結果が生じる可能性があります。</p><p>関連情報は <a href="arrays.html#Base.permutedims"><code>permutedims</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/permuteddimsarray.jl#L273-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.PermutedDimsArrays.PermutedDimsArray" href="#Base.PermutedDimsArrays.PermutedDimsArray"><code>Base.PermutedDimsArrays.PermutedDimsArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PermutedDimsArray(A, perm) -&gt; B</code></pre><p>与えられた AbstractArray <code>A</code> に対して、次元が入れ替わったように見えるビュー <code>B</code> を作成します。<code>permutedims</code> に似ていますが、コピーは行われず (<code>B</code> は <code>A</code> とストレージを共有します)。</p><p>参照: <a href="arrays.html#Base.permutedims"><code>permutedims</code></a>, <a href="arrays.html#Base.invperm"><code>invperm</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(3,5,4);

julia&gt; B = PermutedDimsArray(A, (3,1,2));

julia&gt; size(B)
(4, 3, 5)

julia&gt; B[3,1,2] == A[1,2,3]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/permuteddimsarray.jl#L20-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.promote_shape" href="#Base.promote_shape"><code>Base.promote_shape</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">promote_shape(s1, s2)</code></pre><p>2つの配列の形状が互換性があるかを確認し、末尾の単一次元を許可し、より多くの次元を持つ形状を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = fill(1, (3,4,1,1,1));

julia&gt; b = fill(1, (3,4));

julia&gt; promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia&gt; promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/indices.jl#L155-L173">source</a></section></article><h2 id="Array-functions"><a class="docs-heading-anchor" href="#Array-functions">Array functions</a><a id="Array-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Array-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.accumulate" href="#Base.accumulate"><code>Base.accumulate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accumulate(op, A; dims::Integer, [init])</code></pre><p>累積操作 <code>op</code> を <code>A</code> の次元 <code>dims</code> に沿って実行します（<code>dims</code> はベクトルの場合はオプションです）。初期値 <code>init</code> はキーワード引数としてオプションで提供できます。出力の精度を制御し（例えば、オーバーフローを避けるために）、パフォーマンスのために事前に割り当てられた出力配列を使用するには、<a href="arrays.html#Base.accumulate!"><code>accumulate!</code></a> も参照してください。</p><p>一般的な操作には、<a href="arrays.html#Base.cumsum"><code>cumsum</code></a> や <a href="arrays.html#Base.cumprod"><code>cumprod</code></a> のような専門的なバリアントがあります。遅延バージョンについては、<a href="iterators.html#Base.Iterators.accumulate"><code>Iterators.accumulate</code></a> を参照してください。</p><div class="admonition is-compat" id="Julia-1.5-75d1e5cff7921f5e"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-75d1e5cff7921f5e" title="Permalink"></a></header><div class="admonition-body"><p>非配列イテレータ上の <code>accumulate</code> は、少なくとも Julia 1.5 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; accumulate(+, [1,2,3])
3-element Vector{Int64}:
 1
 3
 6

julia&gt; accumulate(min, (1, -2, 3, -4, 5), init=0)
(0, -2, -2, -4, -4)

julia&gt; accumulate(/, (2, 4, Inf), init=100)
(50.0, 12.5, 0.0)

julia&gt; accumulate(=&gt;, i^2 for i in 1:3)
3-element Vector{Any}:
          1
        1 =&gt; 4
 (1 =&gt; 4) =&gt; 9

julia&gt; accumulate(+, fill(1, 3, 4))
3×4 Matrix{Int64}:
 1  4  7  10
 2  5  8  11
 3  6  9  12

julia&gt; accumulate(+, fill(1, 2, 5), dims=2, init=100.0)
2×5 Matrix{Float64}:
 101.0  102.0  103.0  104.0  105.0
 101.0  102.0  103.0  104.0  105.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L234-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.accumulate!" href="#Base.accumulate!"><code>Base.accumulate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">accumulate!(op, B, A; [dims], [init])</code></pre><p>累積操作 <code>op</code> を <code>A</code> の次元 <code>dims</code> に沿って行い、結果を <code>B</code> に格納します。ベクトルの場合、<code>dims</code> を指定することはオプションです。キーワード引数 <code>init</code> が指定されている場合、その値が累積の初期値として使用されます。</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p>関連情報としては <a href="arrays.html#Base.accumulate"><code>accumulate</code></a>、<a href="arrays.html#Base.cumsum!"><code>cumsum!</code></a>、<a href="arrays.html#Base.cumprod!"><code>cumprod!</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1, 0, 2, 0, 3];

julia&gt; y = rand(5);

julia&gt; accumulate!(+, y, x);

julia&gt; y
5-element Vector{Float64}:
 1.0
 1.0
 3.0
 3.0
 6.0

julia&gt; A = [1 2 3; 4 5 6];

julia&gt; B = similar(A);

julia&gt; accumulate!(-, B, A, dims=1)
2×3 Matrix{Int64}:
  1   2   3
 -3  -3  -3

julia&gt; accumulate!(*, B, A, dims=2, init=10)
2×3 Matrix{Int64}:
 10   20    60
 40  200  1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L305-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cumprod" href="#Base.cumprod"><code>Base.cumprod</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumprod(itr)</code></pre><p>イテレータの累積積。</p><p>他にも <a href="arrays.html#Base.cumprod!"><code>cumprod!</code></a>、<a href="arrays.html#Base.accumulate"><code>accumulate</code></a>、<a href="arrays.html#Base.cumsum"><code>cumsum</code></a> を参照してください。</p><div class="admonition is-compat" id="Julia-1.5-c4cfa3feae50c61"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-c4cfa3feae50c61" title="Permalink"></a></header><div class="admonition-body"><p>非配列イテレータに対する <code>cumprod</code> は、少なくとも Julia 1.5 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cumprod(fill(1//2, 3))
3-element Vector{Rational{Int64}}:
 1//2
 1//4
 1//8

julia&gt; cumprod((1, 2, 1, 3, 1))
(1, 2, 2, 6, 6)

julia&gt; cumprod(&quot;julia&quot;)
5-element Vector{String}:
 &quot;j&quot;
 &quot;ju&quot;
 &quot;jul&quot;
 &quot;juli&quot;
 &quot;julia&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L200-L229">source</a></section><section><div><pre><code class="language-julia hljs">cumprod(A; dims::Integer)</code></pre><p>次元 <code>dim</code> に沿った累積積。パフォーマンスのために事前に割り当てられた出力配列を使用するには、<a href="arrays.html#Base.cumprod!"><code>cumprod!</code></a> も参照してください。また、出力の精度を制御するためにも使用できます（例：オーバーフローを避けるため）。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Int8[1 2 3; 4 5 6];

julia&gt; cumprod(a, dims=1)
2×3 Matrix{Int64}:
 1   2   3
 4  10  18

julia&gt; cumprod(a, dims=2)
2×3 Matrix{Int64}:
 1   2    6
 4  20  120</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L174-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cumprod!" href="#Base.cumprod!"><code>Base.cumprod!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumprod!(y::AbstractVector, x::AbstractVector)</code></pre><p>ベクトル <code>x</code> の累積積を計算し、その結果を <code>y</code> に格納します。詳細は <a href="arrays.html#Base.cumprod"><code>cumprod</code></a> を参照してください。</p><div class="admonition is-warning" id="Warning-c8dc157b3981446e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-c8dc157b3981446e" title="Permalink"></a></header><div class="admonition-body"><p>いずれかの変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L164-L171">source</a></section><section><div><pre><code class="language-julia hljs">cumprod!(B, A; dims::Integer)</code></pre><p><code>A</code>に沿った次元<code>dims</code>の累積積を計算し、結果を<code>B</code>に格納します。詳細は<a href="arrays.html#Base.cumprod"><code>cumprod</code></a>を参照してください。</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cumsum" href="#Base.cumsum"><code>Base.cumsum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumsum(itr)</code></pre><p>イテレータの累積和。</p><p>他の関数を適用するには、<a href="arrays.html#Base.accumulate"><code>accumulate</code></a>を参照してください。</p><div class="admonition is-compat" id="Julia-1.5-9104536e325d715c"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-9104536e325d715c" title="Permalink"></a></header><div class="admonition-body"><p>非配列イテレータに対する<code>cumsum</code>は、少なくともJulia 1.5が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cumsum(1:3)
3-element Vector{Int64}:
 1
 3
 6

julia&gt; cumsum((true, false, true, false, true))
(1, 1, 2, 2, 3)

julia&gt; cumsum(fill(1, 2) for i in 1:3)
3-element Vector{Vector{Int64}}:
 [1, 1]
 [2, 2]
 [3, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L121-L148">source</a></section><section><div><pre><code class="language-julia hljs">cumsum(A; dims::Integer)</code></pre><p>次元 <code>dims</code> に沿った累積和。パフォーマンスのため、また出力の精度を制御するため（例えば、オーバーフローを避けるため）に、事前に割り当てられた出力配列を使用するには、<a href="arrays.html#Base.cumsum!"><code>cumsum!</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; cumsum(a, dims=1)
2×3 Matrix{Int64}:
 1  2  3
 5  7  9

julia&gt; cumsum(a, dims=2)
2×3 Matrix{Int64}:
 1  3   6
 4  9  15</code></pre><div class="admonition is-info" id="Note-53b3957edfff53d3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-53b3957edfff53d3" title="Permalink"></a></header><div class="admonition-body"><p>戻り配列の <code>eltype</code> は、システムワードサイズ未満の符号付き整数の場合は <code>Int</code>、システムワードサイズ未満の符号なし整数の場合は <code>UInt</code> です。小さな符号付きまたは符号なし整数の配列の <code>eltype</code> を保持するには、<code>accumulate(+, A)</code> を使用する必要があります。</p><pre><code class="language-julia-repl hljs">julia&gt; cumsum(Int8[100, 28])
2-element Vector{Int64}:
 100
 128

julia&gt; accumulate(+,Int8[100, 28])
2-element Vector{Int8}:
  100
 -128</code></pre><p>前者の場合、整数はシステムワードサイズに拡張され、その結果は <code>Int64[100, 128]</code> になります。後者の場合、そのような拡張は行われず、整数のオーバーフローが <code>Int8[100, -128]</code> になります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L69-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.cumsum!" href="#Base.cumsum!"><code>Base.cumsum!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cumsum!(B, A; dims::Integer)</code></pre><p><code>A</code>の累積和を次元<code>dims</code>に沿って計算し、結果を<code>B</code>に格納します。詳細は<a href="arrays.html#Base.cumsum"><code>cumsum</code></a>を参照してください。</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/accumulate.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.diff" href="#Base.diff"><code>Base.diff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff(A::AbstractVector)
diff(A::AbstractArray; dims::Integer)</code></pre><p>ベクトルまたは多次元配列 <code>A</code> に対する有限差分演算子。後者の場合、操作する次元は <code>dims</code> キーワード引数で指定する必要があります。</p><div class="admonition is-compat" id="Julia-1.1-f1f85c3b5ace22f3"><header class="admonition-header">Julia 1.1<a class="admonition-anchor" href="#Julia-1.1-f1f85c3b5ace22f3" title="Permalink"></a></header><div class="admonition-body"><p>次元が2より大きい配列に対する <code>diff</code> は、少なくとも Julia 1.1 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [2 4; 6 16]
2×2 Matrix{Int64}:
 2   4
 6  16

julia&gt; diff(a, dims=2)
2×1 Matrix{Int64}:
  2
 10

julia&gt; diff(vec(a))
3-element Vector{Int64}:
  4
 -2
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/multidimensional.jl#L1043-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">repeat(c::AbstractChar, r::Integer) -&gt; String</code></pre><p>文字を <code>r</code> 回繰り返します。これは、<a href="strings.html#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>c^r</code></a> を呼び出すことによって同等に達成できます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(&#39;A&#39;, 3)
&quot;AAA&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/strings/string.jl#L561-L572">source</a></section><section><div><pre><code class="language-julia hljs">repeat(s::AbstractString, r::Integer)</code></pre><p>文字列を <code>r</code> 回繰り返します。これは <code>s^r</code> として書くことができます。</p><p>関連項目 <a href="strings.html#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>^</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(&quot;ha&quot;, 3)
&quot;hahaha&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/strings/basic.jl#L752-L764">source</a></section><section><div><pre><code class="language-julia hljs">repeat(A::AbstractArray; inner=ntuple(Returns(1), ndims(A)), outer=ntuple(Returns(1), ndims(A)))</code></pre><p>配列 <code>A</code> のエントリを繰り返すことによって配列を構築します。<code>inner</code> の i 番目の要素は、<code>A</code> の i 番目の次元の個々のエントリを繰り返す回数を指定します。<code>outer</code> の i 番目の要素は、<code>A</code> の i 番目の次元に沿ったスライスを繰り返す回数を指定します。<code>inner</code> または <code>outer</code> が省略された場合、繰り返しは行われません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(1:2, inner=2)
4-element Vector{Int64}:
 1
 1
 2
 2

julia&gt; repeat(1:2, outer=2)
4-element Vector{Int64}:
 1
 2
 1
 2

julia&gt; repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Matrix{Int64}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L439-L471">source</a></section><section><div><pre><code class="language-julia hljs">repeat(A::AbstractArray, counts::Integer...)</code></pre><p>配列 <code>A</code> を各次元で指定された回数 <code>counts</code> だけ繰り返すことによって配列を構築します。</p><p>関連情報: <a href="arrays.html#Base.fill"><code>fill</code></a>, <a href="iterators.html#Base.Iterators.repeated"><code>Iterators.repeated</code></a>, <a href="iterators.html#Base.Iterators.cycle"><code>Iterators.cycle</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat([1, 2, 3], 2)
6-element Vector{Int64}:
 1
 2
 3
 1
 2
 3

julia&gt; repeat([1, 2, 3], 2, 3)
6×3 Matrix{Int64}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarraymath.jl#L407-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rot180" href="#Base.rot180"><code>Base.rot180</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rot180(A, k)</code></pre><p>行列 <code>A</code> を180度、整数 <code>k</code> 回回転させます。<code>k</code> が偶数の場合、これは <code>copy</code> と同等です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rot180(a,1)
2×2 Matrix{Int64}:
 4  3
 2  1

julia&gt; rot180(a,2)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L260-L283">source</a></section><section><div><pre><code class="language-julia hljs">rot180(A)</code></pre><p>行列 <code>A</code> を180度回転させます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rot180(a)
2×2 Matrix{Int64}:
 4  3
 2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L158-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rotl90" href="#Base.rotl90"><code>Base.rotl90</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotl90(A, k)</code></pre><p>行列 <code>A</code> を整数 <code>k</code> 回 90 度反時計回りに左回転させます。<code>k</code> が 4 の倍数（ゼロを含む）の場合、これは <code>copy</code> と同等です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotl90(a,1)
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; rotl90(a,2)
2×2 Matrix{Int64}:
 4  3
 2  1

julia&gt; rotl90(a,3)
2×2 Matrix{Int64}:
 3  1
 4  2

julia&gt; rotl90(a,4)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L185-L218">source</a></section><section><div><pre><code class="language-julia hljs">rotl90(A)</code></pre><p>行列 <code>A</code> を左に90度回転させます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotl90(a)
2×2 Matrix{Int64}:
 2  4
 1  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L103-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rotr90" href="#Base.rotr90"><code>Base.rotr90</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotr90(A, k)</code></pre><p>行列 <code>A</code> を整数 <code>k</code> 回、時計回りに90度回転させます。<code>k</code> が4の倍数（ゼロを含む）の場合、これは <code>copy</code> と同等です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotr90(a,1)
2×2 Matrix{Int64}:
 3  1
 4  2

julia&gt; rotr90(a,2)
2×2 Matrix{Int64}:
 4  3
 2  1

julia&gt; rotr90(a,3)
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; rotr90(a,4)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L225-L258">source</a></section><section><div><pre><code class="language-julia hljs">rotr90(A)</code></pre><p>行列 <code>A</code> を右に90度回転させます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotr90(a)
2×2 Matrix{Int64}:
 3  1
 4  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L131-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mapslices" href="#Base.mapslices"><code>Base.mapslices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapslices(f, A; dims)</code></pre><p>与えられた配列 <code>A</code> の次元を、各スライス <code>A[..., :, ..., :, ...]</code> に関数 <code>f</code> を適用することで変換します。<code>dims</code> の各 <code>d</code> にはコロンが入ります。結果は残りの次元に沿って連結されます。</p><p>例えば、<code>dims = [1,2]</code> で <code>A</code> が4次元の場合、<code>f</code> はすべての <code>i</code> と <code>j</code> に対して <code>x = A[:,:,i,j]</code> に対して呼び出され、<code>f(x)</code> は結果 <code>R</code> の中で <code>R[:,:,i,j]</code> になります。</p><p><a href="arrays.html#Base.eachcol"><code>eachcol</code></a> や <a href="arrays.html#Base.eachslice"><code>eachslice</code></a> も参照してください。これらは <a href="collections.html#Base.map"><code>map</code></a> や <a href="arrays.html#Base.stack"><code>stack</code></a> と一緒に使用されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(1:30,(2,5,3))
2×5×3 reshape(::UnitRange{Int64}, 2, 5, 3) with eltype Int64:
[:, :, 1] =
 1  3  5  7   9
 2  4  6  8  10

[:, :, 2] =
 11  13  15  17  19
 12  14  16  18  20

[:, :, 3] =
 21  23  25  27  29
 22  24  26  28  30

julia&gt; f(x::Matrix) = fill(x[1,1], 1,4);  # 1×4 行列を返す

julia&gt; B = mapslices(f, A, dims=(1,2))
1×4×3 Array{Int64, 3}:
[:, :, 1] =
 1  1  1  1

[:, :, 2] =
 11  11  11  11

[:, :, 3] =
 21  21  21  21

julia&gt; f2(x::AbstractMatrix) = fill(x[1,1], 1,4);

julia&gt; B == stack(f2, eachslice(A, dims=3))
true

julia&gt; g(x) = x[begin] // x[end-1];  # 数値を返す

julia&gt; mapslices(g, A, dims=[1,3])
1×5×1 Array{Rational{Int64}, 3}:
[:, :, 1] =
 1//21  3//23  1//5  7//27  9//29

julia&gt; map(g, eachslice(A, dims=2))
5-element Vector{Rational{Int64}}:
 1//21
 3//23
 1//5
 7//27
 9//29

julia&gt; mapslices(sum, A; dims=(1,3)) == sum(A; dims=(1,3))
true</code></pre><p><code>eachslice(A; dims=2)</code> では、指定された次元はスライス内でコロンがない次元です。これは <code>view(A,:,i,:)</code> ですが、<code>mapslices(f, A; dims=(1,3))</code> は <code>A[:,i,:]</code> を使用します。関数 <code>f</code> はスライス内の値を変更することができますが、<code>A</code> には影響を与えません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/abstractarray.jl#L3196-L3265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachrow" href="#Base.eachrow"><code>Base.eachrow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachrow(A::AbstractVecOrMat) &lt;: AbstractVector</code></pre><p>行列またはベクトル <code>A</code> の行のベクトルである <a href="arrays.html#Base.RowSlices"><code>RowSlices</code></a> オブジェクトを作成します。行スライスは <code>A</code> の <code>AbstractVector</code> ビューとして返されます。</p><p>逆については <a href="arrays.html#Base.stack"><code>stack</code></a><code>(rows; dims=1)</code> を参照してください。</p><p>他にも <a href="arrays.html#Base.eachcol"><code>eachcol</code></a>、<a href="arrays.html#Base.eachslice"><code>eachslice</code></a>、および <a href="arrays.html#Base.mapslices"><code>mapslices</code></a> を参照してください。</p><div class="admonition is-compat" id="Julia-1.1-9371755af62f0d43"><header class="admonition-header">Julia 1.1<a class="admonition-anchor" href="#Julia-1.1-9371755af62f0d43" title="Permalink"></a></header><div class="admonition-body"><p>この関数は少なくとも Julia 1.1 を必要とします。</p></div></div><div class="admonition is-compat" id="Julia-1.9-c1b21fc43324bc11"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-c1b21fc43324bc11" title="Permalink"></a></header><div class="admonition-body"><p>Julia 1.9 より前は、これがイテレータを返していました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; s = eachrow(a)
2-element RowSlices{Matrix{Int64}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [1, 2]
 [3, 4]

julia&gt; s[1]
2-element view(::Matrix{Int64}, 1, :) with eltype Int64:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/slicearray.jl#L131-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachcol" href="#Base.eachcol"><code>Base.eachcol</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachcol(A::AbstractVecOrMat) &lt;: AbstractVector</code></pre><p>行列またはベクトル <code>A</code> の列のベクトルである <a href="arrays.html#Base.ColumnSlices"><code>ColumnSlices</code></a> オブジェクトを作成します。列スライスは <code>A</code> の <code>AbstractVector</code> ビューとして返されます。</p><p>逆に関しては、<a href="arrays.html#Base.stack"><code>stack</code></a><code>(cols)</code> または <code>reduce(</code><a href="arrays.html#Base.hcat"><code>hcat</code></a><code>, cols)</code> を参照してください。</p><p>他にも <a href="arrays.html#Base.eachrow"><code>eachrow</code></a>、<a href="arrays.html#Base.eachslice"><code>eachslice</code></a>、および <a href="arrays.html#Base.mapslices"><code>mapslices</code></a> を参照してください。</p><div class="admonition is-compat" id="Julia-1.1-b2474fcb5afc086a"><header class="admonition-header">Julia 1.1<a class="admonition-anchor" href="#Julia-1.1-b2474fcb5afc086a" title="Permalink"></a></header><div class="admonition-body"><p>この関数は少なくとも Julia 1.1 が必要です。</p></div></div><div class="admonition is-compat" id="Julia-1.9-c1b21fc43324bc11"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-c1b21fc43324bc11" title="Permalink"></a></header><div class="admonition-body"><p>Julia 1.9 より前は、これがイテレータを返していました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; s = eachcol(a)
2-element ColumnSlices{Matrix{Int64}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:
 [1, 3]
 [2, 4]

julia&gt; s[1]
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/slicearray.jl#L169-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachslice" href="#Base.eachslice"><code>Base.eachslice</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachslice(A::AbstractArray; dims, drop=true)</code></pre><p><a href="arrays.html#Base.Slices"><code>Slices</code></a> オブジェクトを作成し、<code>A</code> の次元 <code>dims</code> に対するスライスの配列を返し、<code>A</code> の他の次元からすべてのデータを選択するビューを返します。<code>dims</code> は整数または整数のタプルであることができます。</p><p><code>drop = true</code>（デフォルト）の場合、外側の <code>Slices</code> は内側の次元を削除し、次元の順序は <code>dims</code> の順序に一致します。<code>drop = false</code> の場合、<code>Slices</code> は基になる配列と同じ次元を持ち、内側の次元はサイズ 1 になります。</p><p><code>eachslice(A; dims::Integer)</code> の逆については <a href="arrays.html#Base.stack"><code>stack</code></a><code>(slices; dims)</code> を参照してください。</p><p>また、<a href="arrays.html#Base.eachrow"><code>eachrow</code></a>、<a href="arrays.html#Base.eachcol"><code>eachcol</code></a>、<a href="arrays.html#Base.mapslices"><code>mapslices</code></a>、および <a href="arrays.html#Base.selectdim"><code>selectdim</code></a> も参照してください。</p><div class="admonition is-compat" id="Julia-1.1-9371755af62f0d43"><header class="admonition-header">Julia 1.1<a class="admonition-anchor" href="#Julia-1.1-9371755af62f0d43" title="Permalink"></a></header><div class="admonition-body"><p>この関数は少なくとも Julia 1.1 を必要とします。</p></div></div><div class="admonition is-compat" id="Julia-1.9-f8778a7a284bcb73"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-f8778a7a284bcb73" title="Permalink"></a></header><div class="admonition-body"><p>Julia 1.9 より前は、これはイテレータを返し、単一の次元 <code>dims</code> のみがサポートされていました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = [1 2 3; 4 5 6; 7 8 9]
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; s = eachslice(m, dims=1)
3-element RowSlices{Matrix{Int64}, Tuple{Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [1, 2, 3]
 [4, 5, 6]
 [7, 8, 9]

julia&gt; s[1]
3-element view(::Matrix{Int64}, 1, :) with eltype Int64:
 1
 2
 3

julia&gt; eachslice(m, dims=1, drop=false)
3×1 Slices{Matrix{Int64}, Tuple{Int64, Colon}, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}, SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}, 2}:
 [1, 2, 3]
 [4, 5, 6]
 [7, 8, 9]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/slicearray.jl#L77-L126">source</a></section></article><h2 id="Combinatorics"><a class="docs-heading-anchor" href="#Combinatorics">Combinatorics</a><a id="Combinatorics-1"></a><a class="docs-heading-anchor-permalink" href="#Combinatorics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.invperm" href="#Base.invperm"><code>Base.invperm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invperm(v)</code></pre><p><code>v</code>の逆順列を返します。もし<code>B = A[v]</code>であれば、<code>A == B[invperm(v)]</code>です。</p><p>関連項目 <a href="sort.html#Base.sortperm"><code>sortperm</code></a>, <a href="arrays.html#Base.invpermute!"><code>invpermute!</code></a>, <a href="arrays.html#Base.isperm"><code>isperm</code></a>, <a href="arrays.html#Base.permutedims"><code>permutedims</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = (2, 3, 1);

julia&gt; invperm(p)
(3, 1, 2)

julia&gt; v = [2; 4; 3; 1];

julia&gt; invperm(v)
4-element Vector{Int64}:
 4
 1
 3
 2

julia&gt; A = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];

julia&gt; B = A[v]
4-element Vector{Char}:
 &#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
 &#39;d&#39;: ASCII/Unicode U+0064 (category Ll: Letter, lowercase)
 &#39;c&#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
 &#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; B[invperm(v)]
4-element Vector{Char}:
 &#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
 &#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
 &#39;c&#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
 &#39;d&#39;: ASCII/Unicode U+0064 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/combinatorics.jl#L246-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isperm" href="#Base.isperm"><code>Base.isperm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isperm(v) -&gt; Bool</code></pre><p><code>v</code> が有効な置換であれば <code>true</code> を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isperm([1; 2])
true

julia&gt; isperm([1; 3])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/combinatorics.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.permute!-Tuple{Any, AbstractVector}" href="#Base.permute!-Tuple{Any, AbstractVector}"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permute!(v, p)</code></pre><p>ベクトル <code>v</code> を、順列 <code>p</code> に従ってインプレースで並べ替えます。<code>p</code> が順列であることを確認するチェックは行われません。</p><p>新しい順列を返すには、<code>v[p]</code> を使用します。これは一般的に <code>permute!(v, p)</code> よりも速いです。<code>u .= @view v[p]</code> を使って事前に割り当てられた出力配列に書き込む方がさらに速いです。（<code>permute!</code> は <code>v</code> をインプレースで上書きしますが、内部的にはどの要素が移動されたかを追跡するためにいくつかの割り当てが必要です。）</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><a href="arrays.html#Base.invpermute!"><code>invpermute!</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; permute!(A, perm);

julia&gt; A
4-element Vector{Int64}:
 1
 4
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/combinatorics.jl#L184-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.invpermute!" href="#Base.invpermute!"><code>Base.invpermute!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invpermute!(v, p)</code></pre><p><a href="arrays.html#Base.permute!-Tuple{Any, AbstractVector}"><code>permute!</code></a>と同様ですが、与えられた置換の逆が適用されます。</p><p>事前に割り当てられた出力配列（例：<code>u = similar(v)</code>）がある場合は、代わりに<code>u[p] = v</code>を使用する方が速いです。(<code>invpermute!</code>は内部でデータのコピーを割り当てます。)</p><div class="admonition is-warning" id="Warning-cb47bbe11ce4bc7d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-cb47bbe11ce4bc7d" title="Permalink"></a></header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; invpermute!(A, perm);

julia&gt; A
4-element Vector{Int64}:
 4
 1
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/combinatorics.jl#L217-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse-Tuple{AbstractVector}" href="#Base.reverse-Tuple{AbstractVector}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse(A; dims=:)</code></pre><p>次元 <code>dims</code> に沿って <code>A</code> を反転します。<code>dims</code> は整数（単一の次元）、整数のタプル（次元のタプル）、または <code>:</code>（すべての次元に沿って反転、デフォルト）です。インプレース反転については、<a href="arrays.html#Base.reverse!"><code>reverse!</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = Int64[1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; reverse(b, dims=2)
2×2 Matrix{Int64}:
 2  1
 4  3

julia&gt; reverse(b)
2×2 Matrix{Int64}:
 4  3
 2  1</code></pre><div class="admonition is-compat" id="Julia-1.6-796e6e1e2d1c13c"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-796e6e1e2d1c13c" title="Permalink"></a></header><div class="admonition-body"><p>Julia 1.6以前は、<code>reverse</code> では単一の整数 <code>dims</code> のみがサポートされていました。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L30-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverseind" href="#Base.reverseind"><code>Base.reverseind</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverseind(v, i)</code></pre><p>与えられたインデックス <code>i</code> に対して <a href="arrays.html#Base.reverse-Tuple{AbstractVector}"><code>reverse(v)</code></a> の中で、<code>v[reverseind(v,i)] == reverse(v)[i]</code> となる <code>v</code> 内の対応するインデックスを返します。 （<code>v</code> に非ASCII文字が含まれる場合、これは非自明な場合があります。）</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = &quot;Julia🚀&quot;
&quot;Julia🚀&quot;

julia&gt; r = reverse(s)
&quot;🚀ailuJ&quot;

julia&gt; for i in eachindex(s)
           print(r[reverseind(r, i)])
       end
Julia🚀</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/strings/basic.jl#L729-L749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reverse!(A; dims=:)</code></pre><p><a href="arrays.html#Base.reverse-Tuple{AbstractVector}"><code>reverse</code></a>と同様ですが、<code>A</code>内でインプレースで動作します。</p><div class="admonition is-compat" id="Julia-1.6-28b0f9201a1684bf"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-28b0f9201a1684bf" title="Permalink"></a></header><div class="admonition-body"><p>多次元の<code>reverse!</code>はJulia 1.6が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/arraymath.jl#L62-L69">source</a></section><section><div><pre><code class="language-julia hljs">reverse!(v [, start=firstindex(v) [, stop=lastindex(v) ]]) -&gt; v</code></pre><p><a href="arrays.html#Base.reverse-Tuple{AbstractVector}"><code>reverse</code></a> のインプレースバージョンです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Vector(1:5)
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; reverse!(A);

julia&gt; A
5-element Vector{Int64}:
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/array.jl#L2201-L2226">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="strings.html">« Strings</a><a class="docs-footer-nextpage" href="parallel.html">Tasks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 19 October 2025 05:51">Sunday 19 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
