<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multi-Threading · The Julia Language</title><meta name="title" content="Multi-Threading · The Julia Language"/><meta property="og:title" content="Multi-Threading · The Julia Language"/><meta property="twitter:title" content="Multi-Threading · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Essentials</a></li><li><a class="tocitem" href="collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="math.html">Mathematics</a></li><li><a class="tocitem" href="numbers.html">Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="arrays.html">Arrays</a></li><li><a class="tocitem" href="parallel.html">Tasks</a></li><li class="is-active"><a class="tocitem" href="multi-threading.html">Multi-Threading</a><ul class="internal"><li><a class="tocitem" href="#Atomic-operations"><span>Atomic operations</span></a></li><li><a class="tocitem" href="#ccall-using-a-libuv-threadpool-(Experimental)"><span>ccall using a libuv threadpool (Experimental)</span></a></li><li><a class="tocitem" href="#Low-level-synchronization-primitives"><span>Low-level synchronization primitives</span></a></li></ul></li><li><a class="tocitem" href="scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="constants.html">Constants</a></li><li><a class="tocitem" href="file.html">Filesystem</a></li><li><a class="tocitem" href="io-network.html">I/O and Network</a></li><li><a class="tocitem" href="punctuation.html">Punctuation</a></li><li><a class="tocitem" href="sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="c.html">C Interface</a></li><li><a class="tocitem" href="libc.html">C Standard Library</a></li><li><a class="tocitem" href="stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="multi-threading.html">Multi-Threading</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="multi-threading.html">Multi-Threading</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/multi-threading.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="lib-multithreading"><a class="docs-heading-anchor" href="#lib-multithreading">Multi-Threading</a><a id="lib-multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#lib-multithreading" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.@threads" href="#Base.Threads.@threads"><code>Base.Threads.@threads</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.@threads [schedule] for ... end</code></pre><p><code>for</code> ループを並列に実行するためのマクロです。反復空間は粗粒度のタスクに分配されます。このポリシーは <code>schedule</code> 引数によって指定できます。ループの実行は、すべての反復の評価が完了するまで待機します。</p><p>参照: <a href="multi-threading.html#Base.Threads.@spawn"><code>@spawn</code></a> および <a href="../stdlib/Distributed.html#man-distributed"><code>Distributed</code></a> の <code>pmap</code>。</p><p><strong>拡張ヘルプ</strong></p><p><strong>セマンティクス</strong></p><p>スケジューリングオプションによってより強力な保証が指定されない限り、<code>@threads</code> マクロによって実行されるループは以下のセマンティクスを持ちます。</p><p><code>@threads</code> マクロは、ループ本体を不特定の順序で、かつ潜在的に同時に実行します。タスクとワーカースレッドの正確な割り当ては指定されていません。割り当ては各実行ごとに異なる場合があります。ループ本体のコード（それから遷移的に呼び出されるコードを含む）は、タスクへの反復の分配や、それらが実行されるワーカースレッドについての仮定をしてはいけません。各反復のループ本体は、他の反復に依存せずに前進することができ、データ競合から解放されている必要があります。そのため、反復間での無効な同期はデッドロックを引き起こす可能性があり、同期されていないメモリアクセスは未定義の動作を引き起こす可能性があります。</p><p>例えば、上記の条件は以下を示唆します：</p><ul><li>反復内で取得されたロックは、同じ反復内で解放されなければなりません。</li><li><code>Channel</code> のようなブロッキングプリミティブを使用して反復間で通信することは不正です。</li><li>反復間で共有されていない場所にのみ書き込みを行います（ロックまたはアトミック操作が使用されていない限り）。</li><li><code>:static</code> スケジュールが使用されない限り、<a href="multi-threading.html#Base.Threads.threadid"><code>threadid()</code></a> の値は単一の反復内でも変わる可能性があります。<a href="../manual/multi-threading.html#man-task-migration"><code>Task Migration</code></a> を参照してください。</li></ul><p><strong>スケジューラ</strong></p><p>スケジューラ引数がない場合、正確なスケジューリングは指定されておらず、Julia のリリースによって異なります。現在、スケジューラが指定されていない場合は <code>:dynamic</code> が使用されます。</p><div class="admonition is-compat" id="Julia-1.5-687f0dfc972bc631"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-687f0dfc972bc631" title="Permalink"></a></header><div class="admonition-body"><p><code>schedule</code> 引数は Julia 1.5 以降で利用可能です。</p></div></div><p><strong><code>:dynamic</code> (デフォルト)</strong></p><p><code>:dynamic</code> スケジューラは、利用可能なワーカースレッドに対して反復を動的に実行します。現在の実装は、各反復の作業負荷が均一であると仮定しています。ただし、この仮定は将来的に削除される可能性があります。</p><p>このスケジューリングオプションは、基盤となる実行メカニズムへの単なるヒントです。ただし、いくつかの特性が期待できます。<code>:dynamic</code> スケジューラによって使用される <code>Task</code> の数は、利用可能なワーカースレッドの数の小さな定数倍に制限されています（<a href="multi-threading.html#Base.Threads.threadpoolsize"><code>Threads.threadpoolsize()</code></a>）。各タスクは反復空間の連続した領域を処理します。したがって、<code>@threads :dynamic for x in xs; f(x); end</code> は、<code>length(xs)</code> がワーカースレッドの数よりも大幅に大きく、<code>f(x)</code> の実行時間がタスクの生成と同期のコスト（通常は 10 マイクロ秒未満）よりも相対的に小さい場合、通常は <code>@sync for x in xs; @spawn f(x); end</code> よりも効率的です。</p><div class="admonition is-compat" id="Julia-1.8-7994ac7d9bc494ab"><header class="admonition-header">Julia 1.8<a class="admonition-anchor" href="#Julia-1.8-7994ac7d9bc494ab" title="Permalink"></a></header><div class="admonition-body"><p><code>schedule</code> 引数の <code>:dynamic</code> オプションは Julia 1.8 以降で利用可能で、デフォルトです。</p></div></div><p><strong><code>:greedy</code></strong></p><p><code>:greedy</code> スケジューラは、<a href="multi-threading.html#Base.Threads.threadpoolsize"><code>Threads.threadpoolsize()</code></a> タスクを生成し、各タスクは生成される反復値に貪欲に取り組みます。1 つのタスクが作業を終えると、次の値をイテレータから取得します。個々のタスクが行う作業は、必ずしもイテレータからの連続した値に対して行われるわけではありません。与えられたイテレータは永遠に値を生成する可能性があり、イテレータインターフェースのみが必要です（インデックス付けは不要です）。</p><p>このスケジューリングオプションは、個々の反復の作業負荷が均一でない/大きなばらつきがある場合に一般的に良い選択です。</p><div class="admonition is-compat" id="Julia-1.11-4ab74bc39567b91d"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-4ab74bc39567b91d" title="Permalink"></a></header><div class="admonition-body"><p><code>schedule</code> 引数の <code>:greedy</code> オプションは Julia 1.11 以降で利用可能です。</p></div></div><p><strong><code>:static</code></strong></p><p><code>:static</code> スケジューラは、スレッドごとに 1 つのタスクを作成し、反復を均等に分割し、各タスクを特定のスレッドに割り当てます。特に、<a href="multi-threading.html#Base.Threads.threadid"><code>threadid()</code></a> の値は 1 つの反復内で一定であることが保証されています。別の <code>@threads</code> ループ内または 1 以外のスレッドから使用する場合、<code>:static</code> を指定することはエラーです。</p><div class="admonition is-info" id="Note-2752e17eba105a96"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2752e17eba105a96" title="Permalink"></a></header><div class="admonition-body"><p><code>:static</code> スケジューリングは、Julia 1.3 より前に書かれたコードの移行をサポートするために存在します。新しく書かれたライブラリ関数では、<code>:static</code> スケジューリングは推奨されません。このオプションを使用する関数は、任意のワーカースレッドから呼び出すことができないためです。</p></div></div><p><strong>例</strong></p><p>異なるスケジューリング戦略を示すために、指定された秒数間実行される非待機のタイムループを含む次の関数 <code>busywait</code> を考えます。</p><pre><code class="language-julia-repl hljs">julia&gt; function busywait(seconds)
            tstart = time_ns()
            while (time_ns() - tstart) / 1e9 &lt; seconds
            end
        end

julia&gt; @time begin
            Threads.@spawn busywait(5)
            Threads.@threads :static for i in 1:Threads.threadpoolsize()
                busywait(1)
            end
        end
6.003001 seconds (16.33 k allocations: 899.255 KiB, 0.25% compilation time)

julia&gt; @time begin
            Threads.@spawn busywait(5)
            Threads.@threads :dynamic for i in 1:Threads.threadpoolsize()
                busywait(1)
            end
        end
2.012056 seconds (16.05 k allocations: 883.919 KiB, 0.66% compilation time)</code></pre><p><code>:dynamic</code> の例は 2 秒かかります。なぜなら、占有されていないスレッドの 1 つが 1 秒の反復を 2 回実行して for ループを完了できるからです。 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L260-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.foreach" href="#Base.Threads.foreach"><code>Base.Threads.foreach</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.foreach(f, channel::Channel;
                schedule::Threads.AbstractSchedule=Threads.FairSchedule(),
                ntasks=Threads.threadpoolsize())</code></pre><p><code>foreach(f, channel)</code>と似ていますが、<code>channel</code>の反復処理と<code>f</code>への呼び出しは、<code>Threads.@spawn</code>によって生成された<code>ntasks</code>タスクに分割されます。この関数は、内部で生成されたすべてのタスクが完了するのを待ってから戻ります。</p><p><code>schedule isa FairSchedule</code>の場合、<code>Threads.foreach</code>は、Juliaのスケジューラがスレッド間で作業項目をより自由に負荷分散できるようにタスクを生成しようとします。このアプローチは一般的にアイテムごとのオーバーヘッドが高くなりますが、他のマルチスレッドワークロードと同時に実行する場合、<code>StaticSchedule</code>よりもパフォーマンスが向上する可能性があります。</p><p><code>schedule isa StaticSchedule</code>の場合、<code>Threads.foreach</code>は、<code>FairSchedule</code>よりもアイテムごとのオーバーヘッドが低くなるようにタスクを生成しますが、負荷分散にはあまり適していません。このアプローチは、細かい粒度の均一なワークロードにより適している可能性がありますが、他のマルチスレッドワークロードと同時に実行する場合、<code>FairSchedule</code>よりもパフォーマンスが低下する可能性があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n = 20

julia&gt; c = Channel{Int}(ch -&gt; foreach(i -&gt; put!(ch, i), 1:n), 1)

julia&gt; d = Channel{Int}(n) do ch
           f = i -&gt; put!(ch, i^2)
           Threads.foreach(f, c)
       end

julia&gt; collect(d)
collect(d) = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]</code></pre><div class="admonition is-compat" id="Julia-1.6-7215191bbae7db1e"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-7215191bbae7db1e" title="Permalink"></a></header><div class="admonition-body"><p>この関数はJulia 1.6以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threads_overloads.jl#L3-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.@spawn" href="#Base.Threads.@spawn"><code>Base.Threads.@spawn</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.@spawn [:default|:interactive] expr</code></pre><p><a href="parallel.html#Core.Task"><code>Task</code></a> を作成し、指定されたスレッドプール（指定されていない場合は <code>:default</code>）の任意の利用可能なスレッドで実行するように <a href="parallel.html#Base.schedule"><code>schedule</code></a> します。タスクは、利用可能なスレッドが見つかると、そのスレッドに割り当てられます。タスクが完了するのを待つには、このマクロの結果に対して <a href="parallel.html#Base.wait"><code>wait</code></a> を呼び出すか、<a href="parallel.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> を呼び出して待機し、その後戻り値を取得します。</p><p>値は <code>$</code> を介して <code>@spawn</code> に埋め込むことができ、これにより値が構築された基盤となるクロージャに直接コピーされます。これにより、変数の<em>値</em>を挿入でき、現在のタスク内での変数の値の変更から非同期コードを隔離できます。</p><div class="admonition is-info" id="Note-e786c1fe8959e2c1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e786c1fe8959e2c1" title="Permalink"></a></header><div class="admonition-body"><p>タスクが実行されるスレッドは、タスクが中断されると変更される可能性があるため、<code>threadid()</code> はタスクに対して定数として扱うべきではありません。詳細な重要な注意事項については、<a href="../manual/multi-threading.html#man-task-migration"><code>Task Migration</code></a> およびより広範な <a href="../manual/multi-threading.html#man-multithreading">multi-threading</a> マニュアルを参照してください。また、<a href="../manual/multi-threading.html#man-threadpools">threadpools</a> に関する章も参照してください。</p></div></div><div class="admonition is-compat" id="Julia-1.3-249f08e258804c9b"><header class="admonition-header">Julia 1.3<a class="admonition-anchor" href="#Julia-1.3-249f08e258804c9b" title="Permalink"></a></header><div class="admonition-body"><p>このマクロは Julia 1.3 以降で利用可能です。</p></div></div><div class="admonition is-compat" id="Julia-1.4-1f0367ae1f8d910d"><header class="admonition-header">Julia 1.4<a class="admonition-anchor" href="#Julia-1.4-1f0367ae1f8d910d" title="Permalink"></a></header><div class="admonition-body"><p><code>$</code> を介して値を埋め込むことは Julia 1.4 以降で利用可能です。</p></div></div><div class="admonition is-compat" id="Julia-1.9-6cfc801018ab8544"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-6cfc801018ab8544" title="Permalink"></a></header><div class="admonition-body"><p>スレッドプールは Julia 1.9 以降で指定できます。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t() = println(&quot;Hello from &quot;, Threads.threadid());

julia&gt; tasks = fetch.([Threads.@spawn t() for i in 1:4]);
Hello from 1
Hello from 1
Hello from 3
Hello from 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L419-L458">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.threadid" href="#Base.Threads.threadid"><code>Base.Threads.threadid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.threadid() -&gt; Int</code></pre><p>現在の実行スレッドのID番号を取得します。マスタースレッドのIDは <code>1</code> です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Threads.threadid()
1

julia&gt; Threads.@threads for i in 1:4
          println(Threads.threadid())
       end
4
2
5
4</code></pre><p>!!! 注     タスクが実行されるスレッドは、タスクがYieldすると変更される可能性があり、これを <a href="../manual/multi-threading.html#man-task-migration"><code>Task Migration</code></a> と呼びます。このため、ほとんどの場合、<code>threadid()</code> を使用してバッファや状態を持つオブジェクトのベクターにインデックスを付けることは安全ではありません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.maxthreadid" href="#Base.Threads.maxthreadid"><code>Base.Threads.maxthreadid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.maxthreadid() -&gt; Int</code></pre><p>Juliaプロセスで利用可能なスレッドの数（すべてのスレッドプールを通じて）の下限を取得します。これはアトミック取得セマンティクスを持ちます。結果は常に<a href="multi-threading.html#Base.Threads.threadid"><code>threadid()</code></a>および<code>threadid(task)</code>（<code>maxthreadid</code>を呼び出す前に観察できたタスクに対して）以上になります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.nthreads" href="#Base.Threads.nthreads"><code>Base.Threads.nthreads</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.nthreads(:default | :interactive) -&gt; Int</code></pre><p>指定されたスレッドプール内の現在のスレッド数を取得します。<code>:interactive</code> のスレッドは ID 番号 <code>1:nthreads(:interactive)</code> を持ち、<code>:default</code> のスレッドは <code>nthreads(:interactive) .+ (1:nthreads(:default))</code> の ID 番号を持ちます。</p><p><code>BLAS.get_num_threads</code> および <code>BLAS.set_num_threads</code> は <a href="../stdlib/LinearAlgebra.html#man-linalg"><code>LinearAlgebra</code></a> 標準ライブラリに、<code>nprocs()</code> は <a href="../stdlib/Distributed.html#man-distributed"><code>Distributed</code></a> 標準ライブラリおよび <a href="multi-threading.html#Base.Threads.maxthreadid"><code>Threads.maxthreadid()</code></a> にあります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L44-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.threadpool" href="#Base.Threads.threadpool"><code>Base.Threads.threadpool</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.threadpool(tid = threadid()) -&gt; Symbol</code></pre><p>指定されたスレッドのスレッドプールを返します。<code>:default</code>、<code>:interactive</code>、または<code>:foreign</code>のいずれかです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.nthreadpools" href="#Base.Threads.nthreadpools"><code>Base.Threads.nthreadpools</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.nthreadpools() -&gt; Int</code></pre><p>現在構成されているスレッドプールの数を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.threadpoolsize" href="#Base.Threads.threadpoolsize"><code>Base.Threads.threadpoolsize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.threadpoolsize(pool::Symbol = :default) -&gt; Int</code></pre><p>デフォルトのスレッドプール（または指定されたスレッドプール）で利用可能なスレッドの数を取得します。</p><p>関連情報: <a href="../stdlib/LinearAlgebra.html#man-linalg"><code>LinearAlgebra</code></a> 標準ライブラリの <code>BLAS.get_num_threads</code> および <code>BLAS.set_num_threads</code>、および <a href="../stdlib/Distributed.html#man-distributed"><code>Distributed</code></a> 標準ライブラリの <code>nprocs()</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L103-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.ngcthreads" href="#Base.Threads.ngcthreads"><code>Base.Threads.ngcthreads</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.ngcthreads() -&gt; Int</code></pre><p>現在構成されているGCスレッドの数を返します。これには、マークスレッドと同時スイープスレッドの両方が含まれます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadingconstructs.jl#L140-L145">source</a></section></article><p>次も参照してください <a href="../manual/multi-threading.html#man-multithreading">Multi-Threading</a>。</p><h2 id="Atomic-operations"><a class="docs-heading-anchor" href="#Atomic-operations">Atomic operations</a><a id="Atomic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="atomic" href="#atomic"><code>atomic</code></a> — <span class="docstring-category">Keyword</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Unsafe pointer operations are compatible with loading and storing pointers declared with <code>_Atomic</code> and <code>std::atomic</code> type in C11 and C++23 respectively. An error may be thrown if there is not support for atomically loading the Julia type <code>T</code>.</p><p>See also: <a href="c.html#Base.unsafe_load"><code>unsafe_load</code></a>, <a href="c.html#Base.unsafe_modify!"><code>unsafe_modify!</code></a>, <a href="c.html#Base.unsafe_replace!"><code>unsafe_replace!</code></a>, <a href="c.html#Base.unsafe_store!"><code>unsafe_store!</code></a>, <a href="c.html#Base.unsafe_swap!"><code>unsafe_swap!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/docs/basedocs.jl#L3617-L3623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomic" href="#Base.@atomic"><code>Base.@atomic</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomic var
@atomic order ex</code></pre><p><code>var</code> または <code>ex</code> を原子的に実行されるものとしてマークします。<code>order</code> が指定されていない場合、デフォルトは :sequentially_consistent です。</p><pre><code class="nohighlight hljs">@atomic a.b.x = new
@atomic a.b.x += addend
@atomic :release a.b.x = new
@atomic :acquire_release a.b.x += addend</code></pre><p>右側で表現されたストア操作を原子的に実行し、新しい値を返します。</p><p><code>=</code> を使用する場合、この操作は <code>setproperty!(a.b, :x, new)</code> 呼び出しに変換されます。演算子を使用する場合も、この操作は <code>modifyproperty!(a.b, :x, +, addend)[2]</code> 呼び出しに変換されます。</p><pre><code class="nohighlight hljs">@atomic a.b.x max arg2
@atomic a.b.x + arg2
@atomic max(a.b.x, arg2)
@atomic :acquire_release max(a.b.x, arg2)
@atomic :acquire_release a.b.x + arg2
@atomic :acquire_release a.b.x max arg2</code></pre><p>右側で表現された二項操作を原子的に実行します。結果を最初の引数のフィールドに格納し、値 <code>(old, new)</code> を返します。</p><p>この操作は <code>modifyproperty!(a.b, :x, func, arg2)</code> 呼び出しに変換されます。</p><p>詳細については、マニュアルの <a href="math.html#Base.:--Tuple{Any, Any}">Per-field atomics</a> セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Atomic{T}; @atomic x::T; end

julia&gt; a = Atomic(1)
Atomic{Int64}(1)

julia&gt; @atomic a.x # a のフィールド x を取得し、順序の一貫性を持つ
1

julia&gt; @atomic :sequentially_consistent a.x = 2 # a のフィールド x を設定し、順序の一貫性を持つ
2

julia&gt; @atomic a.x += 1 # a のフィールド x をインクリメントし、順序の一貫性を持つ
3

julia&gt; @atomic a.x + 1 # a のフィールド x をインクリメントし、順序の一貫性を持つ
3 =&gt; 4

julia&gt; @atomic a.x # a のフィールド x を取得し、順序の一貫性を持つ
4

julia&gt; @atomic max(a.x, 10) # a のフィールド x を最大値に変更し、順序の一貫性を持つ
4 =&gt; 10

julia&gt; @atomic a.x max 5 # 再度 a のフィールド x を最大値に変更し、順序の一貫性を持つ
10 =&gt; 10</code></pre><div class="admonition is-compat" id="Julia-1.7-369e72f03130f8f2"><header class="admonition-header">Julia 1.7<a class="admonition-anchor" href="#Julia-1.7-369e72f03130f8f2" title="Permalink"></a></header><div class="admonition-body"><p>この機能は少なくとも Julia 1.7 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/expr.jl#L1123-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomicswap" href="#Base.@atomicswap"><code>Base.@atomicswap</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomicswap a.b.x = new
@atomicswap :sequentially_consistent a.b.x = new</code></pre><p><code>new</code>を<code>a.b.x</code>に格納し、<code>a.b.x</code>の古い値を返します。</p><p>この操作は<code>swapproperty!(a.b, :x, new)</code>呼び出しに変換されます。</p><p>詳細については、マニュアルの<a href="../manual/multi-threading.html#man-atomics">Per-field atomics</a>セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Atomic{T}; @atomic x::T; end

julia&gt; a = Atomic(1)
Atomic{Int64}(1)

julia&gt; @atomicswap a.x = 2+2 # aのフィールドxを4に置き換え、逐次的整合性を持つ
1

julia&gt; @atomic a.x # aのフィールドxを取得し、逐次的整合性を持つ
4</code></pre><div class="admonition is-compat" id="Julia-1.7-61471fbac9f6db55"><header class="admonition-header">Julia 1.7<a class="admonition-anchor" href="#Julia-1.7-61471fbac9f6db55" title="Permalink"></a></header><div class="admonition-body"><p>この機能は少なくともJulia 1.7が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/expr.jl#L1247-L1273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomicreplace" href="#Base.@atomicreplace"><code>Base.@atomicreplace</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomicreplace a.b.x 期待される =&gt; 希望する
@atomicreplace :sequentially_consistent a.b.x 期待される =&gt; 希望する
@atomicreplace :sequentially_consistent :monotonic a.b.x 期待される =&gt; 希望する</code></pre><p>ペアで表現された条件付き置換を原子的に実行し、値 <code>(old, success::Bool)</code> を返します。ここで <code>success</code> は置換が完了したかどうかを示します。</p><p>この操作は <code>replaceproperty!(a.b, :x, 期待される, 希望する)</code> の呼び出しに相当します。</p><p>詳細についてはマニュアルの <a href="../manual/multi-threading.html#man-atomics">Per-field atomics</a> セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Atomic{T}; @atomic x::T; end

julia&gt; a = Atomic(1)
Atomic{Int64}(1)

julia&gt; @atomicreplace a.x 1 =&gt; 2 # aのフィールドxを1であれば2に置換し、逐次的整合性を持つ
(old = 1, success = true)

julia&gt; @atomic a.x # aのフィールドxを取得し、逐次的整合性を持つ
2

julia&gt; @atomicreplace a.x 1 =&gt; 2 # aのフィールドxを1であれば2に置換し、逐次的整合性を持つ
(old = 2, success = false)

julia&gt; xchg = 2 =&gt; 0; # aのフィールドxを2であれば0に置換し、逐次的整合性を持つ

julia&gt; @atomicreplace a.x xchg
(old = 2, success = true)

julia&gt; @atomic a.x # aのフィールドxを取得し、逐次的整合性を持つ
0</code></pre><div class="admonition is-compat" id="Julia-1.7-61471fbac9f6db55"><header class="admonition-header">Julia 1.7<a class="admonition-anchor" href="#Julia-1.7-61471fbac9f6db55" title="Permalink"></a></header><div class="admonition-body"><p>この機能は少なくともJulia 1.7が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/expr.jl#L1291-L1331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomiconce" href="#Base.@atomiconce"><code>Base.@atomiconce</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomiconce a.b.x = value
@atomiconce :sequentially_consistent a.b.x = value
@atomiconce :sequentially_consistent :monotonic a.b.x = value</code></pre><p>値が以前に未設定であった場合に、条件付きで値を原子的に割り当て、<code>success::Bool</code>を返します。ここで、<code>success</code>は割り当てが完了したかどうかを示します。</p><p>この操作は<code>setpropertyonce!(a.b, :x, value)</code>呼び出しに変換されます。</p><p>詳細については、マニュアルの<a href="../manual/multi-threading.html#man-atomics">Per-field atomics</a>セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct AtomicOnce
           @atomic x
           AtomicOnce() = new()
       end

julia&gt; a = AtomicOnce()
AtomicOnce(#undef)

julia&gt; @atomiconce a.x = 1 # aのフィールドxを1に設定します。未設定の場合、順次一貫性を持って
true

julia&gt; @atomic a.x # aのフィールドxを取得します。順次一貫性を持って
1

julia&gt; @atomiconce a.x = 1 # aのフィールドxを1に設定します。未設定の場合、順次一貫性を持って
false</code></pre><div class="admonition is-compat" id="Julia-1.11-7777c29f191fb86e"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-7777c29f191fb86e" title="Permalink"></a></header><div class="admonition-body"><p>この機能は少なくともJulia 1.11が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/expr.jl#L1357-L1392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.AtomicMemory" href="#Core.AtomicMemory"><code>Core.AtomicMemory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AtomicMemory{T} == GenericMemory{:atomic, T, Core.CPU}</code></pre><p>固定サイズの <a href="arrays.html#Base.DenseVector"><code>DenseVector{T}</code></a>。その要素へのアクセスは原子的に行われます（<code>:monotonic</code> 順序で）。要素の設定は <code>@atomic</code> マクロを使用し、明示的に順序を指定する必要があります。</p><div class="admonition is-warning" id="Warning-b6803105e5b03344"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-b6803105e5b03344" title="Permalink"></a></header><div class="admonition-body"><p>各要素はアクセス時に独立して原子的であり、非原子的に設定することはできません。現在、<code>@atomic</code> マクロと高レベルインターフェースは完成していませんが、将来の実装のための基本的な構成要素として、内部のイントリンシック <code>Core.memoryrefget</code>、<code>Core.memoryrefset!</code>、<code>Core.memoryref_isassigned</code>、<code>Core.memoryrefswap!</code>、<code>Core.memoryrefmodify!</code>、および <code>Core.memoryrefreplace!</code> があります。</p></div></div><p>詳細については、<a href="../manual/multi-threading.html#man-atomic-operations">Atomic Operations</a>を参照してください。</p><div class="admonition is-compat" id="Julia-1.11-a4955f8c12375439"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-a4955f8c12375439" title="Permalink"></a></header><div class="admonition-body"><p>この型は Julia 1.11 以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/genericmemory.jl#L37-L55">source</a></section></article><p><code>unsafe</code> 関数のセットには、これらの原子操作の C/C++ 互換バージョンを選択するオプションのメモリ順序パラメータもあります。このパラメータが指定されている場合、次のようになります： <a href="c.html#Base.unsafe_load"><code>unsafe_load</code></a>、<a href="c.html#Base.unsafe_store!"><code>unsafe_store!</code></a>、<a href="c.html#Base.unsafe_swap!"><code>unsafe_swap!</code></a>、<a href="c.html#Base.unsafe_replace!"><code>unsafe_replace!</code></a>、および <a href="c.html#Base.unsafe_modify!"><code>unsafe_modify!</code></a>。</p><div class="admonition is-warning" id="Warning-17984a4113806c56"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-17984a4113806c56" title="Permalink"></a></header><div class="admonition-body"><p>以下のAPIは非推奨ですが、サポートは数回のリリースにわたって残る可能性があります。</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.Atomic" href="#Base.Threads.Atomic"><code>Base.Threads.Atomic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.Atomic{T}</code></pre><p>型 <code>T</code> のオブジェクトへの参照を保持し、それが原子的に、すなわちスレッドセーフな方法でのみアクセスされることを保証します。</p><p>原子的に使用できるのは、特定の「単純な」型のみで、すなわち原始的なブール型、整数型、および浮動小数点型です。これらは <code>Bool</code>、<code>Int8</code>...<code>Int128</code>、<code>UInt8</code>...<code>UInt128</code>、および <code>Float16</code>...<code>Float64</code> です。</p><p>新しい原子オブジェクトは非原子的な値から作成できます。指定がない場合、原子オブジェクトはゼロで初期化されます。</p><p>原子オブジェクトには <code>[]</code> 表記を使用してアクセスできます：</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; x[] = 1
1

julia&gt; x[]
1</code></pre><p>原子操作は <code>atomic_</code> プレフィックスを使用し、例えば <a href="multi-threading.html#Base.Threads.atomic_add!"><code>atomic_add!</code></a>、<a href="multi-threading.html#Base.Threads.atomic_xchg!"><code>atomic_xchg!</code></a> などがあります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L45-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_cas!" href="#Base.Threads.atomic_cas!"><code>Base.Threads.atomic_cas!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T</code></pre><p>原子比較と設定 <code>x</code></p><p><code>x</code> の値を <code>cmp</code> と原子比較します。等しい場合、<code>newval</code> を <code>x</code> に書き込みます。そうでない場合、<code>x</code> は変更されずにそのままです。<code>x</code> の古い値を返します。返された値を <code>cmp</code> と比較することで（<code>===</code> を介して）、<code>x</code> が変更されたかどうか、そして現在 <code>newval</code> の新しい値を保持しているかを知ることができます。</p><p>詳細については、LLVM の <code>cmpxchg</code> 命令を参照してください。</p><p>この関数はトランザクションセマンティクスを実装するために使用できます。トランザクションの前に、<code>x</code> の値を記録します。トランザクションの後、<code>x</code> がその間に変更されていない場合のみ新しい値が保存されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_cas!(x, 4, 2);

julia&gt; x
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_cas!(x, 3, 2);

julia&gt; x
Base.Threads.Atomic{Int64}(2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L90-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_xchg!" href="#Base.Threads.atomic_xchg!"><code>Base.Threads.atomic_xchg!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T</code></pre><p><code>x</code>の値を原子的に交換します。</p><p><code>x</code>の値を<code>newval</code>と原子的に交換します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw xchg</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_xchg!(x, 2)
3

julia&gt; x[]
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L125-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_add!" href="#Base.Threads.atomic_add!"><code>Base.Threads.atomic_add!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_add!(x::Atomic{T}, val::T) where T &lt;: ArithmeticTypes</code></pre><p><code>val</code>を<code>x</code>に原子的に加算します。</p><p><code>x[] += val</code>を原子的に実行します。<strong>古い</strong>値を返します。<code>Atomic{Bool}</code>には定義されていません。</p><p>詳細については、LLVMの<code>atomicrmw add</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_add!(x, 2)
3

julia&gt; x[]
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L149-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_sub!" href="#Base.Threads.atomic_sub!"><code>Base.Threads.atomic_sub!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_sub!(x::Atomic{T}, val::T) where T &lt;: ArithmeticTypes</code></pre><p><code>val</code>を<code>x</code>から原子的に減算します。</p><p><code>x[] -= val</code>を原子的に実行します。<strong>古い</strong>値を返します。<code>Atomic{Bool}</code>には定義されていません。</p><p>詳細については、LLVMの<code>atomicrmw sub</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_sub!(x, 2)
3

julia&gt; x[]
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L173-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_and!" href="#Base.Threads.atomic_and!"><code>Base.Threads.atomic_and!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_and!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>を<code>val</code>と原子的にビット単位でANDします。</p><p>原子的に<code>x[] &amp;= val</code>を実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw and</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_and!(x, 2)
3

julia&gt; x[]
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L197-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_nand!" href="#Base.Threads.atomic_nand!"><code>Base.Threads.atomic_nand!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_nand!(x::Atomic{T}, val::T) where T</code></pre><p>原子的に <code>x</code> と <code>val</code> のビット単位の NAND（非論理積）を行います。</p><p><code>x[] = ~(x[] &amp; val)</code> を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの <code>atomicrmw nand</code> 命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_nand!(x, 2)
3

julia&gt; x[]
-3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L220-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_or!" href="#Base.Threads.atomic_or!"><code>Base.Threads.atomic_or!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_or!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>を<code>val</code>と原子的にビット単位で論理和します。</p><p><code>x[] |= val</code>を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw or</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia&gt; Threads.atomic_or!(x, 7)
5

julia&gt; x[]
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L243-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_xor!" href="#Base.Threads.atomic_xor!"><code>Base.Threads.atomic_xor!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_xor!(x::Atomic{T}, val::T) where T</code></pre><p>原子的に <code>x</code> と <code>val</code> のビット単位の排他的論理和 (XOR) を計算します。</p><p><code>x[] $= val</code> を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの <code>atomicrmw xor</code> 命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia&gt; Threads.atomic_xor!(x, 7)
5

julia&gt; x[]
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L266-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_max!" href="#Base.Threads.atomic_max!"><code>Base.Threads.atomic_max!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_max!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>と<code>val</code>の最大値を原子的に<code>x</code>に格納します。</p><p>原子的に<code>x[] = max(x[], val)</code>を実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw max</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia&gt; Threads.atomic_max!(x, 7)
5

julia&gt; x[]
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L289-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_min!" href="#Base.Threads.atomic_min!"><code>Base.Threads.atomic_min!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_min!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>と<code>val</code>の最小値を原子的に<code>x</code>に格納します。</p><p><code>x[] = min(x[], val)</code>を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw min</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(7)
Base.Threads.Atomic{Int64}(7)

julia&gt; Threads.atomic_min!(x, 5)
7

julia&gt; x[]
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L312-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_fence" href="#Base.Threads.atomic_fence"><code>Base.Threads.atomic_fence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_fence()</code></pre><p>逐次一致性メモリフェンスを挿入します</p><p>逐次一致性の順序セマンティクスを持つメモリフェンスを挿入します。これは、取得/解放の順序が不十分なアルゴリズムがあるため、必要です。</p><p>これは非常に高価な操作である可能性があります。Juliaの他のすべての原子操作にはすでに取得/解放のセマンティクスがあるため、明示的なフェンスはほとんどの場合必要ありません。</p><p>詳細については、LLVMの<code>fence</code>命令を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/atomics.jl#L450-L464">source</a></section></article><h2 id="ccall-using-a-libuv-threadpool-(Experimental)"><a class="docs-heading-anchor" href="#ccall-using-a-libuv-threadpool-(Experimental)">ccall using a libuv threadpool (Experimental)</a><a id="ccall-using-a-libuv-threadpool-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#ccall-using-a-libuv-threadpool-(Experimental)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@threadcall" href="#Base.@threadcall"><code>Base.@threadcall</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)</code></pre><p><code>@threadcall</code>マクロは<a href="c.html#ccall"><code>ccall</code></a>と同じ方法で呼び出されますが、異なるスレッドで作業を行います。これは、現在の<code>julia</code>スレッドをブロックさせることなく、ブロッキングC関数を呼び出したい場合に便利です。並行性はlibuvスレッドプールのサイズによって制限され、デフォルトでは4スレッドですが、<code>UV_THREADPOOL_SIZE</code>環境変数を設定し、<code>julia</code>プロセスを再起動することで増やすことができます。</p><p>呼び出される関数は、決してJuliaにコールバックしてはいけないことに注意してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/threadcall.jl#L8-L19">source</a></section></article><h2 id="Low-level-synchronization-primitives"><a class="docs-heading-anchor" href="#Low-level-synchronization-primitives">Low-level synchronization primitives</a><a id="Low-level-synchronization-primitives-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-synchronization-primitives" title="Permalink"></a></h2><p>これらのビルディングブロックは、通常の同期オブジェクトを作成するために使用されます。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.SpinLock" href="#Base.Threads.SpinLock"><code>Base.Threads.SpinLock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpinLock()</code></pre><p>再入不可のテスト・アンド・テスト・アンド・セットスピンロックを作成します。再帰的な使用はデッドロックを引き起こします。この種のロックは、実行にかかる時間が短く、ブロックしないコードの周りでのみ使用するべきです（例：I/Oを実行する）。一般的には、<a href="parallel.html#Base.ReentrantLock"><code>ReentrantLock</code></a>を代わりに使用するべきです。</p><p>各<a href="parallel.html#Base.lock"><code>lock</code></a>は<a href="parallel.html#Base.unlock"><code>unlock</code></a>と対になっている必要があります。もし<a href="parallel.html#Base.islocked"><code>!islocked(lck::SpinLock)</code></a>が成り立つ場合、<a href="parallel.html#Base.trylock"><code>trylock(lck)</code></a>は、他のタスクが「同時に」ロックを保持しようとしていない限り成功します。</p><p>テスト・アンド・テスト・アンド・セットスピンロックは、約30の競合スレッドまでが最も速いです。それ以上の競合がある場合は、異なる同期アプローチを検討する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/locks-mt.jl#L14-L30">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="parallel.html">« Tasks</a><a class="docs-footer-nextpage" href="scopedvalues.html">Scoped Values »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 20 May 2025 05:07">Tuesday 20 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
