<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multi-Threading · The Julia Language</title><meta name="title" content="Multi-Threading · The Julia Language"/><meta property="og:title" content="Multi-Threading · The Julia Language"/><meta property="twitter:title" content="Multi-Threading · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/memory-management.html">Memory Management and Garbage Collection</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li><li><a class="tocitem" href="../manual/worldage.html">The World Age mechanism</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Essentials</a></li><li><a class="tocitem" href="collections.html">Collections and Data Structures</a></li><li><a class="tocitem" href="math.html">Mathematics</a></li><li><a class="tocitem" href="numbers.html">Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="arrays.html">Arrays</a></li><li><a class="tocitem" href="parallel.html">Tasks</a></li><li class="is-active"><a class="tocitem" href="multi-threading.html">Multi-Threading</a><ul class="internal"><li><a class="tocitem" href="#Atomic-operations"><span>Atomic operations</span></a></li><li><a class="tocitem" href="#ccall-using-a-libuv-threadpool-(Experimental)"><span>ccall using a libuv threadpool (Experimental)</span></a></li><li><a class="tocitem" href="#Low-level-synchronization-primitives"><span>Low-level synchronization primitives</span></a></li><li><a class="tocitem" href="#Task-metrics-(Experimental)"><span>Task metrics (Experimental)</span></a></li></ul></li><li><a class="tocitem" href="scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="constants.html">Constants</a></li><li><a class="tocitem" href="file.html">Filesystem</a></li><li><a class="tocitem" href="io-network.html">I/O and Network</a></li><li><a class="tocitem" href="punctuation.html">Punctuation</a></li><li><a class="tocitem" href="sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="c.html">C Interface</a></li><li><a class="tocitem" href="libc.html">C Standard Library</a></li><li><a class="tocitem" href="stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/JuliaSyntaxHighlighting.html">Julia Syntax Highlighting</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="multi-threading.html">Multi-Threading</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="multi-threading.html">Multi-Threading</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/multi-threading.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="lib-multithreading"><a class="docs-heading-anchor" href="#lib-multithreading">Multi-Threading</a><a id="lib-multithreading-1"></a><a class="docs-heading-anchor-permalink" href="#lib-multithreading" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.@threads" href="#Base.Threads.@threads"><code>Base.Threads.@threads</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.@threads [schedule] for ... end</code></pre><p><code>for</code> ループを並列に実行するためのマクロです。反復空間は粗粒度のタスクに分配されます。このポリシーは <code>schedule</code> 引数によって指定できます。ループの実行は、すべての反復の評価が完了するのを待ちます。</p><p><code>@threads</code> によって生成されたタスクは <code>:default</code> スレッドプールでスケジュールされます。これは、<code>@threads</code> がメインスレッドまたはインタラクティブプールのタスクから呼び出された場合でも、<code>:interactive</code> スレッドプールのスレッドを使用しないことを意味します。<code>:default</code> スレッドプールは、計算集約型の並列ワークロードを対象としています。</p><p>関連情報: <a href="multi-threading.html#Base.Threads.@spawn"><code>@spawn</code></a> および <a href="../stdlib/Distributed.html#man-distributed"><code>Distributed</code></a> の <code>pmap</code>。スレッドプールに関する詳細は、<a href="../manual/multi-threading.html#man-threadpools">スレッドプール</a> の章を参照してください。</p><p><strong>Extended help</strong></p><p><strong>セマンティクス</strong></p><p>スケジューリングオプションによってより強力な保証が指定されない限り、<code>@threads</code> マクロによって実行されるループは以下のセマンティクスを持ちます。</p><p><code>@threads</code> マクロは、ループ本体を不特定の順序で、かつ潜在的に同時に実行します。タスクとワーカースレッドの正確な割り当ては指定されません。割り当ては各実行で異なる場合があります。ループ本体のコード（それから遷移的に呼び出されるコードを含む）は、タスクへの反復の分配や、それらが実行されるワーカースレッドについての仮定をしてはいけません。各反復のループ本体は、他の反復に依存せずに前進できる必要があり、データ競合から解放されている必要があります。そのため、反復間での無効な同期はデッドロックを引き起こす可能性があり、同期されていないメモリアクセスは未定義の動作を引き起こす可能性があります。</p><p>例えば、上記の条件は以下を示唆します：</p><ul><li>反復で取得したロックは、同じ反復内で解放されなければなりません。</li><li><code>Channel</code> のようなブロッキングプリミティブを使用して反復間で通信することは不正です。</li><li>反復間で共有されていない場所にのみ書き込みます（ロックまたは原子操作が使用されていない限り）。</li><li><code>:static</code> スケジュールが使用されない限り、<a href="multi-threading.html#Base.Threads.threadid"><code>threadid()</code></a> の値は単一の反復内でも変わる可能性があります。<a href="../manual/multi-threading.html#man-task-migration"><code>Task Migration</code></a> を参照してください。</li></ul><p><strong>スケジューラ</strong></p><p>スケジューラ引数がない場合、正確なスケジューリングは未指定で、Julia のリリースによって異なります。現在、スケジューラが指定されていない場合は <code>:dynamic</code> が使用されます。</p><div class="admonition is-compat" id="Julia-1.5-67a2f45346b492db"><header class="admonition-header">Julia 1.5<a class="admonition-anchor" href="#Julia-1.5-67a2f45346b492db" title="Permalink"></a></header><div class="admonition-body"><p><code>schedule</code> 引数は Julia 1.5 から利用可能です。</p></div></div><p><strong><code>:dynamic</code> (デフォルト)</strong></p><p><code>:dynamic</code> スケジューラは、利用可能なワーカースレッドに対して反復を動的に実行します。現在の実装は、各反復のワークロードが均一であると仮定しています。ただし、この仮定は将来的に削除される可能性があります。</p><p>このスケジューリングオプションは、基盤となる実行メカニズムへの単なるヒントです。ただし、いくつかの特性が期待できます。<code>:dynamic</code> スケジューラによって使用される <code>Task</code> の数は、利用可能なワーカースレッドの数の小さな定数倍に制限されています（<a href="multi-threading.html#Base.Threads.threadpoolsize"><code>Threads.threadpoolsize()</code></a>）。各タスクは反復空間の連続した領域を処理します。したがって、<code>@threads :dynamic for x in xs; f(x); end</code> は、<code>length(xs)</code> がワーカースレッドの数よりも大幅に大きく、<code>f(x)</code> の実行時間がタスクの生成と同期のコスト（通常は 10 マイクロ秒未満）よりも相対的に小さい場合、通常は <code>@sync for x in xs; @spawn f(x); end</code> よりも効率的です。</p><div class="admonition is-compat" id="Julia-1.8-d26c1f319de49a50"><header class="admonition-header">Julia 1.8<a class="admonition-anchor" href="#Julia-1.8-d26c1f319de49a50" title="Permalink"></a></header><div class="admonition-body"><p><code>schedule</code> 引数の <code>:dynamic</code> オプションは Julia 1.8 から利用可能で、デフォルトです。</p></div></div><p><strong><code>:greedy</code></strong></p><p><code>:greedy</code> スケジューラは、最大で <a href="multi-threading.html#Base.Threads.threadpoolsize"><code>Threads.threadpoolsize()</code></a> タスクを生成し、生成される値に対して貪欲に作業を行います。1 つのタスクが作業を終えると、次の値をイテレータから取得します。個々のタスクが行う作業は、イテレータからの連続した値である必要はありません。与えられたイテレータは永遠に値を生成する可能性があり、イテレータインターフェースのみが必要です（インデックス付けは不要です）。</p><p>このスケジューリングオプションは、個々の反復のワークロードが均一でない/大きなばらつきがある場合に一般的に良い選択です。</p><div class="admonition is-compat" id="Julia-1.11-781090dfb6bd3f7c"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-781090dfb6bd3f7c" title="Permalink"></a></header><div class="admonition-body"><p><code>schedule</code> 引数の <code>:greedy</code> オプションは Julia 1.11 から利用可能です。</p></div></div><p><strong><code>:static</code></strong></p><p><code>:static</code> スケジューラは、スレッドごとに 1 つのタスクを作成し、反復を均等に分配し、各タスクを特定のスレッドに割り当てます。特に、<a href="multi-threading.html#Base.Threads.threadid"><code>threadid()</code></a> の値は、1 つの反復内で一定であることが保証されています。別の <code>@threads</code> ループ内または 1 以外のスレッドから使用する場合、<code>:static</code> を指定することはエラーです。</p><div class="admonition is-info" id="Note-2752e17eba105a96"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-2752e17eba105a96" title="Permalink"></a></header><div class="admonition-body"><p><code>:static</code> スケジューリングは、Julia 1.3 より前に書かれたコードの移行をサポートするために存在します。新しく書かれたライブラリ関数では、<code>:static</code> スケジューリングは推奨されません。このオプションを使用する関数は、任意のワーカースレッドから呼び出すことができないためです。</p></div></div><p><strong>例</strong></p><p>異なるスケジューリング戦略を示すために、指定された秒数間実行される非待機のタイムループを含む次の関数 <code>busywait</code> を考えます。</p><pre><code class="language-julia-repl hljs">julia&gt; function busywait(seconds)
            tstart = time_ns()
            while (time_ns() - tstart) / 1e9 &lt; seconds
            end
        end

julia&gt; @time begin
            Threads.@spawn busywait(5)
            Threads.@threads :static for i in 1:Threads.threadpoolsize()
                busywait(1)
            end
        end
6.003001 seconds (16.33 k allocations: 899.255 KiB, 0.25% compilation time)

julia&gt; @time begin
            Threads.@spawn busywait(5)
            Threads.@threads :dynamic for i in 1:Threads.threadpoolsize()
                busywait(1)
            end
        end
2.012056 seconds (16.05 k allocations: 883.919 KiB, 0.66% compilation time)</code></pre><p><code>:dynamic</code> の例は 2 秒かかります。なぜなら、非占有のスレッドの 1 つが 1 秒の反復を 2 回実行して for ループを完了できるからです。 ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L283-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.foreach" href="#Base.Threads.foreach"><code>Base.Threads.foreach</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.foreach(f, channel::Channel;
                schedule::Threads.AbstractSchedule=Threads.FairSchedule(),
                ntasks=Threads.threadpoolsize())</code></pre><p><code>foreach(f, channel)</code>と似ていますが、<code>channel</code>の反復処理と<code>f</code>への呼び出しは、<code>Threads.@spawn</code>によって生成された<code>ntasks</code>タスクに分割されます。この関数は、内部で生成されたすべてのタスクが完了するのを待ってから戻ります。</p><p><code>schedule isa FairSchedule</code>の場合、<code>Threads.foreach</code>は、Juliaのスケジューラがスレッド間で作業項目をより自由にロードバランスできるようにタスクを生成しようとします。このアプローチは一般的にアイテムごとのオーバーヘッドが高くなりますが、他のマルチスレッドワークロードと同時に実行する場合、<code>StaticSchedule</code>よりもパフォーマンスが向上する可能性があります。</p><p><code>schedule isa StaticSchedule</code>の場合、<code>Threads.foreach</code>は、<code>FairSchedule</code>よりもアイテムごとのオーバーヘッドが低くなるようにタスクを生成しますが、ロードバランスにはあまり適していません。このアプローチは、細かく均一なワークロードにより適している可能性がありますが、他のマルチスレッドワークロードと同時に実行する場合、<code>FairSchedule</code>よりもパフォーマンスが悪くなる可能性があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n = 20

julia&gt; c = Channel{Int}(ch -&gt; foreach(i -&gt; put!(ch, i), 1:n), 1)

julia&gt; d = Channel{Int}(n) do ch
           f = i -&gt; put!(ch, i^2)
           Threads.foreach(f, c)
       end

julia&gt; collect(d)
collect(d) = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400]</code></pre><div class="admonition is-compat" id="Julia-1.6-7215191bbae7db1e"><header class="admonition-header">Julia 1.6<a class="admonition-anchor" href="#Julia-1.6-7215191bbae7db1e" title="Permalink"></a></header><div class="admonition-body"><p>この関数はJulia 1.6以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threads_overloads.jl#L3-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.@spawn" href="#Base.Threads.@spawn"><code>Base.Threads.@spawn</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.@spawn [:default|:interactive|:samepool] expr</code></pre><p><a href="parallel.html#Core.Task"><code>Task</code></a> を作成し、指定されたスレッドプール <code>:default</code>、<code>:interactive</code>、または呼び出し元と同じプールを使用する <code>:samepool</code> で実行するように <a href="parallel.html#Base.schedule"><code>schedule</code></a> します。指定されていない場合は <code>:default</code> が使用されます。タスクは、利用可能なスレッドが見つかると、そのスレッドに割り当てられます。タスクが完了するのを待つには、このマクロの結果に対して <a href="parallel.html#Base.wait"><code>wait</code></a> を呼び出すか、<a href="parallel.html#Base.fetch-Tuple{Task}"><code>fetch</code></a> を呼び出して待機し、その戻り値を取得します。</p><p>値は <code>$</code> を介して <code>@spawn</code> に補間でき、これは値を構築された基盤のクロージャに直接コピーします。これにより、変数の<em>値</em>を挿入でき、現在のタスク内での変数の値の変更から非同期コードを隔離できます。</p><div class="admonition is-info" id="Note-e786c1fe8959e2c1"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e786c1fe8959e2c1" title="Permalink"></a></header><div class="admonition-body"><p>タスクが実行されるスレッドは、タスクが中断されると変更される可能性があるため、<code>threadid()</code> はタスクに対して定数として扱うべきではありません。詳細な重要な注意事項については、<a href="../manual/multi-threading.html#man-task-migration"><code>Task Migration</code></a> およびより広範な <a href="../manual/multi-threading.html#man-multithreading">multi-threading</a> マニュアルを参照してください。また、<a href="../manual/multi-threading.html#man-threadpools">threadpools</a> に関する章も参照してください。</p></div></div><div class="admonition is-compat" id="Julia-1.3-249f08e258804c9b"><header class="admonition-header">Julia 1.3<a class="admonition-anchor" href="#Julia-1.3-249f08e258804c9b" title="Permalink"></a></header><div class="admonition-body"><p>このマクロは Julia 1.3 以降で利用可能です。</p></div></div><div class="admonition is-compat" id="Julia-1.4-8582f31c89587bff"><header class="admonition-header">Julia 1.4<a class="admonition-anchor" href="#Julia-1.4-8582f31c89587bff" title="Permalink"></a></header><div class="admonition-body"><p><code>$</code> を介して値を補間することは Julia 1.4 以降で利用可能です。</p></div></div><div class="admonition is-compat" id="Julia-1.9-6cfc801018ab8544"><header class="admonition-header">Julia 1.9<a class="admonition-anchor" href="#Julia-1.9-6cfc801018ab8544" title="Permalink"></a></header><div class="admonition-body"><p>スレッドプールは Julia 1.9 以降で指定できます。</p></div></div><div class="admonition is-compat" id="Julia-1.12-6b04707f63643dbe"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-6b04707f63643dbe" title="Permalink"></a></header><div class="admonition-body"><p>同じスレッドプールは Julia 1.12 以降で指定できます。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t() = println(&quot;Hello from &quot;, Threads.threadid());

julia&gt; tasks = fetch.([Threads.@spawn t() for i in 1:4]);
Hello from 1
Hello from 1
Hello from 3
Hello from 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L448-L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.threadid" href="#Base.Threads.threadid"><code>Base.Threads.threadid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.threadid([t::Task]) -&gt; Int</code></pre><p>現在の実行スレッドのID番号、またはタスク<code>t</code>のスレッドのID番号を取得します。マスタースレッドのIDは<code>1</code>です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Threads.threadid()
1

julia&gt; Threads.@threads for i in 1:4
          println(Threads.threadid())
       end
4
2
5
4

julia&gt; Threads.threadid(Threads.@spawn &quot;foo&quot;)
2</code></pre><div class="admonition is-info" id="Note-89963c3cde2f165d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-89963c3cde2f165d" title="Permalink"></a></header><div class="admonition-body"><p>タスクが実行されるスレッドは、タスクが中断されると変更される可能性があり、これを<a href="../manual/multi-threading.html#man-task-migration"><code>Task Migration</code></a>と呼びます。このため、ほとんどの場合、<code>threadid([task])</code>を使用して、たとえばバッファや状態を持つオブジェクトのベクターにインデックスを付けることは安全ではありません。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L8-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.maxthreadid" href="#Base.Threads.maxthreadid"><code>Base.Threads.maxthreadid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.maxthreadid() -&gt; Int</code></pre><p>Juliaプロセスで利用可能なスレッドの数（すべてのスレッドプールを通じて）の下限を取得します。これは、アトミック取得セマンティクスを持ちます。結果は常に<a href="multi-threading.html#Base.Threads.threadid"><code>threadid()</code></a>および<code>threadid(task)</code>（<code>maxthreadid</code>を呼び出す前に観察できた任意のタスクに対して）以上になります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.nthreads" href="#Base.Threads.nthreads"><code>Base.Threads.nthreads</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.nthreads(:default | :interactive) -&gt; Int</code></pre><p>指定されたスレッドプール内の現在のスレッド数を取得します。<code>:interactive</code> のスレッドは ID 番号 <code>1:nthreads(:interactive)</code> を持ち、<code>:default</code> のスレッドは <code>nthreads(:interactive) .+ (1:nthreads(:default))</code> の ID 番号を持ちます。</p><p><code>BLAS.get_num_threads</code> および <code>BLAS.set_num_threads</code> は <a href="../stdlib/LinearAlgebra.html#man-linalg"><code>LinearAlgebra</code></a> 標準ライブラリに、<code>nprocs()</code> は <a href="../stdlib/Distributed.html#man-distributed"><code>Distributed</code></a> 標準ライブラリに、そして <a href="multi-threading.html#Base.Threads.maxthreadid"><code>Threads.maxthreadid()</code></a> にも関連しています。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.threadpool" href="#Base.Threads.threadpool"><code>Base.Threads.threadpool</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.threadpool(tid = threadid()) -&gt; Symbol</code></pre><p>指定されたスレッドのスレッドプールを返します。<code>：default</code>、<code>：interactive</code>、または<code>：foreign</code>のいずれかです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.nthreadpools" href="#Base.Threads.nthreadpools"><code>Base.Threads.nthreadpools</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.nthreadpools() -&gt; Int</code></pre><p>現在構成されているスレッドプールの数を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.threadpoolsize" href="#Base.Threads.threadpoolsize"><code>Base.Threads.threadpoolsize</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.threadpoolsize(pool::Symbol = :default) -&gt; Int</code></pre><p>デフォルトのスレッドプール（または指定されたスレッドプール）で利用可能なスレッドの数を取得します。</p><p>関連情報: <a href="../stdlib/LinearAlgebra.html#man-linalg"><code>LinearAlgebra</code></a> 標準ライブラリの <code>BLAS.get_num_threads</code> および <code>BLAS.set_num_threads</code>、および <a href="../stdlib/Distributed.html#man-distributed"><code>Distributed</code></a> 標準ライブラリの <code>nprocs()</code>。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L126-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.ngcthreads" href="#Base.Threads.ngcthreads"><code>Base.Threads.ngcthreads</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.ngcthreads() -&gt; Int</code></pre><p>現在構成されているGCスレッドの数を返します。これには、マークスレッドと同時スイープスレッドの両方が含まれます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadingconstructs.jl#L163-L168">source</a></section></article><p>See also <a href="../manual/multi-threading.html#man-multithreading">Multi-Threading</a>.</p><h2 id="Atomic-operations"><a class="docs-heading-anchor" href="#Atomic-operations">Atomic operations</a><a id="Atomic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-operations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="atomic" href="#atomic"><code>atomic</code></a> — <span class="docstring-category">Keyword</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Unsafe pointer operations are compatible with loading and storing pointers declared with <code>_Atomic</code> and <code>std::atomic</code> type in C11 and C++23 respectively. An error may be thrown if there is not support for atomically loading the Julia type <code>T</code>.</p><p>See also: <a href="c.html#Base.unsafe_load"><code>unsafe_load</code></a>, <a href="c.html#Base.unsafe_modify!"><code>unsafe_modify!</code></a>, <a href="c.html#Base.unsafe_replace!"><code>unsafe_replace!</code></a>, <a href="c.html#Base.unsafe_store!"><code>unsafe_store!</code></a>, <a href="c.html#Base.unsafe_swap!"><code>unsafe_swap!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/docs/basedocs.jl#L3771-L3777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomic" href="#Base.@atomic"><code>Base.@atomic</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomic var
@atomic order ex</code></pre><p><code>var</code> または <code>ex</code> を原子的に実行されるものとしてマークします。<code>order</code> が指定されていない場合、デフォルトは :sequentially_consistent です。</p><pre><code class="language-julia hljs">@atomic a.b.x = new
@atomic a.b.x += addend
@atomic :release a.b.x = new
@atomic :acquire_release a.b.x += addend
@atomic m[idx] = new
@atomic m[idx] += addend
@atomic :release m[idx] = new
@atomic :acquire_release m[idx] += addend</code></pre><p>右側で表現されたストア操作を原子的に実行し、新しい値を返します。</p><p>代入（<code>=</code>）の場合、この操作は <code>setproperty!(a.b, :x, new)</code> に変換されるか、参照の場合は <code>setindex_atomic!(m, order, new, idx)</code> 呼び出しに変換され、<code>order</code> のデフォルトは <code>:sequentially_consistent</code> です。</p><p>任意の修正演算子の場合、この操作は <code>modifyproperty!(a.b, :x, op, addend)[2]</code> に変換されるか、参照の場合は <code>modifyindex_atomic!(m, order, op, addend, idx...)[2]</code> 呼び出しに変換され、<code>order</code> のデフォルトは <code>:sequentially_consistent</code> です。</p><pre><code class="language-julia hljs">@atomic a.b.x max arg2
@atomic a.b.x + arg2
@atomic max(a.b.x, arg2)
@atomic :acquire_release max(a.b.x, arg2)
@atomic :acquire_release a.b.x + arg2
@atomic :acquire_release a.b.x max arg2
@atomic m[idx] max arg2
@atomic m[idx] + arg2
@atomic max(m[idx], arg2)
@atomic :acquire_release max(m[idx], arg2)
@atomic :acquire_release m[idx] + arg2
@atomic :acquire_release m[idx] max arg2</code></pre><p>右側で表現された二項演算を原子的に実行します。結果を最初の引数のフィールドまたは参照に格納し、値 <code>(old, new)</code> を返します。</p><p>この操作は <code>modifyproperty!(a.b, :x, func, arg2)</code> に変換されるか、参照の場合は <code>modifyindex_atomic!(m, order, func, arg2, idx)</code> 呼び出しに変換され、<code>order</code> のデフォルトは <code>:sequentially_consistent</code> です。</p><p>詳細については、マニュアルの <a href="math.html#Base.:--Tuple{Any, Any}">Per-field atomics</a> セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Atomic{T}; @atomic x::T; end

julia&gt; a = Atomic(1)
Atomic{Int64}(1)

julia&gt; @atomic a.x # fetch field x of a, with sequential consistency
1

julia&gt; @atomic :sequentially_consistent a.x = 2 # set field x of a, with sequential consistency
2

julia&gt; @atomic a.x += 1 # increment field x of a, with sequential consistency
3

julia&gt; @atomic a.x + 1 # increment field x of a, with sequential consistency
3 =&gt; 4

julia&gt; @atomic a.x # fetch field x of a, with sequential consistency
4

julia&gt; @atomic max(a.x, 10) # change field x of a to the max value, with sequential consistency
4 =&gt; 10

julia&gt; @atomic a.x max 5 # again change field x of a to the max value, with sequential consistency
10 =&gt; 10</code></pre><pre><code class="language-julia-repl hljs">julia&gt; mem = AtomicMemory{Int}(undef, 2);

julia&gt; @atomic mem[1] = 2 # set mem[1] to value 2 with sequential consistency
2

julia&gt; @atomic :monotonic mem[1] # fetch the first value of mem, with monotonic consistency
2

julia&gt; @atomic mem[1] += 1 # increment the first value of mem, with sequential consistency
3

julia&gt; @atomic mem[1] + 1 # increment the first value of mem, with sequential consistency
3 =&gt; 4

julia&gt; @atomic mem[1] # fetch the first value of mem, with sequential consistency
4

julia&gt; @atomic max(mem[1], 10) # change the first value of mem to the max value, with sequential consistency
4 =&gt; 10

julia&gt; @atomic mem[1] max 5 # again change the first value of mem to the max value, with sequential consistency
10 =&gt; 10</code></pre><div class="admonition is-compat" id="Julia-1.7-6986c08086b58517"><header class="admonition-header">Julia 1.7<a class="admonition-anchor" href="#Julia-1.7-6986c08086b58517" title="Permalink"></a></header><div class="admonition-body"><p>Atomic fields functionality requires at least Julia 1.7.</p></div></div><div class="admonition is-compat" id="Julia-1.12-2a21cc04f57d4fa0"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-2a21cc04f57d4fa0" title="Permalink"></a></header><div class="admonition-body"><p>Atomic reference functionality requires at least Julia 1.12.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/expr.jl#L1197-L1307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomicswap" href="#Base.@atomicswap"><code>Base.@atomicswap</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomicswap a.b.x = new
@atomicswap :sequentially_consistent a.b.x = new
@atomicswap m[idx] = new
@atomicswap :sequentially_consistent m[idx] = new</code></pre><p><code>new</code>を<code>a.b.x</code>（参照の場合は<code>m[idx]</code>）に格納し、<code>a.b.x</code>の古い値（それぞれ<code>m[idx]</code>に格納されていた古い値）を返します。</p><p>この操作は、<code>swapproperty!(a.b, :x, new)</code>または、参照の場合は<code>swapindex_atomic!(mem, order, new, idx)</code>呼び出しに変換され、<code>order</code>はデフォルトで<code>:sequentially_consistent</code>になります。</p><p>詳細については、マニュアルの<a href="../manual/multi-threading.html#man-atomics">Per-field atomics</a>セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Atomic{T}; @atomic x::T; end

julia&gt; a = Atomic(1)
Atomic{Int64}(1)

julia&gt; @atomicswap a.x = 2+2 # aのフィールドxを4に置き換え、順序の一貫性を持つ
1

julia&gt; @atomic a.x # aのフィールドxを取得し、順序の一貫性を持つ
4</code></pre><pre><code class="language-julia-repl hljs">julia&gt; mem = AtomicMemory{Int}(undef, 2);

julia&gt; @atomic mem[1] = 1;

julia&gt; @atomicswap mem[1] = 4 # `mem`の最初の値を4に置き換え、順序の一貫性を持つ
1

julia&gt; @atomic mem[1] # memの最初の値を取得し、順序の一貫性を持つ
4</code></pre><div class="admonition is-compat" id="Julia-1.7-3353f8bb7599fa"><header class="admonition-header">Julia 1.7<a class="admonition-anchor" href="#Julia-1.7-3353f8bb7599fa" title="Permalink"></a></header><div class="admonition-body"><p>Atomic fields機能は、少なくともJulia 1.7が必要です。</p></div></div><div class="admonition is-compat" id="Julia-1.12-7a194f050a81d641"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-7a194f050a81d641" title="Permalink"></a></header><div class="admonition-body"><p>Atomic reference機能は、少なくともJulia 1.12が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/expr.jl#L1381-L1427">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomicreplace" href="#Base.@atomicreplace"><code>Base.@atomicreplace</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomicreplace a.b.x expected =&gt; desired
@atomicreplace :sequentially_consistent a.b.x expected =&gt; desired
@atomicreplace :sequentially_consistent :monotonic a.b.x expected =&gt; desired
@atomicreplace m[idx] expected =&gt; desired
@atomicreplace :sequentially_consistent m[idx] expected =&gt; desired
@atomicreplace :sequentially_consistent :monotonic m[idx] expected =&gt; desired</code></pre><p>ペアによって表現された条件付き置換を原子的に実行し、値 <code>(old, success::Bool)</code> を返します。ここで <code>success</code> は置換が完了したかどうかを示します。</p><p>この操作は <code>replaceproperty!(a.b, :x, expected, desired)</code> または参照の場合は <code>replaceindex_atomic!(mem, success_order, fail_order, expected, desired, idx)</code> 呼び出しに変換され、両方の順序はデフォルトで <code>:sequentially_consistent</code> になります。</p><p>詳細についてはマニュアルの <a href="../manual/multi-threading.html#man-atomics">Per-field atomics</a> セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Atomic{T}; @atomic x::T; end

julia&gt; a = Atomic(1)
Atomic{Int64}(1)

julia&gt; @atomicreplace a.x 1 =&gt; 2 # aのフィールドxを1であれば2に置換し、順序は逐次的整合性
(old = 1, success = true)

julia&gt; @atomic a.x # aのフィールドxを取得し、順序は逐次的整合性
2

julia&gt; @atomicreplace a.x 1 =&gt; 3 # aのフィールドxを1であれば2に置換し、順序は逐次的整合性
(old = 2, success = false)

julia&gt; xchg = 2 =&gt; 0; # aのフィールドxを2であれば0に置換し、順序は逐次的整合性

julia&gt; @atomicreplace a.x xchg
(old = 2, success = true)

julia&gt; @atomic a.x # aのフィールドxを取得し、順序は逐次的整合性
0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; mem = AtomicMemory{Int}(undef, 2);

julia&gt; @atomic mem[1] = 1;

julia&gt; @atomicreplace mem[1] 1 =&gt; 2 # memの最初の値を1であれば2に置換し、順序は逐次的整合性
(old = 1, success = true)

julia&gt; @atomic mem[1] # memの最初の値を取得し、順序は逐次的整合性
2

julia&gt; @atomicreplace mem[1] 1 =&gt; 3 # aのフィールドxを1であれば2に置換し、順序は逐次的整合性
(old = 2, success = false)

julia&gt; xchg = 2 =&gt; 0; # aのフィールドxを2であれば0に置換し、順序は逐次的整合性

julia&gt; @atomicreplace mem[1] xchg
(old = 2, success = true)

julia&gt; @atomic mem[1] # memの最初の値を取得し、順序は逐次的整合性
0</code></pre><div class="admonition is-compat" id="Julia-1.7-6036b4636b9c9534"><header class="admonition-header">Julia 1.7<a class="admonition-anchor" href="#Julia-1.7-6036b4636b9c9534" title="Permalink"></a></header><div class="admonition-body"><p>原子的フィールド機能は少なくともJulia 1.7が必要です。</p></div></div><div class="admonition is-compat" id="Julia-1.12-3367b642e718981d"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-3367b642e718981d" title="Permalink"></a></header><div class="admonition-body"><p>原子的参照機能は少なくともJulia 1.12が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/expr.jl#L1450-L1522">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@atomiconce" href="#Base.@atomiconce"><code>Base.@atomiconce</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@atomiconce a.b.x = value
@atomiconce :sequentially_consistent a.b.x = value
@atomiconce :sequentially_consistent :monotonic a.b.x = value
@atomiconce m[idx] = value
@atomiconce :sequentially_consistent m[idx] = value
@atomiconce :sequentially_consistent :monotonic m[idx] = value</code></pre><p>値が以前に未設定であった場合、条件付きで値を原子的に割り当てます。返される値 <code>success::Bool</code> は、割り当てが完了したかどうかを示します。</p><p>この操作は <code>setpropertyonce!(a.b, :x, value)</code> に変換されるか、参照の場合は <code>setindexonce_atomic!(m, success_order, fail_order, value, idx)</code> 呼び出しに変換され、両方の順序はデフォルトで <code>:sequentially_consistent</code> になります。</p><p>詳細については、マニュアルの <a href="../manual/multi-threading.html#man-atomics">Per-field atomics</a> セクションを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct AtomicOnce
           @atomic x
           AtomicOnce() = new()
       end

julia&gt; a = AtomicOnce()
AtomicOnce(#undef)

julia&gt; @atomiconce a.x = 1 # aのフィールドxを1に設定します。未設定の場合、順序はsequential consistencyです。
true

julia&gt; @atomic a.x # aのフィールドxを取得します。順序はsequential consistencyです。
1

julia&gt; @atomiconce :monotonic a.x = 2 # aのフィールドxを1に設定します。未設定の場合、順序はmonotonic consistencyです。
false</code></pre><pre><code class="language-julia-repl hljs">julia&gt; mem = AtomicMemory{Vector{Int}}(undef, 1);

julia&gt; isassigned(mem, 1)
false

julia&gt; @atomiconce mem[1] = [1] # memの最初の値を[1]に設定します。未設定の場合、順序はsequential consistencyです。
true

julia&gt; isassigned(mem, 1)
true

julia&gt; @atomic mem[1] # memの最初の値を取得します。順序はsequential consistencyです。
1-element Vector{Int64}:
 1

julia&gt; @atomiconce :monotonic mem[1] = [2] # memの最初の値を[2]に設定します。未設定の場合、順序はmonotonicです。
false

julia&gt; @atomic mem[1]
1-element Vector{Int64}:
 1</code></pre><div class="admonition is-compat" id="Julia-1.11-8d3182011d573b25"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-8d3182011d573b25" title="Permalink"></a></header><div class="admonition-body"><p>原子的フィールド機能は、少なくともJulia 1.11が必要です。</p></div></div><div class="admonition is-compat" id="Julia-1.12-eeb8bc0fd24f9f4c"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-eeb8bc0fd24f9f4c" title="Permalink"></a></header><div class="admonition-body"><p>原子的参照機能は、少なくともJulia 1.12が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/expr.jl#L1559-L1625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.AtomicMemory" href="#Core.AtomicMemory"><code>Core.AtomicMemory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AtomicMemory{T} == GenericMemory{:atomic, T, Core.CPU}</code></pre><p>固定サイズの <a href="arrays.html#Base.DenseVector"><code>DenseVector{T}</code></a>。その個々の要素への取得は原子的に行われます（デフォルトでは <code>:monotonic</code> 順序）。</p><div class="admonition is-warning" id="Warning-907b97092ed6956c"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-907b97092ed6956c" title="Permalink"></a></header><div class="admonition-body"><p><code>AtomicMemory</code> へのアクセスは、<a href="multi-threading.html#Base.@atomic"><code>@atomic</code></a> マクロを使用するか、低レベルのインターフェース関数 <code>Base.getindex_atomic</code>、<code>Base.setindex_atomic!</code>、<code>Base.setindexonce_atomic!</code>、<code>Base.swapindex_atomic!</code>、<code>Base.modifyindex_atomic!</code>、および <code>Base.replaceindex_atomic!</code> を使用して行う必要があります。</p></div></div><p>詳細については、<a href="../manual/multi-threading.html#man-atomic-operations">Atomic Operations</a> およびマクロ <a href="multi-threading.html#Base.@atomic"><code>@atomic</code></a>、<a href="multi-threading.html#Base.@atomiconce"><code>@atomiconce</code></a>、<a href="multi-threading.html#Base.@atomicswap"><code>@atomicswap</code></a>、および <a href="multi-threading.html#Base.@atomicreplace"><code>@atomicreplace</code></a> を参照してください。</p><div class="admonition is-compat" id="Julia-1.11-a4955f8c12375439"><header class="admonition-header">Julia 1.11<a class="admonition-anchor" href="#Julia-1.11-a4955f8c12375439" title="Permalink"></a></header><div class="admonition-body"><p>この型は Julia 1.11 以降が必要です。</p></div></div><div class="admonition is-compat" id="Julia-1.12-5a380c0be2a1d144"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-5a380c0be2a1d144" title="Permalink"></a></header><div class="admonition-body"><p>低レベルのインターフェース関数または <code>@atomic</code> マクロは Julia 1.12 以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/genericmemory.jl#L36-L57">source</a></section></article><p><code>unsafe</code> 関数のセットには、これらの原子操作の C/C++ 互換バージョンを選択するオプションのメモリ順序パラメータもあります。このパラメータが指定されている場合、<a href="c.html#Base.unsafe_load"><code>unsafe_load</code></a>、<a href="c.html#Base.unsafe_store!"><code>unsafe_store!</code></a>、<a href="c.html#Base.unsafe_swap!"><code>unsafe_swap!</code></a>、<a href="c.html#Base.unsafe_replace!"><code>unsafe_replace!</code></a>、および <a href="c.html#Base.unsafe_modify!"><code>unsafe_modify!</code></a> が使用されます。</p><div class="admonition is-warning" id="Warning-17984a4113806c56"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-17984a4113806c56" title="Permalink"></a></header><div class="admonition-body"><p>以下のAPIは非推奨ですが、サポートは数回のリリースにわたって残る可能性があります。</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.Atomic" href="#Base.Threads.Atomic"><code>Base.Threads.Atomic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.Atomic{T}</code></pre><p>型 <code>T</code> のオブジェクトへの参照を保持し、それが原子的に、すなわちスレッドセーフな方法でのみアクセスされることを保証します。</p><p>原子的に使用できるのは特定の「単純な」型のみで、具体的には原始的なブール型、整数型、および浮動小数点型です。これらは <code>Bool</code>、<code>Int8</code>...<code>Int128</code>、<code>UInt8</code>...<code>UInt128</code>、および <code>Float16</code>...<code>Float64</code> です。</p><p>新しい原子オブジェクトは非原子的な値から作成できます。指定がない場合、原子オブジェクトはゼロで初期化されます。</p><p>原子オブジェクトには <code>[]</code> 表記を使用してアクセスできます：</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; x[] = 1
1

julia&gt; x[]
1</code></pre><p>原子操作は <code>atomic_</code> プレフィックスを使用し、例えば <a href="multi-threading.html#Base.Threads.atomic_add!"><code>atomic_add!</code></a>、<a href="multi-threading.html#Base.Threads.atomic_xchg!"><code>atomic_xchg!</code></a> などがあります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L45-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_cas!" href="#Base.Threads.atomic_cas!"><code>Base.Threads.atomic_cas!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_cas!(x::Atomic{T}, cmp::T, newval::T) where T</code></pre><p>原子比較と設定 <code>x</code></p><p><code>x</code> の値を <code>cmp</code> と原子比較します。等しい場合、<code>newval</code> を <code>x</code> に書き込みます。そうでない場合、<code>x</code> は変更されずにそのままです。<code>x</code> の古い値を返します。返された値を <code>cmp</code> と比較することで（<code>===</code> を介して）、<code>x</code> が変更されたかどうか、そして現在 <code>newval</code> の新しい値を保持しているかを知ることができます。</p><p>詳細については、LLVM の <code>cmpxchg</code> 命令を参照してください。</p><p>この関数はトランザクションセマンティクスを実装するために使用できます。トランザクションの前に、<code>x</code> の値を記録します。トランザクションの後、<code>x</code> がその間に変更されていない場合のみ新しい値が保存されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_cas!(x, 4, 2);

julia&gt; x
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_cas!(x, 3, 2);

julia&gt; x
Base.Threads.Atomic{Int64}(2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L90-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_xchg!" href="#Base.Threads.atomic_xchg!"><code>Base.Threads.atomic_xchg!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_xchg!(x::Atomic{T}, newval::T) where T</code></pre><p><code>x</code>の値を原子的に交換します。</p><p><code>x</code>の値を<code>newval</code>と原子的に交換します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw xchg</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_xchg!(x, 2)
3

julia&gt; x[]
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L125-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_add!" href="#Base.Threads.atomic_add!"><code>Base.Threads.atomic_add!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_add!(x::Atomic{T}, val::T) where T &lt;: ArithmeticTypes</code></pre><p><code>val</code>を<code>x</code>に原子的に加算します。</p><p><code>x[] += val</code>を原子的に実行します。<strong>古い</strong>値を返します。<code>Atomic{Bool}</code>には定義されていません。</p><p>詳細については、LLVMの<code>atomicrmw add</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_add!(x, 2)
3

julia&gt; x[]
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L149-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_sub!" href="#Base.Threads.atomic_sub!"><code>Base.Threads.atomic_sub!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_sub!(x::Atomic{T}, val::T) where T &lt;: ArithmeticTypes</code></pre><p><code>val</code>を<code>x</code>から原子的に減算します。</p><p><code>x[] -= val</code>を原子的に実行します。<strong>古い</strong>値を返します。<code>Atomic{Bool}</code>には定義されていません。</p><p>詳細については、LLVMの<code>atomicrmw sub</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_sub!(x, 2)
3

julia&gt; x[]
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L173-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_and!" href="#Base.Threads.atomic_and!"><code>Base.Threads.atomic_and!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_and!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>を<code>val</code>と原子的にビット単位でANDします。</p><p><code>x[] &amp;= val</code>を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw and</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_and!(x, 2)
3

julia&gt; x[]
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L197-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_nand!" href="#Base.Threads.atomic_nand!"><code>Base.Threads.atomic_nand!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_nand!(x::Atomic{T}, val::T) where T</code></pre><p>原子的に <code>x</code> と <code>val</code> のビットワイズ NAND（非論理積）を行います。</p><p><code>x[] = ~(x[] &amp; val)</code> を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの <code>atomicrmw nand</code> 命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(3)
Base.Threads.Atomic{Int64}(3)

julia&gt; Threads.atomic_nand!(x, 2)
3

julia&gt; x[]
-3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L220-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_or!" href="#Base.Threads.atomic_or!"><code>Base.Threads.atomic_or!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_or!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>を<code>val</code>と原子的にビット単位で論理和します。</p><p><code>x[] |= val</code>を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw or</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia&gt; Threads.atomic_or!(x, 7)
5

julia&gt; x[]
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L243-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_xor!" href="#Base.Threads.atomic_xor!"><code>Base.Threads.atomic_xor!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_xor!(x::Atomic{T}, val::T) where T</code></pre><p>原子的に <code>x</code> と <code>val</code> のビット単位の排他的論理和 (XOR) を計算します。</p><p><code>x[] $= val</code> を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの <code>atomicrmw xor</code> 命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia&gt; Threads.atomic_xor!(x, 7)
5

julia&gt; x[]
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L266-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_max!" href="#Base.Threads.atomic_max!"><code>Base.Threads.atomic_max!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_max!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>と<code>val</code>の最大値を原子的に<code>x</code>に格納します。</p><p><code>x[] = max(x[], val)</code>を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw max</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(5)
Base.Threads.Atomic{Int64}(5)

julia&gt; Threads.atomic_max!(x, 7)
5

julia&gt; x[]
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L289-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_min!" href="#Base.Threads.atomic_min!"><code>Base.Threads.atomic_min!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_min!(x::Atomic{T}, val::T) where T</code></pre><p><code>x</code>と<code>val</code>の最小値を原子的に<code>x</code>に格納します。</p><p><code>x[] = min(x[], val)</code>を原子的に実行します。<strong>古い</strong>値を返します。</p><p>詳細については、LLVMの<code>atomicrmw min</code>命令を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Threads.Atomic{Int}(7)
Base.Threads.Atomic{Int64}(7)

julia&gt; Threads.atomic_min!(x, 5)
7

julia&gt; x[]
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L312-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.atomic_fence" href="#Base.Threads.atomic_fence"><code>Base.Threads.atomic_fence</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Threads.atomic_fence()</code></pre><p>逐次一致性メモリフェンスを挿入します</p><p>逐次一致性の順序セマンティクスを持つメモリフェンスを挿入します。これは、取得/解放の順序が不十分なアルゴリズムがあるため、必要です。</p><p>これは非常に高価な操作である可能性があります。Juliaの他のすべての原子操作にはすでに取得/解放セマンティクスがあるため、明示的なフェンスはほとんどの場合必要ないはずです。</p><p>詳細については、LLVMの<code>fence</code>命令を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/atomics.jl#L450-L464">source</a></section></article><h2 id="ccall-using-a-libuv-threadpool-(Experimental)"><a class="docs-heading-anchor" href="#ccall-using-a-libuv-threadpool-(Experimental)">ccall using a libuv threadpool (Experimental)</a><a id="ccall-using-a-libuv-threadpool-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#ccall-using-a-libuv-threadpool-(Experimental)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.@threadcall" href="#Base.@threadcall"><code>Base.@threadcall</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)</code></pre><p><code>@threadcall</code>マクロは<a href="c.html#ccall"><code>ccall</code></a>と同じ方法で呼び出されますが、異なるスレッドで作業を行います。これは、現在の<code>julia</code>スレッドをブロックさせることなく、ブロッキングC関数を呼び出したい場合に便利です。並行性はlibuvスレッドプールのサイズによって制限され、デフォルトでは4スレッドですが、<code>UV_THREADPOOL_SIZE</code>環境変数を設定し、<code>julia</code>プロセスを再起動することで増やすことができます。</p><p>呼び出される関数は、決してJuliaにコールバックしてはいけないことに注意してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/threadcall.jl#L8-L19">source</a></section></article><h2 id="Low-level-synchronization-primitives"><a class="docs-heading-anchor" href="#Low-level-synchronization-primitives">Low-level synchronization primitives</a><a id="Low-level-synchronization-primitives-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-synchronization-primitives" title="Permalink"></a></h2><p>これらのビルディングブロックは、通常の同期オブジェクトを作成するために使用されます。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.SpinLock" href="#Base.Threads.SpinLock"><code>Base.Threads.SpinLock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SpinLock()</code></pre><p>非再入型のテスト・アンド・テスト・アンド・セットスピンロックを作成します。再帰的な使用はデッドロックを引き起こします。この種のロックは、実行にかかる時間が短く、ブロックしないコード（例：I/Oを実行する）周辺でのみ使用するべきです。一般的には、<a href="parallel.html#Base.ReentrantLock"><code>ReentrantLock</code></a> を代わりに使用するべきです。</p><p>各 <a href="parallel.html#Base.lock"><code>lock</code></a> は、<a href="parallel.html#Base.unlock"><code>unlock</code></a> と対になっている必要があります。もし <a href="parallel.html#Base.islocked"><code>!islocked(lck::SpinLock)</code></a> が成り立つ場合、<a href="parallel.html#Base.trylock"><code>trylock(lck)</code></a> は、他のタスクが「同時に」ロックを保持しようとしていない限り成功します。</p><p>テスト・アンド・テスト・アンド・セットスピンロックは、約30程度の競合スレッドまでが最も速いです。それ以上の競合がある場合は、異なる同期アプローチを検討する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/locks-mt.jl#L14-L30">source</a></section></article><h2 id="Task-metrics-(Experimental)"><a class="docs-heading-anchor" href="#Task-metrics-(Experimental)">Task metrics (Experimental)</a><a id="Task-metrics-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Task-metrics-(Experimental)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Experimental.task_metrics" href="#Base.Experimental.task_metrics"><code>Base.Experimental.task_metrics</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.Experimental.task_metrics(::Bool)</code></pre><p>タスクごとのメトリクスの収集を有効または無効にします。<code>Base.Experimental.task_metrics(true)</code>が有効なときに作成された<code>Task</code>は、<a href="multi-threading.html#Base.Experimental.task_running_time_ns"><code>Base.Experimental.task_running_time_ns</code></a>および<a href="multi-threading.html#Base.Experimental.task_wall_time_ns"><code>Base.Experimental.task_wall_time_ns</code></a>のタイミング情報を利用できます。</p><div class="admonition is-info" id="Note-1bd5533cb4a43dad"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1bd5533cb4a43dad" title="Permalink"></a></header><div class="admonition-body"><p>タスクメトリクスは、<code>--task-metrics=yes</code>コマンドラインオプションを介して起動時に有効にすることができます。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/experimental.jl#L510-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Experimental.task_running_time_ns" href="#Base.Experimental.task_running_time_ns"><code>Base.Experimental.task_running_time_ns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.Experimental.task_running_time_ns(t::Task) -&gt; Union{UInt64, Nothing}</code></pre><p>タスク <code>t</code> が実行に費やした合計ナノ秒を返します。このメトリックは、<code>t</code> が yield するか完了するまで更新されず、<code>t</code> が現在のタスクである場合は継続的に更新されます。詳細は <a href="multi-threading.html#Base.Experimental.task_wall_time_ns"><code>Base.Experimental.task_wall_time_ns</code></a> を参照してください。</p><p>タスクのタイミングが有効でない場合は <code>nothing</code> を返します。詳細は <a href="multi-threading.html#Base.Experimental.task_metrics"><code>Base.Experimental.task_metrics</code></a> を参照してください。</p><div class="admonition is-info" id="このメトリックは-Julia-スケジューラからのものです-add8c6f9b9a55c62"><header class="admonition-header">このメトリックは Julia スケジューラからのものです<a class="admonition-anchor" href="#このメトリックは-Julia-スケジューラからのものです-add8c6f9b9a55c62" title="Permalink"></a></header><div class="admonition-body"><p>タスクは OS スレッド上で実行されており、OS スケジューラによってスケジュール解除される場合、この時間もメトリックにカウントされます。</p></div></div><div class="admonition is-compat" id="Julia-1.12-9f078e6fccb43ca2"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-9f078e6fccb43ca2" title="Permalink"></a></header><div class="admonition-body"><p>このメソッドは Julia 1.12 で追加されました。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/experimental.jl#L530-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Experimental.task_wall_time_ns" href="#Base.Experimental.task_wall_time_ns"><code>Base.Experimental.task_wall_time_ns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.Experimental.task_wall_time_ns(t::Task) -&gt; Union{UInt64, Nothing}</code></pre><p>タスク <code>t</code> が実行可能であった合計ナノ秒を返します。これは、タスクが最初に実行キューに入ってから、完了するまでの時間、またはタスクがまだ完了していない場合は現在の時間までの時間です。 <a href="multi-threading.html#Base.Experimental.task_running_time_ns"><code>Base.Experimental.task_running_time_ns</code></a> も参照してください。</p><p>タスクのタイミングが有効でない場合は <code>nothing</code> を返します。 <a href="multi-threading.html#Base.Experimental.task_metrics"><code>Base.Experimental.task_metrics</code></a> も参照してください。</p><div class="admonition is-compat" id="Julia-1.12-9f078e6fccb43ca2"><header class="admonition-header">Julia 1.12<a class="admonition-anchor" href="#Julia-1.12-9f078e6fccb43ca2" title="Permalink"></a></header><div class="admonition-body"><p>このメソッドは Julia 1.12 で追加されました。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ba1e628ee49351af0b704afd2b2903d253bd3564/base/experimental.jl#L559-L572">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="parallel.html">« Tasks</a><a class="docs-footer-nextpage" href="scopedvalues.html">Scoped Values »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 19 October 2025 05:51">Sunday 19 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
