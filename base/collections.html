<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Collections and Data Structures · The Julia Language</title><meta name="title" content="Collections and Data Structures · The Julia Language"/><meta property="og:title" content="Collections and Data Structures · The Julia Language"/><meta property="twitter:title" content="Collections and Data Structures · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/installation.html">Installation</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/asynchronous-programming.html">Asynchronous Programming</a></li><li><a class="tocitem" href="../manual/multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="../manual/distributed-computing.html">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="tocitem" href="../manual/command-line-interface.html">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Essentials</a></li><li class="is-active"><a class="tocitem" href="collections.html">Collections and Data Structures</a><ul class="internal"><li><a class="tocitem" href="#lib-collections-iteration"><span>Iteration</span></a></li><li><a class="tocitem" href="#Constructors-and-Types"><span>Constructors and Types</span></a></li><li><a class="tocitem" href="#General-Collections"><span>General Collections</span></a></li><li><a class="tocitem" href="#Iterable-Collections"><span>Iterable Collections</span></a></li><li><a class="tocitem" href="#Indexable-Collections"><span>Indexable Collections</span></a></li><li><a class="tocitem" href="#Dictionaries"><span>Dictionaries</span></a></li><li><a class="tocitem" href="#Set-Like-Collections"><span>Set-Like Collections</span></a></li><li><a class="tocitem" href="#Dequeues"><span>Dequeues</span></a></li><li><a class="tocitem" href="#Utility-Collections"><span>Utility Collections</span></a></li></ul></li><li><a class="tocitem" href="math.html">Mathematics</a></li><li><a class="tocitem" href="numbers.html">Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="arrays.html">Arrays</a></li><li><a class="tocitem" href="parallel.html">Tasks</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="scopedvalues.html">Scoped Values</a></li><li><a class="tocitem" href="constants.html">Constants</a></li><li><a class="tocitem" href="file.html">Filesystem</a></li><li><a class="tocitem" href="io-network.html">I/O and Network</a></li><li><a class="tocitem" href="punctuation.html">Punctuation</a></li><li><a class="tocitem" href="sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="reflection.html">Reflection and introspection</a></li><li><a class="tocitem" href="c.html">C Interface</a></li><li><a class="tocitem" href="libc.html">C Standard Library</a></li><li><a class="tocitem" href="stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/ArgTools.html">ArgTools</a></li><li><a class="tocitem" href="../stdlib/Artifacts.html">Artifacts</a></li><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/Downloads.html">Downloads</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LazyArtifacts.html">Lazy Artifacts</a></li><li><a class="tocitem" href="../stdlib/LibCURL.html">LibCURL</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/NetworkOptions.html">Network Options</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/StyledStrings.html">StyledStrings</a></li><li><a class="tocitem" href="../stdlib/TOML.html">TOML</a></li><li><a class="tocitem" href="../stdlib/Tar.html">Tar</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/pkgimg.html">Package Images</a></li><li><a class="tocitem" href="../devdocs/llvm-passes.html">Custom LLVM Passes</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/EscapeAnalysis.html"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../devdocs/aot.html">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../devdocs/gc.html">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../devdocs/jit.html">JIT Design and Implementation</a></li><li><a class="tocitem" href="../devdocs/builtins.html">Core.Builtins</a></li><li><a class="tocitem" href="../devdocs/precompile_hang.html">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/external_profilers.html">External Profiler Support</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li><li><a class="tocitem" href="../devdocs/probes.html">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/build/build.html">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../devdocs/build/linux.html">Linux</a></li><li><a class="tocitem" href="../devdocs/build/macos.html">macOS</a></li><li><a class="tocitem" href="../devdocs/build/windows.html">Windows</a></li><li><a class="tocitem" href="../devdocs/build/freebsd.html">FreeBSD</a></li><li><a class="tocitem" href="../devdocs/build/arm.html">ARM (Linux)</a></li><li><a class="tocitem" href="../devdocs/build/distributing.html">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="collections.html">Collections and Data Structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="collections.html">Collections and Data Structures</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/collections.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Collections-and-Data-Structures"><a class="docs-heading-anchor" href="#Collections-and-Data-Structures">Collections and Data Structures</a><a id="Collections-and-Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Collections-and-Data-Structures" title="Permalink"></a></h1><h2 id="lib-collections-iteration"><a class="docs-heading-anchor" href="#lib-collections-iteration">Iteration</a><a id="lib-collections-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#lib-collections-iteration" title="Permalink"></a></h2><p>逐次反復は <a href="collections.html#Base.iterate"><code>iterate</code></a> 関数によって実装されています。一般的な <code>for</code> ループ：</p><pre><code class="language-julia hljs">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><p>は次のように翻訳されます：</p><pre><code class="language-julia hljs">next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end</code></pre><p><code>state</code>オブジェクトは何でもよく、各イテラブルタイプに適切に選択されるべきです。カスタムイテラブルタイプを定義する詳細については、<a href="../manual/interfaces.html#man-interface-iteration">manual section on the iteration interface</a>を参照してください。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterate(iter [, state]) -&gt; Union{Nothing, Tuple{Any, Any}}</code></pre><p>イテレータを進めて次の要素を取得します。要素が残っていない場合は、<code>nothing</code>が返されるべきです。そうでなければ、次の要素と新しいイテレーション状態の2タプルが返されるべきです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L1234-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IteratorSize" href="#Base.IteratorSize"><code>Base.IteratorSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IteratorSize(itertype::Type) -&gt; IteratorSize</code></pre><p>イテレータの型を与えると、次のいずれかの値を返します：</p><ul><li><code>SizeUnknown()</code> もし長さ（要素の数）が事前に決定できない場合。</li><li><code>HasLength()</code> もし固定された有限の長さがある場合。</li><li><code>HasShape{N}()</code> もし既知の長さに加えて多次元の形状の概念がある場合（配列のように）。この場合、<code>N</code> は次元の数を示し、<a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a> 関数はイテレータに対して有効です。</li><li><code>IsInfinite()</code> もしイテレータが永遠に値を生成する場合。</li></ul><p>この関数を定義していないイテレータのデフォルト値は <code>HasLength()</code> です。これは、ほとんどのイテレータが <a href="collections.html#Base.length"><code>length</code></a> を実装していると仮定されることを意味します。</p><p>この特性は、結果のためにスペースを事前に割り当てるアルゴリズムと、結果を段階的にサイズ変更するアルゴリズムを選択するために一般的に使用されます。</p><pre><code class="language-julia-repl hljs">julia&gt; Base.IteratorSize(1:5)
Base.HasShape{1}()

julia&gt; Base.IteratorSize((2,3))
Base.HasLength()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/generator.jl#L68-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IteratorEltype" href="#Base.IteratorEltype"><code>Base.IteratorEltype</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IteratorEltype(itertype::Type) -&gt; IteratorEltype</code></pre><p>イテレータの型が与えられたとき、次のいずれかの値を返します：</p><ul><li><code>EltypeUnknown()</code> イテレータによって生成される要素の型が事前に知られていない場合。</li><li><code>HasEltype()</code> 要素の型が知られており、<a href="collections.html#Base.eltype"><code>eltype</code></a> が意味のある値を返す場合。</li></ul><p><code>HasEltype()</code> はデフォルトであり、イテレータは <a href="collections.html#Base.eltype"><code>eltype</code></a> を実装していると仮定されます。</p><p>このトレイトは、特定の型の結果を事前に割り当てるアルゴリズムと、生成される値の型に基づいて結果の型を選択するアルゴリズムの間で選択するために一般的に使用されます。</p><pre><code class="language-julia-repl hljs">julia&gt; Base.IteratorEltype(1:5)
Base.HasEltype()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/generator.jl#L109-L127">source</a></section></article><p>完全に実装されました:</p><ul><li><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a></li><li><a href="collections.html#Base.UnitRange"><code>UnitRange</code></a></li><li><a href="base.html#Core.Tuple"><code>Tuple</code></a></li><li><a href="numbers.html#Core.Number"><code>Number</code></a></li><li><a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a></li><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li><li><code>各行</code></li><li><a href="strings.html#Core.AbstractString"><code>AbstractString</code></a></li><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="collections.html#Core.Pair"><code>Pair</code></a></li><li><a href="base.html#Core.NamedTuple"><code>NamedTuple</code></a></li></ul><h2 id="Constructors-and-Types"><a class="docs-heading-anchor" href="#Constructors-and-Types">Constructors and Types</a><a id="Constructors-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors-and-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractRange" href="#Base.AbstractRange"><code>Base.AbstractRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRange{T} &lt;: AbstractVector{T}</code></pre><p>型 <code>T</code> の要素を持つ線形範囲のスーパタイプです。 <a href="collections.html#Base.UnitRange"><code>UnitRange</code></a>、<a href="collections.html#Base.LinRange"><code>LinRange</code></a> およびその他の型はこのサブタイプです。</p><p>すべてのサブタイプは <a href="collections.html#Base.step"><code>step</code></a> を定義する必要があります。したがって、<a href="math.html#Base.LogRange"><code>LogRange</code></a> は <code>AbstractRange</code> のサブタイプではありません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L255-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.OrdinalRange" href="#Base.OrdinalRange"><code>Base.OrdinalRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrdinalRange{T, S} &lt;: AbstractRange{T}</code></pre><p>型 <code>T</code> の要素を持ち、型 <code>S</code> の間隔を持つ順序範囲のスーパークラス。ステップは常に <a href="numbers.html#Base.oneunit"><code>oneunit</code></a> の正確な倍数である必要があり、<code>T</code> は &quot;離散的&quot; な型でなければならず、<code>oneunit</code> より小さい値を持つことはできません。例えば、<code>Integer</code> や <code>Date</code> 型は適格ですが、<code>Float64</code> は適格ではありません（この型は <code>oneunit(Float64)</code> より小さい値を表すことができるため）。<a href="collections.html#Base.UnitRange"><code>UnitRange</code></a>、<a href="collections.html#Base.StepRange"><code>StepRange</code></a>、およびその他の型はこのサブタイプです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L273-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractUnitRange" href="#Base.AbstractUnitRange"><code>Base.AbstractUnitRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractUnitRange{T} &lt;: OrdinalRange{T, T}</code></pre><p>ステップサイズが<a href="numbers.html#Base.oneunit"><code>oneunit(T)</code></a>で、要素の型が<code>T</code>の範囲のスーパークラスです。<a href="collections.html#Base.UnitRange"><code>UnitRange</code></a>やその他の型はこのサブタイプです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L286-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.StepRange" href="#Base.StepRange"><code>Base.StepRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StepRange{T, S} &lt;: OrdinalRange{T, S}</code></pre><p>要素の型 <code>T</code> と間隔の型 <code>S</code> を持つ範囲。各要素間のステップは一定で、範囲は型 <code>T</code> の <code>start</code> と <code>stop</code>、および型 <code>S</code> の <code>step</code> に基づいて定義されます。<code>T</code> も <code>S</code> も浮動小数点型であってはなりません。<code>a:b:c</code> という構文は、<code>b != 0</code> であり、<code>a</code>、<code>b</code>、<code>c</code> がすべて整数である場合に <code>StepRange</code> を作成します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(StepRange(1, Int8(2), 10))
5-element Vector{Int64}:
 1
 3
 5
 7
 9

julia&gt; typeof(StepRange(1, Int8(2), 10))
StepRange{Int64, Int8}

julia&gt; typeof(1:3:6)
StepRange{Int64, Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L294-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.UnitRange" href="#Base.UnitRange"><code>Base.UnitRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitRange{T&lt;:Real}</code></pre><p><code>start</code> と <code>stop</code> の型 <code>T</code> によってパラメータ化された範囲で、<code>start</code> から <code>stop</code> を超えるまで <code>1</code> ずつ間隔を空けて要素が埋められます。<code>a:b</code> という構文は、<code>a</code> と <code>b</code> の両方が <code>Integer</code> の場合に <code>UnitRange</code> を作成します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(UnitRange(2.3, 5.2))
3-element Vector{Float64}:
 2.3
 3.3
 4.3

julia&gt; typeof(1:10)
UnitRange{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L386-L404">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.LinRange" href="#Base.LinRange"><code>Base.LinRange</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinRange{T,L}</code></pre><p><code>start</code> と <code>stop</code> の間に <code>len</code> 個の線形に間隔をあけた要素を持つ範囲。間隔のサイズは <code>len</code> によって制御され、<code>Integer</code> でなければなりません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LinRange(1.5, 5.5, 9)
9-element LinRange{Float64, Int64}:
 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5</code></pre><p><a href="math.html#Base.range"><code>range</code></a> を使用するのと比較して、<code>LinRange</code> を直接構築する方がオーバーヘッドが少なくなりますが、浮動小数点エラーを修正しようとはしません：</p><pre><code class="language-julia-repl hljs">julia&gt; collect(range(-0.1, 0.3, length=5))
5-element Vector{Float64}:
 -0.1
  0.0
  0.1
  0.2
  0.3

julia&gt; collect(LinRange(-0.1, 0.3, 5))
5-element Vector{Float64}:
 -0.1
 -1.3877787807814457e-17
  0.09999999999999999
  0.19999999999999998
  0.3</code></pre><p>対数間隔の点については <a href="math.html#Base.LogRange"><code>Logrange</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L524-L559">source</a></section></article><h2 id="General-Collections"><a class="docs-heading-anchor" href="#General-Collections">General Collections</a><a id="General-Collections-1"></a><a class="docs-heading-anchor-permalink" href="#General-Collections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isempty(collection) -&gt; Bool</code></pre><p>コレクションが空であるかどうかを判断します（要素がない）。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>isempty(itr)</code> は、適切な <a href="collections.html#Base.isdone"><code>Base.isdone(itr)</code></a> メソッドが定義されていない限り、状態を持つイテレータ <code>itr</code> の次の要素を消費する可能性があります。状態を持つイテレータは <em>isdone</em> を実装すべきですが、任意のイテレータタイプをサポートする汎用コードを書く際には <code>isempty</code> の使用を避けることをお勧めします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L1096-L1117">source</a></section><section><div><pre><code class="language-julia hljs">isempty(condition)</code></pre><p>条件に待機中のタスクがない場合は <code>true</code> を返し、そうでない場合は <code>false</code> を返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/condition.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdone" href="#Base.isdone"><code>Base.isdone</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdone(itr, [state]) -&gt; Union{Bool, Missing}</code></pre><p>この関数は、イテレータの完了に関する高速パスのヒントを提供します。これは、ユーザーに公開されない要素が消費されるのを避けたい状態を持つイテレータにとって便利です（例えば、<code>isempty</code>や<code>zip</code>で完了状態を確認する際など）。</p><p>この機能を利用したい状態を持つイテレータは、イテレータが完了しているかどうかに応じてtrue/falseを返す<code>isdone</code>メソッドを定義する必要があります。状態を持たないイテレータは、この関数を実装する必要はありません。</p><p>結果が<code>missing</code>の場合、呼び出し元は<code>iterate(x, state) === nothing</code>を計算して明確な答えを得ることができます。</p><p>関連情報として、<a href="collections.html#Base.iterate"><code>iterate</code></a>、<a href="collections.html#Base.isempty"><code>isempty</code></a>を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L1215-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">empty!(collection) -&gt; collection</code></pre><p>コレクションからすべての要素を削除します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; empty!(A);

julia&gt; A
Dict{String, Int64}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L202-L219">source</a></section><section><div><pre><code class="language-julia hljs">empty!(c::Channel)</code></pre><p>チャンネル <code>c</code> を内部バッファに対して <code>empty!</code> を呼び出すことで空にします。空のチャンネルを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/channels.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(collection) -&gt; 整数</code></pre><p>コレクション内の要素の数を返します。</p><p>インデックス可能なコレクションの最後の有効なインデックスを取得するには、<a href="collections.html#Base.lastindex"><code>lastindex</code></a>を使用してください。</p><p>関連情報: <a href="arrays.html#Base.size"><code>size</code></a>, <a href="arrays.html#Base.ndims"><code>ndims</code></a>, <a href="arrays.html#Base.eachindex"><code>eachindex</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length(1:5)
5

julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L278-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.checked_length" href="#Base.checked_length"><code>Base.checked_length</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.checked_length(r)</code></pre><p><code>length(r)</code>を計算しますが、結果が<code>Union{Integer(eltype(r)),Int}</code>に収まらない場合は、適用可能な場合にオーバーフローエラーをチェックすることがあります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/checked.jl#L374-L379">source</a></section></article><p>完全に実装されました:</p><ul><li><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a></li><li><a href="collections.html#Base.UnitRange"><code>UnitRange</code></a></li><li><a href="base.html#Core.Tuple"><code>Tuple</code></a></li><li><a href="numbers.html#Core.Number"><code>Number</code></a></li><li><a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a></li><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li><li><a href="strings.html#Core.AbstractString"><code>AbstractString</code></a></li><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="base.html#Core.NamedTuple"><code>NamedTuple</code></a></li></ul><h2 id="Iterable-Collections"><a class="docs-heading-anchor" href="#Iterable-Collections">Iterable Collections</a><a id="Iterable-Collections-1"></a><a class="docs-heading-anchor-permalink" href="#Iterable-Collections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in" href="#Base.in"><code>Base.in</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">in(item, collection) -&gt; Bool
∈(item, collection) -&gt; Bool</code></pre><p>指定されたコレクションにアイテムが含まれているかどうかを判断します。これは、コレクションを反復処理して生成された値のいずれかに対して<a href="math.html#Base.:=="><code>==</code></a>であるという意味です。<code>item</code>が<a href="../manual/missing.html#missing"><code>missing</code></a>であるか、<code>collection</code>が<code>item</code>を含まない<code>missing</code>を含む場合を除いて、<code>Bool</code>値を返します。この場合、<code>missing</code>が返されます（<a href="https://en.wikipedia.org/wiki/Three-valued_logic">三値論理</a>、<a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a>および<a href="math.html#Base.:=="><code>==</code></a>の動作に一致します）。</p><p>一部のコレクションは、わずかに異なる定義に従います。たとえば、<a href="collections.html#Base.Set"><code>Set</code></a>はアイテムが要素のいずれかに<a href="base.html#Base.isequal"><code>isequal</code></a>であるかどうかを確認します。<a href="collections.html#Base.Dict"><code>Dict</code></a>は<code>key=&gt;value</code>ペアを探し、<code>key</code>は<a href="base.html#Base.isequal"><code>isequal</code></a>を使用して比較されます。</p><p>辞書内のキーの存在をテストするには、<a href="collections.html#Base.haskey"><code>haskey</code></a>または<code>k in keys(dict)</code>を使用します。上記のコレクションについては、結果は常に<code>Bool</code>です。</p><p><code>in.(items, collection)</code>または<code>items .∈ collection</code>でブロードキャストすると、<code>item</code>と<code>collection</code>の両方がブロードキャストされますが、これはしばしば意図したものではありません。たとえば、両方の引数がベクトルで（次元が一致する場合）、結果はコレクション<code>items</code>の各値が<code>collection</code>の対応する位置の値に<code>in</code>であるかどうかを示すベクトルになります。<code>items</code>の各値が<code>collection</code>に含まれているかどうかを示すベクトルを取得するには、<code>collection</code>をタプルまたは<code>Ref</code>でラップします。次のようにします：<code>in.(items, Ref(collection))</code>または<code>items .∈ Ref(collection)</code>。</p><p>関連情報：<a href="collections.html#Base.:∉"><code>∉</code></a>、<a href="sort.html#Base.Sort.insorted"><code>insorted</code></a>、<a href="strings.html#Base.contains"><code>contains</code></a>、<a href="strings.html#Base.occursin"><code>occursin</code></a>、<a href="collections.html#Base.issubset"><code>issubset</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1:3:20
1:3:19

julia&gt; 4 in a
true

julia&gt; 5 in a
false

julia&gt; missing in [1, 2]
missing

julia&gt; 1 in [2, missing]
missing

julia&gt; 1 in [1, missing]
true

julia&gt; missing in Set([1, 2])
false

julia&gt; (1=&gt;missing) in Dict(1=&gt;10, 2=&gt;20)
missing

julia&gt; [1, 2] .∈ [2, 3]
2-element BitVector:
 0
 0

julia&gt; [1, 2] .∈ ([2, 3],)
2-element BitVector:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/operators.jl#L1343-L1409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∉" href="#Base.:∉"><code>Base.:∉</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∉(item, collection) -&gt; Bool
∌(collection, item) -&gt; Bool</code></pre><p><code>∈</code> と <code>∋</code> の否定、すなわち <code>item</code> が <code>collection</code> に含まれていないことをチェックします。</p><p><code>items .∉ collection</code> でブロードキャストすると、<code>item</code> と <code>collection</code> の両方がブロードキャストされるため、意図しない結果になることがよくあります。たとえば、両方の引数がベクトルで（次元が一致する場合）、結果は <code>collection</code> の対応する位置の値に対して <code>items</code> の各値が含まれていないかどうかを示すベクトルになります。<code>items</code> の各値が <code>collection</code> に含まれていないかどうかを示すベクトルを取得するには、<code>collection</code> をタプルまたは <code>Ref</code> でラップします。例えば、<code>items .∉ Ref(collection)</code> のようにします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 1 ∉ 2:4
true

julia&gt; 1 ∉ 1:3
false

julia&gt; [1, 2] .∉ [2, 3]
2-element BitVector:
 1
 1

julia&gt; [1, 2] .∉ ([2, 3],)
2-element BitVector:
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/operators.jl#L1412-L1444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.hasfastin" href="#Base.hasfastin"><code>Base.hasfastin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.hasfastin(T)</code></pre><p><code>collection::T</code> に対して <code>x ∈ collection</code> の計算が「高速」な操作（通常は定数または対数の複雑さ）と見なされるかどうかを判断します。便利のために <code>hasfastin(x) = hasfastin(typeof(x))</code> という定義が提供されているので、インスタンスを型の代わりに渡すことができます。ただし、型引数を受け取る形式は新しい型のために定義する必要があります。</p><p><code>hasfastin(T)</code> のデフォルトは、<a href="collections.html#Base.AbstractSet"><code>AbstractSet</code></a>、<a href="collections.html#Base.AbstractDict"><code>AbstractDict</code></a>、および <a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a> のサブタイプに対しては <code>true</code> であり、それ以外は <code>false</code> です。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L348-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eltype(type)</code></pre><p>与えられた <code>type</code> のコレクションを反復処理することによって生成される要素の型を決定します。辞書型の場合、これは <code>Pair{KeyType,ValType}</code> になります。定義 <code>eltype(x) = eltype(typeof(x))</code> は、インスタンスを型の代わりに渡すことができるように便利のために提供されています。ただし、型引数を受け入れる形式は新しい型のために定義されるべきです。</p><p>参照: <a href="collections.html#Base.keytype"><code>keytype</code></a>, <a href="base.html#Core.typeof"><code>typeof</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eltype(fill(1f0, (2,2)))
Float32

julia&gt; eltype(fill(0x1, (2,2)))
UInt8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L219-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.indexin" href="#Base.indexin"><code>Base.indexin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indexin(a, b)</code></pre><p><code>b</code>の各値に対する<code>a</code>の最初のインデックスを含む配列を返します。出力配列は、<code>a</code>が<code>b</code>のメンバーでない場合は<code>nothing</code>を含みます。</p><p>関連情報: <a href="sort.html#Base.sortperm"><code>sortperm</code></a>, <a href="arrays.html#Base.findfirst-Tuple{Any}"><code>findfirst</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;];

julia&gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

julia&gt; indexin(a, b)
6-element Vector{Union{Nothing, Int64}}:
 1
 2
 3
 2
  nothing
 1

julia&gt; indexin(b, a)
3-element Vector{Union{Nothing, Int64}}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L2714-L2744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.unique" href="#Base.unique"><code>Base.unique</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique(itr)</code></pre><p>コレクション <code>itr</code> のユニークな要素のみを含む配列を返します。これは <a href="base.html#Base.isequal"><code>isequal</code></a> と <a href="base.html#Base.hash"><code>hash</code></a> によって決定され、同等の要素の最初の出現順に並べられます。入力の要素型は保持されます。</p><p>関連情報: <a href="collections.html#Base.unique!"><code>unique!</code></a>, <a href="collections.html#Base.allunique"><code>allunique</code></a>, <a href="collections.html#Base.allequal"><code>allequal</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique([1, 2, 6, 2])
3-element Vector{Int64}:
 1
 2
 6

julia&gt; unique(Real[1, 1.0, 2])
2-element Vector{Real}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L200-L223">source</a></section><section><div><pre><code class="language-julia hljs">unique(f, itr)</code></pre><p><code>itr</code>の要素に適用された<code>f</code>によって生成された各ユニークな値から1つの値を含む配列を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique(x -&gt; x^2, [1, -1, 3, -3, 4])
3-element Vector{Int64}:
 1
 3
 4</code></pre><p>この機能は、配列内のユニークな要素の最初の出現の<em>インデックス</em>を抽出するためにも使用できます：</p><pre><code class="language-julia-repl hljs">julia&gt; a = [3.1, 4.2, 5.3, 3.1, 3.1, 3.1, 4.2, 1.7];

julia&gt; i = unique(i -&gt; a[i], eachindex(a))
4-element Vector{Int64}:
 1
 2
 3
 8

julia&gt; a[i]
4-element Vector{Float64}:
 3.1
 4.2
 5.3
 1.7

julia&gt; a[i] == unique(a)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L264-L300">source</a></section><section><div><pre><code class="language-julia hljs">unique(A::AbstractArray; dims::Int)</code></pre><p>次元 <code>dims</code> に沿った <code>A</code> のユニークな領域を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = map(isodd, reshape(Vector(1:8), (2,2,2)))
2×2×2 Array{Bool, 3}:
[:, :, 1] =
 1  1
 0  0

[:, :, 2] =
 1  1
 0  0

julia&gt; unique(A)
2-element Vector{Bool}:
 1
 0

julia&gt; unique(A, dims=2)
2×1×2 Array{Bool, 3}:
[:, :, 1] =
 1
 0

[:, :, 2] =
 1
 0

julia&gt; unique(A, dims=3)
2×2×1 Array{Bool, 3}:
[:, :, 1] =
 1  1
 0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/multidimensional.jl#L1685-L1723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unique!(f, A::AbstractVector)</code></pre><p><code>A</code>の要素に適用された<code>f</code>によって生成された各ユニークな値に対して<code>A</code>から1つの値を選択し、修正された<code>A</code>を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>このメソッドはJulia 1.1以降で利用可能です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique!(x -&gt; x^2, [1, -1, 3, -3, 4])
3-element Vector{Int64}:
 1
 3
 4

julia&gt; unique!(n -&gt; n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])
3-element Vector{Int64}:
 5
 1
 9

julia&gt; unique!(iseven, [2, 3, 5, 7, 9])
2-element Vector{Int64}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L344-L372">source</a></section><section><div><pre><code class="language-julia hljs">unique!(A::AbstractVector)</code></pre><p><a href="base.html#Base.isequal"><code>isequal</code></a> および <a href="base.html#Base.hash"><code>hash</code></a> によって決定される重複アイテムを削除し、修正された <code>A</code> を返します。<code>unique!</code> は、<code>A</code> の要素を発生する順序で返します。返されるデータの順序を気にしない場合は、<code>(sort!(A); unique!(A))</code> を呼び出す方が、<code>A</code> の要素がソート可能である限り、はるかに効率的です。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique!([1, 1, 1])
1-element Vector{Int64}:
 1

julia&gt; A = [7, 3, 2, 3, 7, 5];

julia&gt; unique!(A)
4-element Vector{Int64}:
 7
 3
 2
 5

julia&gt; B = [7, 6, 42, 6, 7, 42];

julia&gt; sort!(B);  # unique! はソートされたデータをより効率的に処理できます。

julia&gt; unique!(B)
3-element Vector{Int64}:
  6
  7
 42</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L436-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.allunique" href="#Base.allunique"><code>Base.allunique</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allunique(itr) -&gt; Bool
allunique(f, itr) -&gt; Bool</code></pre><p><code>itr</code>からのすべての値が<a href="base.html#Base.isequal"><code>isequal</code></a>で比較したときに異なる場合は<code>true</code>を返します。あるいは、2番目のメソッドの場合、<code>[f(x) for x in itr]</code>のすべてが異なる場合です。</p><p><code>allunique(f, itr)</code>は、<code>length(itr)</code>回未満で<code>f</code>を呼び出す場合があります。呼び出しの正確な回数は実装の詳細と見なされます。</p><p><code>allunique</code>は、入力がソートされている場合に特化した実装を使用することがあります。</p><p>関連情報: <a href="collections.html#Base.unique"><code>unique</code></a>, <a href="sort.html#Base.issorted"><code>issorted</code></a>, <a href="collections.html#Base.allequal"><code>allequal</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p>メソッド<code>allunique(f, itr)</code>は、少なくともJulia 1.11が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; allunique([1, 2, 3])
true

julia&gt; allunique([1, 2, 1, 2])
false

julia&gt; allunique(Real[1, 1.0, 2])
false

julia&gt; allunique([NaN, 2.0, NaN, 4.0])
false

julia&gt; allunique(abs, [1, -1, 2])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L480-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.allequal" href="#Base.allequal"><code>Base.allequal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allequal(itr) -&gt; Bool
allequal(f, itr) -&gt; Bool</code></pre><p><code>itr</code>のすべての値が<a href="base.html#Base.isequal"><code>isequal</code></a>で比較したときに等しい場合は<code>true</code>を返します。あるいは、2番目のメソッドでは<code>[f(x) for x in itr]</code>のすべてが等しい場合です。</p><p><code>allequal(f, itr)</code>は、<code>f</code>を<code>length(itr)</code>回未満で呼び出す場合があります。呼び出しの正確な回数は実装の詳細と見なされます。</p><p>関連: <a href="collections.html#Base.unique"><code>unique</code></a>, <a href="collections.html#Base.allunique"><code>allunique</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p><code>allequal</code>関数は少なくともJulia 1.8が必要です。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p>メソッド<code>allequal(f, itr)</code>は少なくともJulia 1.11が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; allequal([])
true

julia&gt; allequal([1])
true

julia&gt; allequal([1, 1])
true

julia&gt; allequal([1, 2])
false

julia&gt; allequal(Dict(:a =&gt; 1, :b =&gt; 1))
false

julia&gt; allequal(abs2, [1, -1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L604-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Any, Any}" href="#Base.reduce-Tuple{Any, Any}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce(op, itr; [init])</code></pre><p>与えられた二項演算子 <code>op</code> を使って、与えられたコレクション <code>itr</code> を縮約します。提供された場合、初期値 <code>init</code> は <code>op</code> の中立要素でなければならず、空のコレクションに対して返されます。非空のコレクションに対して <code>init</code> が使用されるかどうかは不明です。</p><p>空のコレクションに対しては、<code>init</code> を提供する必要がありますが、いくつかの特別なケース（例えば、<code>op</code> が <code>+</code>、<code>*</code>、<code>max</code>、<code>min</code>、<code>&amp;</code>、<code>|</code> のいずれかである場合）では、Julia が <code>op</code> の中立要素を決定できます。</p><p>特定の一般的に使用される演算子の縮約には特別な実装がある場合があり、代わりに使用すべきです: <a href="collections.html#Base.maximum"><code>maximum</code></a><code>(itr)</code>, <a href="collections.html#Base.minimum"><code>minimum</code></a><code>(itr)</code>, <a href="collections.html#Base.sum"><code>sum</code></a><code>(itr)</code>, <a href="collections.html#Base.prod"><code>prod</code></a><code>(itr)</code>, <a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a><code>(itr)</code>, <a href="collections.html#Base.all-Tuple{Any}"><code>all</code></a><code>(itr)</code>. 配列の配列を連結するための効率的な方法は、<code>reduce(</code><a href="arrays.html#Base.vcat"><code>vcat</code></a><code>, arr)</code> または <code>reduce(</code><a href="arrays.html#Base.hcat"><code>hcat</code></a><code>, arr)</code> を呼び出すことです。</p><p>縮約の結合性は実装に依存します。これは、<code>-</code> のような非結合的な操作を使用できないことを意味します。なぜなら、<code>reduce(-,[1,2,3])</code> が <code>(1-2)-3</code> または <code>1-(2-3)</code> として評価されるべきかは未定義だからです。左または右の結合性が保証されるためには、代わりに <a href="collections.html#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a> または <a href="collections.html#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a> を使用してください。</p><p>いくつかの操作は誤差を蓄積します。縮約がグループで実行できる場合、並列処理が容易になります。将来のバージョンの Julia ではアルゴリズムが変更される可能性があります。順序付きコレクションを使用する場合、要素は再配置されないことに注意してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reduce(*, [2; 3; 4])
24

julia&gt; reduce(*, [2; 3; 4]; init=-1)
-24</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L452-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reduce-Tuple{Any, AbstractArray}" href="#Base.reduce-Tuple{Any, AbstractArray}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce(f, A::AbstractArray; dims=:, [init])</code></pre><p>2引数関数 <code>f</code> を <code>A</code> の次元に沿って縮小します。<code>dims</code> は縮小する次元を指定するベクトルであり、キーワード引数 <code>init</code> は縮小に使用する初期値です。<code>+</code>、<code>*</code>、<code>max</code> および <code>min</code> の場合、<code>init</code> 引数はオプションです。</p><p>縮小の結合性は実装に依存します。特定の結合性、例えば左から右への結合性が必要な場合は、自分自身のループを書くか、<a href="collections.html#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a> または <a href="collections.html#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a> の使用を検討してください。<a href="collections.html#Base.reduce-Tuple{Any, Any}"><code>reduce</code></a> のドキュメントを参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = reshape(Vector(1:16), (4,4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reduce(max, a, dims=2)
4×1 Matrix{Int64}:
 13
 14
 15
 16

julia&gt; reduce(max, a, dims=1)
1×4 Matrix{Int64}:
 4  8  12  16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L346-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.foldl-Tuple{Any, Any}" href="#Base.foldl-Tuple{Any, Any}"><code>Base.foldl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldl(op, itr; [init])</code></pre><p><a href="collections.html#Base.reduce-Tuple{Any, Any}"><code>reduce</code></a>と同様ですが、左結合性が保証されています。提供された場合、キーワード引数<code>init</code>は正確に1回使用されます。一般的に、空のコレクションで作業するには<code>init</code>を提供する必要があります。</p><p>他に<a href="collections.html#Base.mapfoldl-Tuple{Any, Any, Any}"><code>mapfoldl</code></a>、<a href="collections.html#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a>、<a href="arrays.html#Base.accumulate"><code>accumulate</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; foldl(=&gt;, 1:4)
((1 =&gt; 2) =&gt; 3) =&gt; 4

julia&gt; foldl(=&gt;, 1:4; init=0)
(((0 =&gt; 1) =&gt; 2) =&gt; 3) =&gt; 4

julia&gt; accumulate(=&gt;, (1,2,3,4))
(1, 1 =&gt; 2, (1 =&gt; 2) =&gt; 3, ((1 =&gt; 2) =&gt; 3) =&gt; 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L177-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.foldr-Tuple{Any, Any}" href="#Base.foldr-Tuple{Any, Any}"><code>Base.foldr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foldr(op, itr; [init])</code></pre><p><a href="collections.html#Base.reduce-Tuple{Any, Any}"><code>reduce</code></a>と同様ですが、右結合性が保証されています。キーワード引数<code>init</code>が提供された場合、正確に1回使用されます。一般的に、空のコレクションで作業するには<code>init</code>を提供する必要があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; foldr(=&gt;, 1:4)
1 =&gt; (2 =&gt; (3 =&gt; 4))

julia&gt; foldr(=&gt;, 1:4; init=0)
1 =&gt; (2 =&gt; (3 =&gt; (4 =&gt; 0)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L226-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum" href="#Base.maximum"><code>Base.maximum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximum(f, itr; [init])</code></pre><p>関数 <code>f</code> を <code>itr</code> の各要素に適用した結果の中で最大の値を返します。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> で指定できます。これは <code>max</code> に対して中立的な要素でなければならず（すなわち、他のどの要素よりも小さいか等しい）、非空のコレクションに対して <code>init</code> が使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数 <code>init</code> は Julia 1.6 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; maximum(length, [&quot;Julion&quot;, &quot;Julia&quot;, &quot;Jule&quot;])
6

julia&gt; maximum(length, []; init=-1)
-1

julia&gt; maximum(sin, Real[]; init=-1.0)  # 良い、なぜなら sin の出力は &gt;= -1
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L677-L701">source</a></section><section><div><pre><code class="language-julia hljs">maximum(itr; [init])</code></pre><p>コレクション内の最大の要素を返します。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> によって指定できます。これは <code>max</code> に対して中立的な要素でなければなりません（すなわち、他のどの要素よりも小さいか等しいものでなければなりません）。<code>init</code> が非空のコレクションに対して使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数 <code>init</code> は Julia 1.6 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; maximum(-20.5:10)
9.5

julia&gt; maximum([1,2,3])
3

julia&gt; maximum(())
ERROR: ArgumentError: reducing over an empty collection is not allowed; consider supplying `init` to the reducer
Stacktrace:
[...]

julia&gt; maximum((); init=-Inf)
-Inf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L731-L760">source</a></section><section><div><pre><code class="language-julia hljs">maximum(A::AbstractArray; dims)</code></pre><p>与えられた次元にわたる配列の最大値を計算します。2つ以上の引数の最大値を取る<a href="math.html#Base.max"><code>max(a,b)</code></a>関数も参照してください。これは<code>max.(a,b)</code>を介して配列に要素ごとに適用できます。</p><p>参照: <a href="collections.html#Base.maximum!"><code>maximum!</code></a>, <a href="collections.html#Base.extrema"><code>extrema</code></a>, <a href="collections.html#Base.findmax"><code>findmax</code></a>, <a href="collections.html#Base.argmax"><code>argmax</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; maximum(A, dims=1)
1×2 Matrix{Int64}:
 3  4

julia&gt; maximum(A, dims=2)
2×1 Matrix{Int64}:
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L599-L624">source</a></section><section><div><pre><code class="language-julia hljs">maximum(f, A::AbstractArray; dims)</code></pre><p>与えられた次元にわたって配列の各要素に関数 <code>f</code> を適用することによって最大値を計算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; maximum(abs2, A, dims=1)
1×2 Matrix{Int64}:
 9  16

julia&gt; maximum(abs2, A, dims=2)
2×1 Matrix{Int64}:
  4
 16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L627-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.maximum!" href="#Base.maximum!"><code>Base.maximum!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maximum!(r, A)</code></pre><p><code>A</code>の単一次元にわたる最大値を計算し、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; maximum!([1; 1], A)
2-element Vector{Int64}:
 2
 4

julia&gt; maximum!([1 1], A)
1×2 Matrix{Int64}:
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L652-L675">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum" href="#Base.minimum"><code>Base.minimum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimum(f, itr; [init])</code></pre><p>関数 <code>f</code> を <code>itr</code> の各要素に適用した結果の最小値を返します。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> で指定できます。これは <code>min</code> に対して中立的な要素でなければならず（すなわち、他のどの要素よりも大きいか等しい）、<code>init</code> が非空のコレクションに対して使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数 <code>init</code> は Julia 1.6 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; minimum(length, [&quot;Julion&quot;, &quot;Julia&quot;, &quot;Jule&quot;])
4

julia&gt; minimum(length, []; init=typemax(Int64))
9223372036854775807

julia&gt; minimum(sin, Real[]; init=1.0)  # 良い、sin の出力は &lt;= 1 であるため
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L704-L728">source</a></section><section><div><pre><code class="language-julia hljs">minimum(itr; [init])</code></pre><p>コレクション内の最小要素を返します。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> によって指定できます。これは <code>min</code> に対して中立的な要素でなければなりません（すなわち、他のどの要素よりも大きいか等しいものでなければなりません）。<code>init</code> が非空のコレクションに対して使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数 <code>init</code> は Julia 1.6 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; minimum(-20.5:10)
-20.5

julia&gt; minimum([1,2,3])
1

julia&gt; minimum([])
ERROR: ArgumentError: reducing over an empty collection is not allowed; consider supplying `init` to the reducer
Stacktrace:
[...]

julia&gt; minimum([]; init=Inf)
Inf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L763-L792">source</a></section><section><div><pre><code class="language-julia hljs">minimum(A::AbstractArray; dims)</code></pre><p>与えられた次元にわたる配列の最小値を計算します。2つ以上の引数の最小値を取るための<a href="math.html#Base.min"><code>min(a,b)</code></a>関数も参照してください。これは<code>min.(a,b)</code>を介して配列に要素ごとに適用できます。</p><p>他にも<a href="collections.html#Base.minimum!"><code>minimum!</code></a>、<a href="collections.html#Base.extrema"><code>extrema</code></a>、<a href="collections.html#Base.findmin"><code>findmin</code></a>、<a href="collections.html#Base.argmin"><code>argmin</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; minimum(A, dims=1)
1×2 Matrix{Int64}:
 1  2

julia&gt; minimum(A, dims=2)
2×1 Matrix{Int64}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L678-L703">source</a></section><section><div><pre><code class="language-julia hljs">minimum(f, A::AbstractArray; dims)</code></pre><p>与えられた次元にわたって配列の各要素に関数 <code>f</code> を呼び出すことによって最小値を計算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; minimum(abs2, A, dims=1)
1×2 Matrix{Int64}:
 1  4

julia&gt; minimum(abs2, A, dims=2)
2×1 Matrix{Int64}:
 1
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L706-L728">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.minimum!" href="#Base.minimum!"><code>Base.minimum!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimum!(r, A)</code></pre><p><code>A</code>の単一次元にわたる最小値を計算し、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; minimum!([1; 1], A)
2-element Vector{Int64}:
 1
 3

julia&gt; minimum!([1 1], A)
1×2 Matrix{Int64}:
 1  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L731-L754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema" href="#Base.extrema"><code>Base.extrema</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema(itr; [init]) -&gt; (mn, mx)</code></pre><p>最小値 <code>mn</code> と最大値 <code>mx</code> の両方を1回のパスで計算し、2タプルとして返します。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> で指定できます。これは、最初の要素と2番目の要素がそれぞれ <code>min</code> と <code>max</code> の中立要素である2タプルでなければなりません（すなわち、他のどの要素よりも大きい/小さいか等しい）。その結果、<code>itr</code> が空の場合、返される <code>(mn, mx)</code> タプルは <code>mn ≥ mx</code> を満たします。<code>init</code> が指定されている場合、非空の <code>itr</code> に対しても使用できます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>キーワード引数 <code>init</code> はJulia 1.8以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; extrema(2:10)
(2, 10)

julia&gt; extrema([9,pi,4.5])
(3.141592653589793, 9.0)

julia&gt; extrema([]; init = (Inf, -Inf))
(Inf, -Inf)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L795-L821">source</a></section><section><div><pre><code class="language-julia hljs">extrema(f, itr; [init]) -&gt; (mn, mx)</code></pre><p><code>itr</code>の各要素に適用された<code>f</code>の最小値<code>mn</code>と最大値<code>mx</code>の両方を計算し、それらを2タプルとして返します。<code>itr</code>に対しては1回のパスのみが行われます。</p><p>空の<code>itr</code>に対して返される値は<code>init</code>で指定できます。これは、最初の要素と2番目の要素がそれぞれ<code>min</code>と<code>max</code>の中立要素である2タプルでなければなりません（すなわち、他のどの要素よりも大きい/小さいか等しい）。これは非空のコレクションに使用されます。注意: これは、空の<code>itr</code>に対して返される値<code>(mn, mx)</code>が<code>mn ≥ mx</code>を満たすことを意味しますが、非空の<code>itr</code>に対しては<code>mn ≤ mx</code>を満たします。これは「逆説的」ですが、期待される結果です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>このメソッドはJulia 1.2以降が必要です。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>キーワード引数<code>init</code>はJulia 1.8以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; extrema(sin, 0:π)
(0.0, 0.9092974268256817)

julia&gt; extrema(sin, Real[]; init = (1.0, -1.0))  # 良好、なぜなら -1 ≤ sin(::Real) ≤ 1
(1.0, -1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L824-L851">source</a></section><section><div><pre><code class="language-julia hljs">extrema(A::AbstractArray; dims) -&gt; Array{Tuple}</code></pre><p>与えられた次元にわたって配列の最小および最大要素を計算します。</p><p>参照: <a href="collections.html#Base.minimum"><code>minimum</code></a>, <a href="collections.html#Base.maximum"><code>maximum</code></a>, <a href="collections.html#Base.extrema!"><code>extrema!</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(Vector(1:2:16), (2,2,2))
2×2×2 Array{Int64, 3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia&gt; extrema(A, dims = (1,2))
1×1×2 Array{Tuple{Int64, Int64}, 3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L757-L784">source</a></section><section><div><pre><code class="language-julia hljs">extrema(f, A::AbstractArray; dims) -&gt; Array{Tuple}</code></pre><p>与えられた次元の <code>A</code> の各要素に適用された <code>f</code> の最小値と最大値を計算します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>このメソッドは Julia 1.2 以降が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L787-L795">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.extrema!" href="#Base.extrema!"><code>Base.extrema!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extrema!(r, A)</code></pre><p><code>A</code>の単一次元にわたる最小値と最大値を計算し、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>このメソッドはJulia 1.8以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; extrema!([(1, 1); (1, 1)], A)
2-element Vector{Tuple{Int64, Int64}}:
 (1, 2)
 (3, 4)

julia&gt; extrema!([(1, 1);; (1, 1)], A)
1×2 Matrix{Tuple{Int64, Int64}}:
 (1, 3)  (2, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L798-L824">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.argmax" href="#Base.argmax"><code>Base.argmax</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">argmax(r::AbstractRange)</code></pre><p>範囲は複数の最大要素を持つことがあります。その場合、<code>argmax</code>は最大のインデックスを返しますが、必ずしも最初のものではありません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L872-L878">source</a></section><section><div><pre><code class="language-julia hljs">argmax(f, domain)</code></pre><p>値 <code>x</code> を <code>domain</code> から返し、<code>f(x)</code> が最大化されます。<code>f(x)</code> の最大値が複数ある場合は、最初のものが見つかります。</p><p><code>domain</code> は空でない反復可能なものでなければなりません。</p><p>値は <code>isless</code> で比較されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>このメソッドは Julia 1.7 以降が必要です。</p></div></div><p>関連情報として <a href="collections.html#Base.argmin"><code>argmin</code></a>、<a href="collections.html#Base.findmax"><code>findmax</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmax(abs, -10:5)
-10

julia&gt; argmax(cos, 0:π/2:2π)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1003-L1026">source</a></section><section><div><pre><code class="language-julia hljs">argmax(itr)</code></pre><p>コレクション内の最大要素のインデックスまたはキーを返します。最大要素が複数ある場合は、最初のものが返されます。</p><p>コレクションは空であってはいけません。</p><p>インデックスは<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(itr)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(itr)</code></a>によって返されるものと同じ型です。</p><p>値は<code>isless</code>で比較されます。</p><p>関連項目: <a href="collections.html#Base.argmin"><code>argmin</code></a>, <a href="collections.html#Base.findmax"><code>findmax</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmax([8, 0.1, -9, pi])
1

julia&gt; argmax([1, 7, 7, 6])
2

julia&gt; argmax([1, 7, 7, NaN])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1029-L1055">source</a></section><section><div><pre><code class="language-julia hljs">argmax(A; dims) -&gt; indices</code></pre><p>配列入力の場合、指定された次元にわたる最大要素のインデックスを返します。<code>NaN</code>は、<code>missing</code>を除くすべての値よりも大きいと見なされます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; argmax(A, dims=1)
1×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)

julia&gt; argmax(A, dims=2)
2×1 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1251-L1273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.argmin" href="#Base.argmin"><code>Base.argmin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">argmin(r::AbstractRange)</code></pre><p>範囲は複数の最小要素を持つことがあります。その場合、<code>argmin</code>は最小のインデックスを返しますが、必ずしも最初のものではありません。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L855-L861">source</a></section><section><div><pre><code class="language-julia hljs">argmin(f, domain)</code></pre><p><code>f(x)</code> が最小化される <code>domain</code> からの値 <code>x</code> を返します。<code>f(x)</code> の最小値が複数ある場合は、最初のものが見つかります。</p><p><code>domain</code> は空でない反復可能なものでなければなりません。</p><p><code>NaN</code> は <code>missing</code> を除くすべての値よりも小さいと見なされます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>このメソッドは Julia 1.7 以降が必要です。</p></div></div><p><a href="collections.html#Base.argmax"><code>argmax</code></a> や <a href="collections.html#Base.findmin"><code>findmin</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmin(sign, -10:5)
-10

julia&gt; argmin(x -&gt; -x^3 + x^2 - 10, -5:5)
5

julia&gt; argmin(acos, 0:0.1:1)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1058-L1084">source</a></section><section><div><pre><code class="language-julia hljs">argmin(itr)</code></pre><p>コレクション内の最小要素のインデックスまたはキーを返します。最小要素が複数ある場合は、最初のものが返されます。</p><p>コレクションは空であってはいけません。</p><p>インデックスは、<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(itr)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(itr)</code></a> によって返されるものと同じ型です。</p><p><code>NaN</code> は、<code>missing</code> を除くすべての値よりも小さいと見なされます。</p><p>関連情報: <a href="collections.html#Base.argmax"><code>argmax</code></a>, <a href="collections.html#Base.findmin"><code>findmin</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmin([8, 0.1, -9, pi])
3

julia&gt; argmin([7, 1, 1, 6])
2

julia&gt; argmin([7, 1, 1, NaN])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1087-L1113">source</a></section><section><div><pre><code class="language-julia hljs">argmin(A; dims) -&gt; indices</code></pre><p>配列入力の場合、指定された次元にわたる最小要素のインデックスを返します。<code>NaN</code>は、<code>missing</code>を除くすべての値よりも小さいと見なされます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; argmin(A, dims=1)
1×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)

julia&gt; argmin(A, dims=2)
2×1 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1226-L1248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findmax" href="#Base.findmax"><code>Base.findmax</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findmax(f, domain) -&gt; (f(x), index)</code></pre><p><code>f</code>の出力値（コドメイン内の値）と、<code>domain</code>内の対応する値のインデックスまたはキー（<code>f</code>への入力）をペアで返します。<code>f(x)</code>が最大化されるようにします。最大点が複数ある場合は、最初のものが返されます。</p><p><code>domain</code>は、<a href="collections.html#Base.keys"><code>keys</code></a>をサポートする空でないイテラブルでなければなりません。インデックスは<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(domain)</code></a>によって返されるものと同じ型です。</p><p>値は<code>isless</code>で比較されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>このメソッドはJulia 1.7以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmax(identity, 5:9)
(9, 5)

julia&gt; findmax(-, 1:10)
(-1, 1)

julia&gt; findmax(first, [(1, :a), (3, :b), (3, :c)])
(3, 2)

julia&gt; findmax(cos, 0:π/2:2π)
(1.0, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L874-L904">source</a></section><section><div><pre><code class="language-julia hljs">findmax(itr) -&gt; (x, index)</code></pre><p>コレクション <code>itr</code> の最大要素とそのインデックスまたはキーを返します。最大要素が複数ある場合は、最初のものが返されます。値は <code>isless</code> で比較されます。</p><p>インデックスは <a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(itr)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(itr)</code></a> によって返されるものと同じ型です。</p><p>関連項目: <a href="collections.html#Base.findmin"><code>findmin</code></a>, <a href="collections.html#Base.argmax"><code>argmax</code></a>, <a href="collections.html#Base.maximum"><code>maximum</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmax([8, 0.1, -9, pi])
(8.0, 1)

julia&gt; findmax([1, 7, 7, 6])
(7, 2)

julia&gt; findmax([1, 7, 7, NaN])
(NaN, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L909-L933">source</a></section><section><div><pre><code class="language-julia hljs">findmax(A; dims) -&gt; (maxval, index)</code></pre><p>配列入力に対して、指定された次元における最大値とそのインデックスを返します。<code>NaN</code>は、<code>missing</code>を除くすべての値よりも大きいと見なされます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; findmax(A, dims=1)
([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])

julia&gt; findmax(A, dims=2)
([2.0; 4.0;;], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2);;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1155-L1174">source</a></section><section><div><pre><code class="language-julia hljs">findmax(f, A; dims) -&gt; (f(x), index)</code></pre><p>配列入力の場合、指定された次元にわたって <code>f</code> を最大化する対応する値のコドメイン内の値とインデックスを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [-1.0 1; -0.5 2]
2×2 Matrix{Float64}:
 -1.0  1.0
 -0.5  2.0

julia&gt; findmax(abs2, A, dims=1)
([1.0 4.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(2, 2)])

julia&gt; findmax(abs2, A, dims=2)
([1.0; 4.0;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 2);;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1178-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findmin" href="#Base.findmin"><code>Base.findmin</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findmin(f, domain) -&gt; (f(x), index)</code></pre><p>コドメイン内の値（<code>f</code>の出力）と、対応する値のインデックスまたはキー（<code>f</code>の入力）からなるペアを返します。ここで、<code>f(x)</code>が最小化されます。最小点が複数ある場合は、最初のものが返されます。</p><p><code>domain</code>は空でないイテラブルでなければなりません。</p><p>インデックスは<a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(domain)</code></a>および<a href="collections.html#Base.pairs"><code>pairs(domain)</code></a>によって返されるものと同じ型です。</p><p><code>NaN</code>は、<code>missing</code>を除くすべての値よりも小さいと見なされます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>このメソッドはJulia 1.7以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmin(identity, 5:9)
(5, 1)

julia&gt; findmin(-, 1:10)
(-10, 10)

julia&gt; findmin(first, [(2, :a), (2, :b), (3, :c)])
(2, 1)

julia&gt; findmin(cos, 0:π/2:2π)
(-1.0, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L937-L970">source</a></section><section><div><pre><code class="language-julia hljs">findmin(itr) -&gt; (x, index)</code></pre><p>コレクション <code>itr</code> の最小要素とそのインデックスまたはキーを返します。複数の最小要素がある場合は、最初のものが返されます。<code>NaN</code> は <code>missing</code> を除くすべての値よりも小さいと見なされます。</p><p>インデックスは <a href="arrays.html#Base.keys-Tuple{AbstractArray}"><code>keys(itr)</code></a> および <a href="collections.html#Base.pairs"><code>pairs(itr)</code></a> によって返されるのと同じ型です。</p><p>関連情報: <a href="collections.html#Base.findmax"><code>findmax</code></a>, <a href="collections.html#Base.argmin"><code>argmin</code></a>, <a href="collections.html#Base.minimum"><code>minimum</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmin([8, 0.1, -9, pi])
(-9.0, 3)

julia&gt; findmin([1, 7, 7, 6])
(1, 1)

julia&gt; findmin([1, 7, 7, NaN])
(NaN, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L975-L999">source</a></section><section><div><pre><code class="language-julia hljs">findmin(A; dims) -&gt; (minval, index)</code></pre><p>配列入力に対して、指定された次元における最小値とそのインデックスを返します。<code>NaN</code>は、<code>missing</code>を除くすべての値よりも小さいと見なされます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; findmin(A, dims=1)
([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])

julia&gt; findmin(A, dims=2)
([1.0; 3.0;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1);;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1082-L1101">source</a></section><section><div><pre><code class="language-julia hljs">findmin(f, A; dims) -&gt; (f(x), index)</code></pre><p>配列入力の場合、指定された次元にわたって <code>f</code> を最小化する対応する値のコドメイン内の値とインデックスを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [-1.0 1; -0.5 2]
2×2 Matrix{Float64}:
 -1.0  1.0
 -0.5  2.0

julia&gt; findmin(abs2, A, dims=1)
([0.25 1.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(1, 2)])

julia&gt; findmin(abs2, A, dims=2)
([1.0; 0.25;;], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1);;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1105-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findmax!" href="#Base.findmax!"><code>Base.findmax!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findmax!(rval, rind, A) -&gt; (maxval, index)</code></pre><p><code>A</code>の最大値と対応する線形インデックスを<code>rval</code>と<code>rind</code>の単一次元に沿って見つけ、結果を<code>rval</code>と<code>rind</code>に格納します。<code>NaN</code>は<code>missing</code>を除くすべての他の値よりも大きいと見なされます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1141-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.findmin!" href="#Base.findmin!"><code>Base.findmin!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findmin!(rval, rind, A) -&gt; (minval, index)</code></pre><p><code>A</code>の最小値と対応する線形インデックスを<code>rval</code>と<code>rind</code>の単一次元に沿って見つけ、結果を<code>rval</code>と<code>rind</code>に格納します。<code>NaN</code>は<code>missing</code>を除くすべての値よりも小さいと見なされます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L1068-L1076">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum" href="#Base.sum"><code>Base.sum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum(f, itr; [init])</code></pre><p><code>itr</code>の各要素に対して関数<code>f</code>を呼び出した結果を合計します。</p><p>返り値の型は、システムのワードサイズ未満の符号付き整数の場合は<code>Int</code>、システムのワードサイズ未満の符号なし整数の場合は<code>UInt</code>です。その他の引数については、すべての引数が昇格される共通の返り値の型が見つかります。</p><p>空の<code>itr</code>に対して返される値は<code>init</code>で指定できます。<code>init</code>は加法的単位（すなわちゼロ）でなければならず、非空のコレクションに対して<code>init</code>が使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数<code>init</code>はJulia 1.6以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sum(abs2, [2; 3; 4])
29</code></pre><p>小さな整数のeltypeを持つ配列に対する<code>sum(A)</code>と<code>reduce(+, A)</code>の重要な違いに注意してください：</p><pre><code class="language-julia-repl hljs">julia&gt; sum(Int8[100, 28])
128

julia&gt; reduce(+, Int8[100, 28])
-128</code></pre><p>前者の場合、整数はシステムのワードサイズに拡張されるため、結果は128になります。後者の場合、そのような拡張は行われず、整数のオーバーフローが発生し、-128になります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L495-L531">source</a></section><section><div><pre><code class="language-julia hljs">sum(itr; [init])</code></pre><p>コレクション内のすべての要素の合計を返します。</p><p>返り値の型は、システムのワードサイズ未満の符号付き整数の場合は <code>Int</code>、システムのワードサイズ未満の符号なし整数の場合は <code>UInt</code> です。その他のすべての引数については、すべての引数が昇格される共通の返り値の型が見つかります。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> によって指定できます。これは加法的単位元（すなわちゼロ）でなければならず、<code>init</code> が非空のコレクションに使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数 <code>init</code> は Julia 1.6 以降が必要です。</p></div></div><p>参照: <a href="collections.html#Base.reduce-Tuple{Any, Any}"><code>reduce</code></a>, <a href="collections.html#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>, <a href="collections.html#Base.count"><code>count</code></a>, <a href="collections.html#Base.union"><code>union</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sum(1:20)
210

julia&gt; sum(1:20; init = 0.0)
210.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L534-L560">source</a></section><section><div><pre><code class="language-julia hljs">sum(A::AbstractArray; dims)</code></pre><p>与えられた次元にわたって配列の要素を合計します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; sum(A, dims=1)
1×2 Matrix{Int64}:
 4  6

julia&gt; sum(A, dims=2)
2×1 Matrix{Int64}:
 3
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L449-L470">source</a></section><section><div><pre><code class="language-julia hljs">sum(f, A::AbstractArray; dims)</code></pre><p>配列の各要素に対して関数 <code>f</code> を呼び出した結果を、指定された次元にわたって合計します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; sum(abs2, A, dims=1)
1×2 Matrix{Int64}:
 10  20

julia&gt; sum(abs2, A, dims=2)
2×1 Matrix{Int64}:
  5
 25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L473-L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sum!" href="#Base.sum!"><code>Base.sum!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sum!(r, A)</code></pre><p><code>A</code>の要素を<code>r</code>の単一次元にわたって合計し、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; sum!([1; 1], A)
2-element Vector{Int64}:
 3
 7

julia&gt; sum!([1 1], A)
1×2 Matrix{Int64}:
 4  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L498-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prod" href="#Base.prod"><code>Base.prod</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prod(f, itr; [init])</code></pre><p><code>itr</code>の各要素に適用された<code>f</code>の積を返します。</p><p>返り値の型は、システムのワードサイズ未満の符号付き整数の場合は<code>Int</code>、システムのワードサイズ未満の符号なし整数の場合は<code>UInt</code>です。その他のすべての引数については、すべての引数が昇格される共通の返り値の型が見つかります。</p><p>空の<code>itr</code>に対して返される値は<code>init</code>によって指定できます。<code>init</code>が非空のコレクションに使用されるかどうかは未定義であるため、乗法的単位（すなわち1）でなければなりません。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数<code>init</code>はJulia 1.6以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prod(abs2, [2; 3; 4])
576</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L566-L587">source</a></section><section><div><pre><code class="language-julia hljs">prod(itr; [init])</code></pre><p>コレクションのすべての要素の積を返します。</p><p>返り値の型は、システムのワードサイズ未満の符号付き整数の場合は <code>Int</code>、システムのワードサイズ未満の符号なし整数の場合は <code>UInt</code> です。他のすべての引数については、すべての引数が昇格される共通の返り値の型が見つかります。</p><p>空の <code>itr</code> に対して返される値は <code>init</code> によって指定できます。これは乗法的単位（すなわち1）でなければならず、<code>init</code> が非空のコレクションに使用されるかどうかは未定義です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>キーワード引数 <code>init</code> は Julia 1.6 以降が必要です。</p></div></div><p>参照: <a href="collections.html#Base.reduce-Tuple{Any, Any}"><code>reduce</code></a>, <a href="arrays.html#Base.cumprod"><code>cumprod</code></a>, <a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prod(1:5)
120

julia&gt; prod(1:5; init = 1.0)
120.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L590-L616">source</a></section><section><div><pre><code class="language-julia hljs">prod(A::AbstractArray; dims)</code></pre><p>与えられた次元にわたって配列の要素を掛け算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prod(A, dims=1)
1×2 Matrix{Int64}:
 3  8

julia&gt; prod(A, dims=2)
2×1 Matrix{Int64}:
  2
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L524-L545">source</a></section><section><div><pre><code class="language-julia hljs">prod(f, A::AbstractArray; dims)</code></pre><p>与えられた次元にわたって配列の各要素に対して関数 <code>f</code> を呼び出した結果を掛け算します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prod(abs2, A, dims=1)
1×2 Matrix{Int64}:
 9  64

julia&gt; prod(abs2, A, dims=2)
2×1 Matrix{Int64}:
   4
 144</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L548-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prod!" href="#Base.prod!"><code>Base.prod!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prod!(r, A)</code></pre><p><code>A</code>の要素を<code>r</code>の単一次元にわたって乗算し、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>いかなる変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになる可能性があります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prod!([1; 1], A)
2-element Vector{Int64}:
  2
 12

julia&gt; prod!([1 1], A)
1×2 Matrix{Int64}:
 3  8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L573-L596">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.any-Tuple{Any}" href="#Base.any-Tuple{Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">any(itr) -&gt; Bool</code></pre><p>ブールコレクションの任意の要素が <code>true</code> であるかをテストし、<code>itr</code> 内で最初の <code>true</code> 値が見つかった時点で <code>true</code> を返します（ショートサーキット）。<code>false</code> でショートサーキットするには、<a href="collections.html#Base.all-Tuple{Any}"><code>all</code></a> を使用してください。</p><p>入力に <a href="../manual/missing.html#missing"><code>missing</code></a> 値が含まれている場合、すべての非欠損値が <code>false</code> である場合（または同等に、入力に <code>true</code> 値が含まれていない場合）には <code>missing</code> を返し、<a href="https://en.wikipedia.org/wiki/Three-valued_logic">三値論理</a>に従います。</p><p>関連項目: <a href="collections.html#Base.all-Tuple{Any}"><code>all</code></a>, <a href="collections.html#Base.count"><code>count</code></a>, <a href="collections.html#Base.sum"><code>sum</code></a>, <a href="math.html#Base.:|"><code>|</code></a>, , <a href="math.html#||"><code>||</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [true,false,false,true]
4-element Vector{Bool}:
 1
 0
 0
 1

julia&gt; any(a)
true

julia&gt; any((println(i); v) for (i, v) in enumerate(a))
1
true

julia&gt; any([missing, true])
true

julia&gt; any([false, missing])
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1118-L1153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.any-Tuple{AbstractArray, Any}" href="#Base.any-Tuple{AbstractArray, Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">any(p, itr) -&gt; Bool</code></pre><p>述語 <code>p</code> が <code>itr</code> の任意の要素に対して <code>true</code> を返すかどうかを判定し、<code>p</code> が <code>true</code> を返す <code>itr</code> の最初のアイテムに出会った時点で <code>true</code> を返します（ショートサーキット）。<code>false</code> に対してショートサーキットを行うには、<a href="collections.html#Base.all-Tuple{Any}"><code>all</code></a> を使用してください。</p><p>入力に <a href="../manual/missing.html#missing"><code>missing</code></a> 値が含まれている場合、すべての非欠損値が <code>false</code> である場合（または同等に、入力に <code>true</code> 値が含まれていない場合）には <code>missing</code> を返します。これは <a href="https://en.wikipedia.org/wiki/Three-valued_logic">三値論理</a> に従います。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; any(i-&gt;(4&lt;=i&lt;=6), [3,5,7])
true

julia&gt; any(i -&gt; (println(i); i &gt; 3), 1:10)
1
2
3
4
true

julia&gt; any(i -&gt; i &gt; 0, [1, missing])
true

julia&gt; any(i -&gt; i &gt; 0, [-1, missing])
missing

julia&gt; any(i -&gt; i &gt; 0, [-1, 0])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1195-L1227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.any!" href="#Base.any!"><code>Base.any!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">any!(r, A)</code></pre><p><code>A</code>の中の値が<code>r</code>の単一次元に沿って<code>true</code>であるかどうかをテストし、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; any!([1; 1], A)
2-element Vector{Int64}:
 1
 1

julia&gt; any!([1 1], A)
1×2 Matrix{Int64}:
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L949-L973">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.all-Tuple{Any}" href="#Base.all-Tuple{Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all(itr) -&gt; Bool</code></pre><p>ブールコレクションのすべての要素が <code>true</code> であるかどうかをテストし、<code>itr</code> で最初の <code>false</code> 値が見つかるとすぐに <code>false</code> を返します（ショートサーキット）。<code>true</code> でショートサーキットするには、<a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a> を使用してください。</p><p>入力に <a href="../manual/missing.html#missing"><code>missing</code></a> 値が含まれている場合、すべての非欠損値が <code>true</code> である場合（または同等に、入力に <code>false</code> 値が含まれていない場合）、<a href="https://en.wikipedia.org/wiki/Three-valued_logic">三値論理</a>に従って <code>missing</code> を返します。</p><p>関連項目: <a href="collections.html#Base.all!"><code>all!</code></a>, <a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a>, <a href="collections.html#Base.count"><code>count</code></a>, <a href="math.html#Base.:&amp;"><code>&amp;</code></a>, , <a href="math.html#&amp;&amp;"><code>&amp;&amp;</code></a>, <a href="collections.html#Base.allunique"><code>allunique</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [true,false,false,true]
4-element Vector{Bool}:
 1
 0
 0
 1

julia&gt; all(a)
false

julia&gt; all((println(i); v) for (i, v) in enumerate(a))
1
2
false

julia&gt; all([missing, false])
false

julia&gt; all([true, missing])
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1156-L1192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.all-Tuple{AbstractArray, Any}" href="#Base.all-Tuple{AbstractArray, Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all(p, itr) -&gt; Bool</code></pre><p>述語 <code>p</code> が <code>itr</code> のすべての要素に対して <code>true</code> を返すかどうかを判定し、<code>p</code> が <code>false</code> を返す最初のアイテムが <code>itr</code> で見つかった時点で <code>false</code> を返します（ショートサーキット）。<code>true</code> でショートサーキットするには、<a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a> を使用してください。</p><p>入力に <a href="../manual/missing.html#missing"><code>missing</code></a> 値が含まれている場合、すべての非欠損値が <code>true</code> である場合（または同等に、入力に <code>false</code> 値が含まれていない場合）には <code>missing</code> を返します。これは <a href="https://en.wikipedia.org/wiki/Three-valued_logic">三値論理</a> に従います。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; all(i-&gt;(4&lt;=i&lt;=6), [4,5,6])
true

julia&gt; all(i -&gt; (println(i); i &lt; 3), 1:10)
1
2
3
false

julia&gt; all(i -&gt; i &gt; 0, [1, missing])
missing

julia&gt; all(i -&gt; i &gt; 0, [-1, missing])
false

julia&gt; all(i -&gt; i &gt; 0, [1, 2])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1269-L1300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.all!" href="#Base.all!"><code>Base.all!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all!(r, A)</code></pre><p><code>A</code>の単一次元に沿ったすべての値が<code>true</code>であるかをテストし、結果を<code>r</code>に書き込みます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; all!([1; 1], A)
2-element Vector{Int64}:
 0
 0

julia&gt; all!([1 1], A)
1×2 Matrix{Int64}:
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L875-L898">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.count" href="#Base.count"><code>Base.count</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">count([f=identity,] itr; init=0) -&gt; Integer</code></pre><p><code>f</code> が <code>true</code> を返す <code>itr</code> の要素の数をカウントします。<code>f</code> が省略された場合、<code>itr</code> の <code>true</code> 要素の数をカウントします（これはブール値のコレクションである必要があります）。<code>init</code> はカウントを開始する値を指定するオプションであり、出力の型も決定します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>init</code> キーワードは Julia 1.6 で追加されました。</p></div></div><p>参照: <a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a>, <a href="collections.html#Base.sum"><code>sum</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count(i-&gt;(4&lt;=i&lt;=6), [2,3,4,5,6])
3

julia&gt; count([true, false, true, true])
3

julia&gt; count(&gt;(3), 1:7, init=0x03)
0x07</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L1348-L1372">source</a></section><section><div><pre><code class="language-julia hljs">count(
    pattern::Union{AbstractChar,AbstractString,AbstractPattern},
    string::AbstractString;
    overlap::Bool = false,
)</code></pre><p><code>string</code>内の<code>pattern</code>の一致数を返します。これは<code>length(findall(pattern, string))</code>を呼び出すのと同等ですが、より効率的です。</p><p><code>overlap=true</code>の場合、一致するシーケンスは元の文字列のインデックスで重複することが許可されます。そうでない場合、重複しない文字範囲からでなければなりません。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>このメソッドは少なくともJulia 1.3が必要です。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>パターンとして文字を使用するには、少なくともJulia 1.7が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count(&#39;a&#39;, &quot;JuliaLang&quot;)
2

julia&gt; count(r&quot;a(.)a&quot;, &quot;cabacabac&quot;, overlap=true)
3

julia&gt; count(r&quot;a(.)a&quot;, &quot;cabacabac&quot;)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/regex.jl#L519-L549">source</a></section><section><div><pre><code class="language-julia hljs">count([f=identity,] A::AbstractArray; dims=:)</code></pre><p><code>f</code> が <code>true</code> を返す <code>A</code> の要素の数を、指定された次元にわたってカウントします。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>dims</code> キーワードは Julia 1.5 で追加されました。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>init</code> キーワードは Julia 1.6 で追加されました。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; count(&lt;=(2), A, dims=1)
1×2 Matrix{Int64}:
 1  1

julia&gt; count(&lt;=(2), A, dims=2)
2×1 Matrix{Int64}:
 2
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reducedim.jl#L382-L410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.foreach" href="#Base.foreach"><code>Base.foreach</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">foreach(f, c...) -&gt; Nothing</code></pre><p>イテラブル <code>c</code> の各要素に対して関数 <code>f</code> を呼び出します。複数のイテラブル引数がある場合、<code>f</code> は要素ごとに呼び出され、いずれかのイテレータが終了するとイテレーションが停止します。</p><p><code>f</code> の結果が必要ない場合は、<code>foreach(println, array)</code> のように <a href="collections.html#Base.map"><code>map</code></a> の代わりに <code>foreach</code> を使用するべきです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tri = 1:3:7; res = Int[];

julia&gt; foreach(x -&gt; push!(res, x^2), tri)

julia&gt; res
3-element Vector{Int64}:
  1
 16
 49

julia&gt; foreach((x, y) -&gt; println(x, &quot; with &quot;, y), tri, &#39;a&#39;:&#39;z&#39;)
1 with a
4 with b
7 with c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L3159-L3186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map(f, c...) -&gt; collection</code></pre><p>コレクション <code>c</code> を変換し、各要素に <code>f</code> を適用します。複数のコレクション引数がある場合、要素ごとに <code>f</code> を適用し、いずれかが尽きた時点で停止します。</p><p>他にも <a href="collections.html#Base.map!"><code>map!</code></a>、<a href="collections.html#Base.foreach"><code>foreach</code></a>、<a href="collections.html#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>、<a href="arrays.html#Base.mapslices"><code>mapslices</code></a>、<a href="iterators.html#Base.Iterators.zip"><code>zip</code></a>、<a href="iterators.html#Base.Iterators.map"><code>Iterators.map</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; map(x -&gt; x * 2, [1, 2, 3])
3-element Vector{Int64}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30, 400, 5000])
3-element Vector{Int64}:
 11
 22
 33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L3376-L3398">source</a></section><section><div><pre><code class="language-julia hljs">map(f, A::AbstractArray...) -&gt; N-array</code></pre><p>同じ <a href="arrays.html#Base.ndims"><code>ndims</code></a> の多次元配列に作用する場合、それらはすべて同じ <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a> を持っている必要があり、結果も同様になります。</p><p>サイズが不一致の <a href="arrays.html#Base.Broadcast.broadcast"><code>broadcast</code></a> も参照してください。</p><p><strong>例</strong></p><pre><code class="nohighlight hljs">julia&gt; map(//, [1 2; 3 4], [4 3; 2 1])
2×2 Matrix{Rational{Int64}}:
 1//4  2//3
 3//2  4//1

julia&gt; map(+, [1 2; 3 4], zeros(2,1))
ERROR: DimensionMismatch

julia&gt; map(+, [1 2; 3 4], [1,10,100,1000], zeros(3,1))  # 3番目が尽きるまで反復
3-element Vector{Float64}:
   2.0
  13.0
 102.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L3470-L3494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.map!" href="#Base.map!"><code>Base.map!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map!(function, destination, collection...)</code></pre><p><a href="collections.html#Base.map"><code>map</code></a>と同様ですが、新しいコレクションではなく<code>destination</code>に結果を格納します。<code>destination</code>は最小のコレクションと同じかそれ以上の大きさでなければなりません。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>いずれかの変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p>参照: <a href="collections.html#Base.map"><code>map</code></a>, <a href="collections.html#Base.foreach"><code>foreach</code></a>, <a href="iterators.html#Base.Iterators.zip"><code>zip</code></a>, <a href="c.html#Base.copyto!"><code>copyto!</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = zeros(3);

julia&gt; map!(x -&gt; x * 2, a, [1, 2, 3]);

julia&gt; a
3-element Vector{Float64}:
 2.0
 4.0
 6.0

julia&gt; map!(+, zeros(Int, 5), 100:999, 1:3)
5-element Vector{Int64}:
 101
 103
 105
   0
   0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L3433-L3463">source</a></section><section><div><pre><code class="language-julia hljs">map!(f, values(dict::AbstractDict))</code></pre><p><code>dict</code>を修正し、各値を<code>val</code>から<code>f(val)</code>に変換します。<code>dict</code>の型は変更できないことに注意してください：<code>f(val)</code>が<code>dict</code>の値の型のインスタンスでない場合、可能であれば値の型に変換され、それ以外の場合はエラーが発生します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p><code>map!(f, values(dict::AbstractDict))</code>はJulia 1.2以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2)
Dict{Symbol, Int64} with 2 entries:
  :a =&gt; 1
  :b =&gt; 2

julia&gt; map!(v -&gt; v-1, values(d))
ValueIterator for a Dict{Symbol, Int64} with 2 entries. Values:
  0
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L648-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mapreduce-Tuple{Any, Any, Any}" href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>Base.mapreduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapreduce(f, op, itrs...; [init])</code></pre><p>関数 <code>f</code> を <code>itrs</code> の各要素に適用し、その後、結果を二項関数 <code>op</code> を使用して縮約します。提供されている場合、<code>init</code> は空のコレクションに対して返される <code>op</code> の中立要素でなければなりません。<code>init</code> が非空のコレクションに使用されるかどうかは不明です。一般的に、空のコレクションで作業するには <code>init</code> を提供する必要があります。</p><p><a href="collections.html#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a> は、<code>reduce(op, map(f, itr); init=init)</code> を呼び出すのと機能的に同等ですが、一般的には中間コレクションを作成する必要がないため、より高速に実行されます。<a href="collections.html#Base.reduce-Tuple{Any, Any}"><code>reduce</code></a> と <a href="collections.html#Base.map"><code>map</code></a> のドキュメントを参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>複数のイテレータを持つ <code>mapreduce</code> は、Julia 1.2 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mapreduce(x-&gt;x^2, +, [1:3;]) # == 1 + 4 + 9
14</code></pre><p>縮約の結合性は実装に依存します。さらに、一部の実装では、<code>itr</code> に複数回現れる要素に対して <code>f</code> の戻り値を再利用する場合があります。すべての値に対して <code>f</code> を呼び出し、左または右の結合性を保証するには、<a href="collections.html#Base.mapfoldl-Tuple{Any, Any, Any}"><code>mapfoldl</code></a> または <a href="collections.html#Base.mapfoldr-Tuple{Any, Any, Any}"><code>mapfoldr</code></a> を使用してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L280-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mapfoldl-Tuple{Any, Any, Any}" href="#Base.mapfoldl-Tuple{Any, Any, Any}"><code>Base.mapfoldl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapfoldl(f, op, itr; [init])</code></pre><p><a href="collections.html#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>と同様ですが、<a href="collections.html#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a>のように左結合性が保証されています。指定された場合、キーワード引数<code>init</code>は正確に1回使用されます。一般的に、空のコレクションで作業するには<code>init</code>を提供する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mapfoldr-Tuple{Any, Any, Any}" href="#Base.mapfoldr-Tuple{Any, Any, Any}"><code>Base.mapfoldr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapfoldr(f, op, itr; [init])</code></pre><p><a href="collections.html#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>と同様ですが、<a href="collections.html#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a>のように右結合性が保証されています。提供された場合、キーワード引数<code>init</code>は正確に1回使用されます。一般的に、空のコレクションで作業するには<code>init</code>を提供する必要があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/reduce.jl#L216-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">first(coll)</code></pre><p>イテラブルコレクションの最初の要素を取得します。空であっても<a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a>の開始点を返します。</p><p>関連情報: <a href="iterators.html#Base.Iterators.only"><code>only</code></a>, <a href="collections.html#Base.firstindex"><code>firstindex</code></a>, <a href="collections.html#Base.last"><code>last</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first(2:2:10)
2

julia&gt; first([1; 2; 3; 4])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L454-L470">source</a></section><section><div><pre><code class="language-julia hljs">first(itr, n::Integer)</code></pre><p>イテラブルコレクション <code>itr</code> の最初の <code>n</code> 要素を取得します。<code>itr</code> が十分に長くない場合は、より少ない要素を取得します。</p><p>関連: <a href="strings.html#Base.startswith"><code>startswith</code></a>, <a href="iterators.html#Base.Iterators.take"><code>Iterators.take</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>このメソッドは少なくとも Julia 1.6 を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first([&quot;foo&quot;, &quot;bar&quot;, &quot;qux&quot;], 2)
2-element Vector{String}:
 &quot;foo&quot;
 &quot;bar&quot;

julia&gt; first(1:6, 10)
1:6

julia&gt; first(Bool[], 1)
Bool[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L477-L501">source</a></section><section><div><pre><code class="language-julia hljs">first(s::AbstractString, n::Integer)</code></pre><p><code>s</code>の最初の<code>n</code>文字からなる文字列を取得します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;∀&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;∀ϵ≠&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/strings/basic.jl#L690-L706">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">last(coll)</code></pre><p>順序付きコレクションの最後の要素を取得します。これはO(1)時間で計算できる場合に限ります。これは、<a href="collections.html#Base.lastindex"><code>lastindex</code></a>を呼び出して最後のインデックスを取得することで実現されます。空であっても、<a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a>の終点を返します。</p><p>他に<a href="collections.html#Base.first"><code>first</code></a>、<a href="strings.html#Base.endswith"><code>endswith</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; last(1:2:10)
9

julia&gt; last([1; 2; 3; 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L509-L526">source</a></section><section><div><pre><code class="language-julia hljs">last(itr, n::Integer)</code></pre><p>イテラブルコレクション <code>itr</code> の最後の <code>n</code> 要素を取得します。<code>itr</code> が十分に長くない場合は、より少ない要素が返されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>このメソッドは少なくとも Julia 1.6 を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; last([&quot;foo&quot;, &quot;bar&quot;, &quot;qux&quot;], 2)
2-element Vector{String}:
 &quot;bar&quot;
 &quot;qux&quot;

julia&gt; last(1:6, 10)
1:6

julia&gt; last(Float64[], 1)
Float64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L529-L551">source</a></section><section><div><pre><code class="language-julia hljs">last(s::AbstractString, n::Integer)</code></pre><p>文字列 <code>s</code> の最後の <code>n</code> 文字からなる文字列を取得します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;0&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;²&gt;0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/strings/basic.jl#L709-L725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.front" href="#Base.front"><code>Base.front</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">front(x::Tuple)::Tuple</code></pre><p><code>x</code>の最後の要素を除いたすべての要素からなる<code>Tuple</code>を返します。</p><p>関連: <a href="collections.html#Base.first"><code>first</code></a>, <a href="collections.html#Base.tail"><code>tail</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.front((1,2,3))
(1, 2)

julia&gt; Base.front(())
ERROR: ArgumentError: Cannot call front on an empty tuple.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/tuple.jl#L324-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.tail" href="#Base.tail"><code>Base.tail</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tail(x::Tuple)::Tuple</code></pre><p><code>x</code>の最初のコンポーネントを除くすべてのコンポーネントからなる<code>Tuple</code>を返します。</p><p>参照: <a href="collections.html#Base.front"><code>front</code></a>, <a href="collections.html#Base.rest"><code>rest</code></a>, <a href="collections.html#Base.first"><code>first</code></a>, <a href="iterators.html#Base.Iterators.peel"><code>Iterators.peel</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.tail((1,2,3))
(2, 3)

julia&gt; Base.tail(())
ERROR: ArgumentError: Cannot call tail on an empty tuple.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L498-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.step" href="#Base.step"><code>Base.step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">step(r)</code></pre><p><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a> オブジェクトのステップサイズを取得します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; step(1:10)
1

julia&gt; step(1:2:10)
2

julia&gt; step(2.5:0.3:10.9)
0.3

julia&gt; step(range(2.5, stop=10.9, length=85))
0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/range.jl#L685-L704">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.collect-Tuple{Any}" href="#Base.collect-Tuple{Any}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect(collection)</code></pre><p>コレクションまたはイテレータ内のすべてのアイテムの <code>Array</code> を返します。辞書の場合、<code>key=&gt;value</code> <a href="collections.html#Core.Pair">Pair</a> の <code>Vector</code> を返します。引数が配列のようであるか、<a href="collections.html#Base.IteratorSize"><code>HasShape</code></a> 特性を持つイテレータである場合、結果は引数と同じ形状および次元数を持ちます。</p><p><a href="../manual/arrays.html#man-comprehensions">comprehensions</a> によって、<a href="../manual/arrays.html#man-generators">generator expression</a> を <code>Array</code> に変換するために使用されます。したがって、<em>ジェネレータに対して</em>、角括弧の表記法を使用することができ、<code>collect</code> を呼び出す代わりに使用できます。2番目の例を参照してください。</p><p><strong>例</strong></p><p><code>UnitRange{Int64}</code> コレクションからアイテムを収集します：</p><pre><code class="language-julia-repl hljs">julia&gt; collect(1:3)
3-element Vector{Int64}:
 1
 2
 3</code></pre><p>ジェネレータからアイテムを収集します（出力は <code>[x^2 for x in 1:3]</code> と同じです）：</p><pre><code class="language-julia-repl hljs">julia&gt; collect(x^2 for x in 1:3)
3-element Vector{Int64}:
 1
 4
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L682-L715">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.collect-Tuple{Type, Any}" href="#Base.collect-Tuple{Type, Any}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collect(element_type, collection)</code></pre><p>コレクションまたはイテラブル内のすべてのアイテムの指定された要素タイプを持つ <code>Array</code> を返します。結果は <code>collection</code> と同じ形状と次元数を持ちます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(Float64, 1:2:5)
3-element Vector{Float64}:
 1.0
 3.0
 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L632-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter(f, a)</code></pre><p>コレクション <code>a</code> のコピーを返し、<code>f</code> が <code>false</code> の要素を削除します。関数 <code>f</code> には1つの引数が渡されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p><code>a</code> をタプルとしてサポートするには、少なくともJulia 1.4が必要です。</p></div></div><p>参照: <a href="collections.html#Base.filter!"><code>filter!</code></a>, <a href="iterators.html#Base.Iterators.filter"><code>Iterators.filter</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1:10
1:10

julia&gt; filter(isodd, a)
5-element Vector{Int64}:
 1
 3
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L2847-L2871">source</a></section><section><div><pre><code class="language-julia hljs">filter(f)</code></pre><p>関数 <code>f</code> を使用して引数をフィルタリングする関数を作成します。これは、<code>x -&gt; filter(f, x)</code> に相当する関数です。</p><p>返される関数は <code>Base.Fix1{typeof(filter)}</code> 型であり、特化したメソッドを実装するために使用できます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2, Inf, 4, NaN, 6) |&gt; filter(isfinite)
(1, 2, 4, 6)

julia&gt; map(filter(iseven), [1:3, 2:4, 3:5])
3-element Vector{Vector{Int64}}:
 [2]
 [2, 4]
 [4]</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p>このメソッドは少なくとも Julia 1.9 を必要とします。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L2934-L2956">source</a></section><section><div><pre><code class="language-julia hljs">filter(f, d::AbstractDict)</code></pre><p><code>f</code>が<code>false</code>である要素を削除して、<code>d</code>のコピーを返します。関数<code>f</code>には<code>key=&gt;value</code>ペアが渡されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(1=&gt;&quot;a&quot;, 2=&gt;&quot;b&quot;)
Dict{Int64, String} with 2 entries:
  2 =&gt; &quot;b&quot;
  1 =&gt; &quot;a&quot;

julia&gt; filter(p-&gt;isodd(p.first), d)
Dict{Int64, String} with 1 entry:
  1 =&gt; &quot;a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L459-L476">source</a></section><section><div><pre><code class="language-julia hljs">filter(f, itr::SkipMissing{&lt;:AbstractArray})</code></pre><p>与えられた <code>SkipMissing</code> イテレータでラップされた配列に似たベクトルを返しますが、すべての欠損要素と <code>f</code> が <code>false</code> を返す要素は削除されます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>このメソッドは Julia 1.2 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1 2; missing 4]
2×2 Matrix{Union{Missing, Int64}}:
 1         2
  missing  4

julia&gt; filter(isodd, skipmissing(x))
1-element Vector{Int64}:
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/missing.jl#L364-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filter!(f, a)</code></pre><p>コレクション <code>a</code> を更新し、<code>f</code> が <code>false</code> の要素を削除します。関数 <code>f</code> には1つの引数が渡されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; filter!(isodd, Vector(1:10))
5-element Vector{Int64}:
 1
 3
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L2901-L2917">source</a></section><section><div><pre><code class="language-julia hljs">filter!(f, d::AbstractDict)</code></pre><p><code>d</code>を更新し、<code>f</code>が<code>false</code>である要素を削除します。関数<code>f</code>には<code>key=&gt;value</code>ペアが渡されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(1=&gt;&quot;a&quot;, 2=&gt;&quot;b&quot;, 3=&gt;&quot;c&quot;)
Dict{Int64, String} with 3 entries:
  2 =&gt; &quot;b&quot;
  3 =&gt; &quot;c&quot;
  1 =&gt; &quot;a&quot;

julia&gt; filter!(p-&gt;isodd(p.first), d)
Dict{Int64, String} with 2 entries:
  3 =&gt; &quot;c&quot;
  1 =&gt; &quot;a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L417-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.replace-Tuple{Any, Vararg{Pair}}" href="#Base.replace-Tuple{Any, Vararg{Pair}}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace(A, old_new::Pair...; [count::Integer])</code></pre><p>コレクション <code>A</code> のコピーを返します。ここで、<code>old_new</code> の各ペア <code>old=&gt;new</code> に対して、すべての <code>old</code> の出現が <code>new</code> に置き換えられます。等価性は <a href="base.html#Base.isequal"><code>isequal</code></a> を使用して決定されます。<code>count</code> が指定されている場合、合計で最大 <code>count</code> の出現のみが置き換えられます。</p><p>結果の要素型は、<code>A</code> の要素型とペアの <code>new</code> 値の型に基づいて昇格を使用して選択されます（[<code>promote_type</code>](@ref] を参照）。<code>count</code> が省略され、<code>A</code> の要素型が <code>Union</code> の場合、結果の要素型には、異なる型の値で置き換えられる単一型は含まれません。たとえば、<code>Union{T,Missing}</code> は、<code>missing</code> が置き換えられると <code>T</code> になります。</p><p>他にも <a href="collections.html#Base.replace!"><code>replace!</code></a>、<a href="collections.html#Base.splice!"><code>splice!</code></a>、<a href="collections.html#Base.delete!"><code>delete!</code></a>、<a href="collections.html#Base.insert!"><code>insert!</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>要素を <code>Tuple</code> の中で置き換えるには、バージョン 1.7 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace([1, 2, 1, 3], 1=&gt;0, 2=&gt;4, count=2)
4-element Vector{Int64}:
 0
 4
 1
 3

julia&gt; replace([1, missing], missing=&gt;0)
2-element Vector{Int64}:
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L780-L814">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.replace-Tuple{Union{Function, Type}, Any}" href="#Base.replace-Tuple{Union{Function, Type}, Any}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace(new::Union{Function, Type}, A; [count::Integer])</code></pre><p><code>A</code>の各値<code>x</code>を<code>new(x)</code>で置き換えたコピーを返します。<code>count</code>が指定されている場合、合計で最大<code>count</code>の値を置き換えます（置き換えは<code>new(x) !== x</code>として定義されます）。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p><code>Tuple</code>の要素を置き換えるにはバージョン1.7が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace(x -&gt; isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Vector{Int64}:
 2
 2
 6
 4

julia&gt; replace(Dict(1=&gt;2, 3=&gt;4)) do kv
           first(kv) &lt; 3 ? first(kv)=&gt;3 : kv
       end
Dict{Int64, Int64} with 2 entries:
  3 =&gt; 4
  1 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L841-L867">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.replace!" href="#Base.replace!"><code>Base.replace!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace!(A, old_new::Pair...; [count::Integer])</code></pre><p>各ペア <code>old=&gt;new</code> に対して、コレクション <code>A</code> 内の <code>old</code> のすべての出現を <code>new</code> に置き換えます。等価性は <a href="base.html#Base.isequal"><code>isequal</code></a> を使用して決定されます。<code>count</code> が指定されている場合、合計で最大 <code>count</code> 回の出現を置き換えます。詳細は <a href="collections.html#Base.replace-Tuple{Any, Vararg{Pair}}"><code>replace</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace!([1, 2, 1, 3], 1=&gt;0, 2=&gt;4, count=2)
4-element Vector{Int64}:
 0
 4
 1
 3

julia&gt; replace!(Set([1, 2, 3]), 1=&gt;0)
Set{Int64} with 3 elements:
  0
  2
  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L710-L734">source</a></section><section><div><pre><code class="language-julia hljs">replace!(new::Union{Function, Type}, A; [count::Integer])</code></pre><p>コレクション <code>A</code> の各要素 <code>x</code> を <code>new(x)</code> で置き換えます。<code>count</code> が指定されている場合、合計で最大 <code>count</code> の値を置き換えます（置き換えは <code>new(x) !== x</code> と定義されます）。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace!(x -&gt; isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Vector{Int64}:
 2
 2
 6
 4

julia&gt; replace!(Dict(1=&gt;2, 3=&gt;4)) do kv
           first(kv) &lt; 3 ? first(kv)=&gt;3 : kv
       end
Dict{Int64, Int64} with 2 entries:
  3 =&gt; 4
  1 =&gt; 3

julia&gt; replace!(x-&gt;2x, Set([3, 6]))
Set{Int64} with 2 elements:
  6
  12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L748-L776">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rest" href="#Base.rest"><code>Base.rest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.rest(collection[, itr_state])</code></pre><p>特定のイテレーション状態 <code>itr_state</code> から始めて <code>collection</code> の末尾を取得するための汎用関数。<code>collection</code> 自体が <code>Tuple</code> の場合は <code>Tuple</code> を返し、<code>collection</code> が <code>AbstractArray</code> の場合は <code>AbstractVector</code> のサブタイプを返し、<code>collection</code> が <code>AbstractString</code> の場合は <code>AbstractString</code> のサブタイプを返し、それ以外の場合は任意のイテレーターを返し、<code>Iterators.rest(collection[, itr_state])</code> にフォールバックします。</p><p>ユーザー定義のコレクションタイプに対してオーバーロードすることで、最終位置での <a href="../manual/functions.html#destructuring-assignment">スラープによる代入</a> の動作をカスタマイズできます。例えば、<code>a, b... = collection</code> のように。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>Base.rest</code> は少なくとも Julia 1.6 が必要です。</p></div></div><p>参照: <a href="collections.html#Base.first"><code>first</code></a>, <a href="iterators.html#Base.Iterators.rest"><code>Iterators.rest</code></a>, <a href="collections.html#Base.split_rest"><code>Base.split_rest</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; first, state = iterate(a)
(1, 2)

julia&gt; first, Base.rest(a, state)
(1, [3, 2, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/tuple.jl#L172-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.split_rest" href="#Base.split_rest"><code>Base.split_rest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.split_rest(collection, n::Int[, itr_state]) -&gt; (rest_but_n, last_n)</code></pre><p>コレクションの尾を特定のイテレーション状態 <code>itr_state</code> から分割するための汎用関数。2つの新しいコレクションのタプルを返します。最初のコレクションには尾のすべての要素が含まれますが、<code>n</code> 個の最後の要素は2番目のコレクションを構成します。</p><p>最初のコレクションの型は一般的に <a href="collections.html#Base.rest"><code>Base.rest</code></a> の型に従いますが、フォールバックケースは遅延ではなく、ベクターに即座に収集されます。</p><p>ユーザー定義のコレクションタイプに対してオーバーロードすることで、非最終位置での <a href="../manual/functions.html#destructuring-assignment">スラープによる代入</a> の動作をカスタマイズできます。例えば、<code>a, b..., c = collection</code> のように。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.9</header><div class="admonition-body"><p><code>Base.split_rest</code> は少なくとも Julia 1.9 を必要とします。</p></div></div><p>参照: <a href="collections.html#Base.rest"><code>Base.rest</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; first, state = iterate(a)
(1, 2)

julia&gt; first, Base.split_rest(a, 1, state)
(1, ([3, 2], [4]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/tuple.jl#L210-L241">source</a></section></article><h2 id="Indexable-Collections"><a class="docs-heading-anchor" href="#Indexable-Collections">Indexable Collections</a><a id="Indexable-Collections-1"></a><a class="docs-heading-anchor-permalink" href="#Indexable-Collections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(collection, key...)</code></pre><p>指定されたキーまたはインデックスに格納されている値をコレクションから取得します。構文 <code>a[i,j,...]</code> はコンパイラによって <code>getindex(a, i, j, ...)</code> に変換されます。</p><p>関連項目としては <a href="collections.html#Base.get"><code>get</code></a>, <a href="collections.html#Base.keys"><code>keys</code></a>, <a href="arrays.html#Base.eachindex"><code>eachindex</code></a> があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; getindex(A, &quot;a&quot;)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L906-L924">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setindex!(collection, value, key...)</code></pre><p>指定されたキーまたはインデックス内のコレクションに指定された値を格納します。構文 <code>a[i,j,...] = x</code> はコンパイラによって <code>(setindex!(a, x, i, j, ...); x)</code> に変換されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Dict(&quot;a&quot;=&gt;1)
Dict{String, Int64} with 1 entry:
  &quot;a&quot; =&gt; 1

julia&gt; setindex!(a, 2, &quot;b&quot;)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L964-L981">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.firstindex" href="#Base.firstindex"><code>Base.firstindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">firstindex(collection) -&gt; 整数
firstindex(collection, d) -&gt; 整数</code></pre><p><code>collection</code>の最初のインデックスを返します。<code>d</code>が指定されている場合、次元<code>d</code>に沿った<code>collection</code>の最初のインデックスを返します。</p><p>構文<code>A[begin]</code>および<code>A[1, begin]</code>はそれぞれ<code>A[firstindex(A)]</code>および<code>A[1, firstindex(A, 2)]</code>に変換されます。</p><p>参照: <a href="collections.html#Base.first"><code>first</code></a>, <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>, <a href="collections.html#Base.lastindex"><code>lastindex</code></a>, <a href="arrays.html#Base.nextind"><code>nextind</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; firstindex([1,2,4])
1

julia&gt; firstindex(rand(3,4,5), 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L429-L448">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.lastindex" href="#Base.lastindex"><code>Base.lastindex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lastindex(collection) -&gt; Integer
lastindex(collection, d) -&gt; Integer</code></pre><p><code>collection</code>の最後のインデックスを返します。<code>d</code>が指定されている場合、次元<code>d</code>に沿った<code>collection</code>の最後のインデックスを返します。</p><p>構文<code>A[end]</code>および<code>A[end, end]</code>はそれぞれ<code>A[lastindex(A)]</code>および<code>A[lastindex(A, 1), lastindex(A, 2)]</code>に変換されます。</p><p>参照: <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>, <a href="collections.html#Base.firstindex"><code>firstindex</code></a>, <a href="arrays.html#Base.eachindex"><code>eachindex</code></a>, <a href="arrays.html#Base.prevind"><code>prevind</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lastindex([1,2,4])
3

julia&gt; lastindex(rand(3,4,5), 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L406-L425">source</a></section></article><p>完全に実装されました:</p><ul><li><a href="arrays.html#Core.Array"><code>Array</code></a></li><li><a href="arrays.html#Base.BitArray"><code>BitArray</code></a></li><li><a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a></li><li><code>サブ配列</code></li></ul><p>部分的に実装されたのは：</p><ul><li><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a></li><li><a href="collections.html#Base.UnitRange"><code>UnitRange</code></a></li><li><a href="base.html#Core.Tuple"><code>Tuple</code></a></li><li><a href="strings.html#Core.AbstractString"><code>AbstractString</code></a></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li><li><a href="base.html#Core.NamedTuple"><code>NamedTuple</code></a></li></ul><h2 id="Dictionaries"><a class="docs-heading-anchor" href="#Dictionaries">Dictionaries</a><a id="Dictionaries-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionaries" title="Permalink"></a></h2><p><a href="collections.html#Base.Dict"><code>Dict</code></a>は標準辞書です。その実装では、キーのハッシュ関数として<a href="base.html#Base.hash"><code>hash</code></a>を使用し、等価性を決定するために<a href="base.html#Base.isequal"><code>isequal</code></a>を使用します。カスタムタイプのこれら2つの関数を定義して、ハッシュテーブルにどのように格納されるかをオーバーライドします。</p><p><a href="collections.html#Base.IdDict"><code>IdDict</code></a> は、キーが常にオブジェクトのアイデンティティである特別なハッシュテーブルです。</p><p><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a> は、キーがオブジェクトへの弱い参照であるハッシュテーブルの実装であり、ハッシュテーブル内で参照されていてもガーベジコレクションされる可能性があります。<code>Dict</code> と同様に、ハッシュ化には <code>hash</code> を使用し、等価性には <code>isequal</code> を使用しますが、<code>Dict</code> とは異なり、挿入時にキーを変換しません。</p><p><a href="collections.html#Base.Dict"><code>Dict</code></a> は、<code>=&gt;</code> で構築されたペアオブジェクトを <code>4d61726b646f776e2e436f64652822222c2022446963742229_40726566</code> コンストラクタに渡すことで作成できます: <code>Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>。この呼び出しは、キーと値から型情報を推測しようとします（つまり、この例では <code>Dict{String, Int64}</code> が作成されます）。型を明示的に指定するには、構文 <code>Dict{KeyType,ValueType}(...)</code> を使用します。例えば、<code>Dict{String,Int32}(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code> のようになります。</p><p>辞書はジェネレーターを使っても作成できます。例えば、<code>Dict(i =&gt; f(i) for i = 1:10)</code>。</p><p>辞書 <code>D</code> があるとき、構文 <code>D[x]</code> はキー <code>x</code> の値を返します（存在する場合）またはエラーをスローします。また、<code>D[x] = y</code> はキーと値のペア <code>x =&gt; y</code> を <code>D</code> に格納します（キー <code>x</code> の既存の値を置き換えます）。<code>D[...]</code> に対する複数の引数はタプルに変換されます。たとえば、構文 <code>D[x,y]</code> は <code>D[(x,y)]</code> と同等であり、タプル <code>(x,y)</code> によってキー付けされた値を参照します。</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractDict" href="#Base.AbstractDict"><code>Base.AbstractDict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractDict{K, V}</code></pre><p>キーの型が <code>K</code> で値の型が <code>V</code> の辞書のような型のスーパタイプです。 <a href="collections.html#Base.Dict"><code>Dict</code></a>、<a href="collections.html#Base.IdDict"><code>IdDict</code></a> およびその他の型はこれのサブタイプです。 <code>AbstractDict{K, V}</code> は <code>Pair{K, V}</code> のイテレータであるべきです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Dict" href="#Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Dict([itr])</code></pre><p><code>Dict{K,V}()</code> は、型 <code>K</code> のキーと型 <code>V</code> の値を持つハッシュテーブルを構築します。キーは <a href="base.html#Base.isequal"><code>isequal</code></a> で比較され、<a href="base.html#Base.hash"><code>hash</code></a> でハッシュ化されます。</p><p>単一のイテラブル引数を与えると、引数によって生成された 2-タプル <code>(key,value)</code> からキーと値のペアを取る <a href="collections.html#Base.Dict"><code>Dict</code></a> が構築されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Dict([(&quot;A&quot;, 1), (&quot;B&quot;, 2)])
Dict{String, Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre><p>また、ペア引数のシーケンスを渡すこともできます。</p><pre><code class="language-julia-repl hljs">julia&gt; Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)
Dict{String, Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>キーは可変であることが許可されていますが、保存されたキーを変更すると、ハッシュテーブルが内部的に不整合になる可能性があり、その場合 <code>Dict</code> は正しく機能しません。キーを変更する必要がある場合は、<a href="collections.html#Base.IdDict"><code>IdDict</code></a> が代替手段となることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L31-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IdDict" href="#Base.IdDict"><code>Base.IdDict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdDict([itr])</code></pre><p><code>IdDict{K,V}()</code> は、<a href="base.html#Base.objectid"><code>objectid</code></a> をハッシュとして、<code>===</code> を等価性として使用し、型 <code>K</code> のキーと型 <code>V</code> の値を持つハッシュテーブルを構築します。さらなるヘルプについては <a href="collections.html#Base.Dict"><code>Dict</code></a> を参照し、このバージョンのセットについては <a href="collections.html#Base.IdSet"><code>IdSet</code></a> を参照してください。</p><p>以下の例では、<code>Dict</code> のキーはすべて <code>isequal</code> であり、したがって同じようにハッシュされ、上書きされます。<code>IdDict</code> はオブジェクトIDでハッシュされるため、3つの異なるキーを保持します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Dict(true =&gt; &quot;yes&quot;, 1 =&gt; &quot;no&quot;, 1.0 =&gt; &quot;maybe&quot;)
Dict{Real, String} with 1 entry:
  1.0 =&gt; &quot;maybe&quot;

julia&gt; IdDict(true =&gt; &quot;yes&quot;, 1 =&gt; &quot;no&quot;, 1.0 =&gt; &quot;maybe&quot;)
IdDict{Any, String} with 3 entries:
  true =&gt; &quot;yes&quot;
  1.0  =&gt; &quot;maybe&quot;
  1    =&gt; &quot;no&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/iddict.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.WeakKeyDict" href="#Base.WeakKeyDict"><code>Base.WeakKeyDict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeakKeyDict([itr])</code></pre><p><code>WeakKeyDict()</code> は、キーがオブジェクトへの弱い参照であるハッシュテーブルを構築します。これにより、ハッシュテーブル内で参照されていても、オブジェクトはガーベジコレクトされる可能性があります。</p><p>さらなるヘルプについては、<a href="collections.html#Base.Dict"><code>Dict</code></a> を参照してください。なお、<a href="collections.html#Base.Dict"><code>Dict</code></a> とは異なり、<code>WeakKeyDict</code> は挿入時にキーを変換しません。これは、キーオブジェクトが挿入前にどこにも参照されていなかったことを意味します。</p><p>また、<a href="base.html#Core.WeakRef"><code>WeakRef</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/weakkeydict.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.ImmutableDict" href="#Base.ImmutableDict"><code>Base.ImmutableDict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImmutableDict</code></pre><p><code>ImmutableDict</code>は、不変のリンクリストとして実装された辞書であり、多くの個別の挿入を通じて構築される小さな辞書に最適です。値を削除することはできませんが、同じキーで新しい値を挿入することで部分的に上書きしたり隠したりすることができます。</p><pre><code class="nohighlight hljs">ImmutableDict(KV::Pair)</code></pre><p><code>key =&gt; value</code>ペアのために<code>ImmutableDict</code>に新しいエントリを作成します。</p><ul><li><code>(key =&gt; value) in dict</code>を使用して、この特定の組み合わせがプロパティセットに含まれているかどうかを確認します。</li><li><code>get(dict, key, default)</code>を使用して、特定のキーに対する最新の値を取得します。</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L778-L793">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.PersistentDict" href="#Base.PersistentDict"><code>Base.PersistentDict</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PersistentDict</code></pre><p><code>PersistentDict</code> はハッシュ配列マップトライとして実装された辞書で、永続性が必要な状況に最適です。各操作は前の辞書とは別の新しい辞書を返しますが、基盤となる実装は空間効率が良く、複数の別々の辞書間でストレージを共有することがあります。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>IdDictのように振る舞います。</p></div></div><pre><code class="language-julia hljs">PersistentDict(KV::Pair)</code></pre><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dict = Base.PersistentDict(:a=&gt;1)
Base.PersistentDict{Symbol, Int64} with 1 entry:
  :a =&gt; 1

julia&gt; dict2 = Base.delete(dict, :a)
Base.PersistentDict{Symbol, Int64}()

julia&gt; dict3 = Base.PersistentDict(dict, :a=&gt;2)
Base.PersistentDict{Symbol, Int64} with 1 entry:
  :a =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L907-L937">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.haskey" href="#Base.haskey"><code>Base.haskey</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haskey(collection, key) -&gt; Bool</code></pre><p>コレクションが指定された <code>key</code> に対するマッピングを持っているかどうかを判断します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; haskey(D, &#39;a&#39;)
true

julia&gt; haskey(D, &#39;c&#39;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L529-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get(collection, key, default)</code></pre><p>指定されたキーに対して保存されている値を返します。キーに対するマッピングが存在しない場合は、指定されたデフォルト値を返します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>タプルと数値の場合、この関数は少なくともJulia 1.7を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L480-L499">source</a></section><section><div><pre><code class="language-julia hljs">get(f::Union{Function, Type}, collection, key)</code></pre><p>指定されたキーに対して保存されている値を返します。キーに対するマッピングが存在しない場合は、<code>f()</code>を返します。デフォルト値を辞書に保存するには、<a href="collections.html#Base.get!"><code>get!</code></a>を使用してください。</p><p>これは<code>do</code>ブロック構文を使用して呼び出すことを意図しています。</p><pre><code class="language-julia hljs">get(dict, key) do
    # ここでデフォルト値を計算
    time()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L507-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.get!" href="#Base.get!"><code>Base.get!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get!(collection, key, default)</code></pre><p>指定されたキーに対して保存されている値を返します。キーに対するマッピングが存在しない場合は、<code>key =&gt; default</code>を保存し、<code>default</code>を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; get!(d, &quot;a&quot;, 5)
1

julia&gt; get!(d, &quot;d&quot;, 4)
4

julia&gt; d
Dict{String, Int64} with 4 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1
  &quot;d&quot; =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L385-L408">source</a></section><section><div><pre><code class="language-julia hljs">get!(f::Union{Function, Type}, collection, key)</code></pre><p>指定されたキーに対して保存されている値を返します。キーに対するマッピングが存在しない場合は、<code>key =&gt; f()</code>を保存し、<code>f()</code>を返します。</p><p>これは<code>do</code>ブロック構文を使用して呼び出すことを意図しています。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; squares = Dict{Int, Int}();

julia&gt; function get_square!(d, i)
           get!(d, i) do
               i^2
           end
       end
get_square! (generic function with 1 method)

julia&gt; get_square!(squares, 2)
4

julia&gt; squares
Dict{Int64, Int64} with 1 entry:
  2 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L411-L437">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getkey" href="#Base.getkey"><code>Base.getkey</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getkey(collection, key, default)</code></pre><p>引数 <code>key</code> に一致するキーが <code>collection</code> に存在する場合はそのキーを返し、そうでない場合は <code>default</code> を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; getkey(D, &#39;a&#39;, 1)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; getkey(D, &#39;d&#39;, &#39;a&#39;)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L551-L569">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete!(collection, key)</code></pre><p>指定されたキーに対するマッピングをコレクションから削除し、コレクションを返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;)
Dict{String, Int64} with 1 entry:
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;) # dは変更されません
Dict{String, Int64} with 1 entry:
  &quot;a&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L651-L671">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!-Tuple{Any, Any, Any}" href="#Base.pop!-Tuple{Any, Any, Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pop!(collection, key[, default])</code></pre><p><code>collection</code>に<code>key</code>が存在する場合は、そのマッピングを削除して返します。存在しない場合は<code>default</code>を返すか、<code>default</code>が指定されていない場合はエラーをスローします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L586-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keys(iterator)</code></pre><p>キーと値を持つイテレータまたはコレクション（例えば、配列や辞書）に対して、キーのイテレータを返します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">values(iterator)</code></pre><p>キーと値を持つイテレータまたはコレクションに対して、値のイテレータを返します。この関数はデフォルトで引数をそのまま返します。一般的なイテレータの要素は通常「値」と見なされるためです。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; values(d)
ValueIterator for a Dict{String, Int64} with 2 entries. Values:
  2
  1

julia&gt; values([2])
1-element Vector{Int64}:
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L1124-L1145">source</a></section><section><div><pre><code class="language-julia hljs">values(a::AbstractDict)</code></pre><p>コレクション内のすべての値に対するイテレータを返します。 <code>collect(values(a))</code> は値の配列を返します。値が内部的にハッシュテーブルに格納されている場合、<code>Dict</code> のように、返される順序は異なる場合があります。しかし、<code>keys(a)</code>、<code>values(a)</code> および <code>pairs(a)</code> はすべて <code>a</code> をイテレートし、同じ順序で要素を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; collect(values(D))
2-element Vector{Int64}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L109-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pairs(IndexLinear(), A)
pairs(IndexCartesian(), A)
pairs(IndexStyle(A), A)</code></pre><p>配列 <code>A</code> の各要素にアクセスするイテレータで、<code>i =&gt; x</code> を返します。ここで、<code>i</code> は要素のインデックスで、<code>x = A[i]</code> です。<code>pairs(A)</code> と同じですが、インデックスのスタイルを選択できます。また、<code>enumerate(A)</code> に似ていますが、<code>i</code> は <code>A</code> の有効なインデックスであり、<code>enumerate</code> は常に 1 からカウントします。</p><p><a href="arrays.html#Base.IndexLinear"><code>IndexLinear()</code></a> を指定すると、<code>i</code> は整数になります。<a href="arrays.html#Base.IndexCartesian"><code>IndexCartesian()</code></a> を指定すると、<code>i</code> は <a href="arrays.html#Base.IteratorsMD.CartesianIndex"><code>Base.CartesianIndex</code></a> になります。<code>IndexStyle(A)</code> を指定すると、配列 <code>A</code> のネイティブインデックススタイルとして定義されているものが選択されます。</p><p>基になる配列の境界を変更すると、このイテレータは無効になります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [&quot;a&quot; &quot;d&quot;; &quot;b&quot; &quot;e&quot;; &quot;c&quot; &quot;f&quot;];

julia&gt; for (index, value) in pairs(IndexStyle(A), A)
           println(&quot;$index $value&quot;)
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia&gt; S = view(A, 1:2, :);

julia&gt; for (index, value) in pairs(IndexStyle(S), S)
           println(&quot;$index $value&quot;)
       end
CartesianIndex(1, 1) a
CartesianIndex(2, 1) b
CartesianIndex(1, 2) d
CartesianIndex(2, 2) e</code></pre><p>他にも <a href="arrays.html#Base.IndexStyle"><code>IndexStyle</code></a>、<a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a> を参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/iterators.jl#L228-L273">source</a></section><section><div><pre><code class="language-julia hljs">pairs(collection)</code></pre><p>任意のコレクションに対して <code>key =&gt; value</code> ペアのイテレータを返します。これは、キーのセットを値のセットにマッピングするコレクションを含みます。配列の場合、キーは配列のインデックスです。エントリが内部的にハッシュテーブルに格納されている場合（<code>Dict</code> の場合など）、返される順序は異なる場合があります。しかし、<code>keys(a)</code>、<code>values(a)</code>、および <code>pairs(a)</code> はすべて <code>a</code> を反復処理し、同じ順序で要素を返します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Dict(zip([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [1, 2, 3]))
Dict{String, Int64} with 3 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; pairs(a)
Dict{String, Int64} with 3 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; foreach(println, pairs([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
1 =&gt; &quot;a&quot;
2 =&gt; &quot;b&quot;
3 =&gt; &quot;c&quot;

julia&gt; (;a=1, b=2, c=3) |&gt; pairs |&gt; collect
3-element Vector{Pair{Symbol, Int64}}:
 :a =&gt; 1
 :b =&gt; 2
 :c =&gt; 3

julia&gt; (;a=1, b=2, c=3) |&gt; collect
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L135-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge(initial::Face, others::Face...)</code></pre><p><code>initial</code> フェイスと <code>others</code> のプロパティをマージし、後のフェイスが優先されます。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/056e843b2d428bb9735b03af0cff97e738ac7e14/src/faces.jl#L496-L501">source</a></section><section><div><pre><code class="language-julia hljs">merge(d::AbstractDict, others::AbstractDict...)</code></pre><p>与えられたコレクションからマージされたコレクションを構築します。必要に応じて、結果のコレクションの型はマージされたコレクションの型に合わせて昇格されます。同じキーが別のコレクションに存在する場合、そのキーの値は最後にリストされたコレクションにある値になります。同じキーを持つ値のカスタム処理については、<a href="collections.html#Base.mergewith"><code>mergewith</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String, Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String, Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; merge(a, b)
Dict{String, Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4711.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; merge(b, a)
Dict{String, Float64} with 3 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L325-L358">source</a></section><section><div><pre><code class="language-julia hljs">merge(a::NamedTuple, bs::NamedTuple...)</code></pre><p>2つ以上の既存の名前付きタプルを左結合的にマージして新しい名前付きタプルを構築します。マージは、名前付きタプルのペア間で左から右に進行し、最も左と最も右の名前付きタプルの両方に存在するフィールドの順序は、最も左の名前付きタプルに見つかった位置と同じになります。ただし、値は、そのフィールドを含む最も右の名前付きタプルの一致するフィールドから取得されます。ペアの最も右の名前付きタプルにのみ存在するフィールドは、最後に追加されます。シグネチャ <code>merge(a::NamedTuple)</code> を持つ単一の名前付きタプルのみが供給された場合のフォールバックが実装されています。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>3つ以上の <code>NamedTuple</code> のマージには、少なくともJulia 1.1が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; merge((a=1, b=2, c=3), (b=4, d=5))
(a = 1, b = 4, c = 3, d = 5)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))
(a = 1, b = 3, c = (d = 2,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/namedtuple.jl#L309-L333">source</a></section><section><div><pre><code class="language-julia hljs">merge(a::NamedTuple, iterable)</code></pre><p>キーと値のペアのイテラブルを名前付きタプルとして解釈し、マージを実行します。</p><pre><code class="language-julia-repl hljs">julia&gt; merge((a=1, b=2, c=3), [:b=&gt;4, :d=&gt;5])
(a = 1, b = 4, c = 3, d = 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/namedtuple.jl#L357-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mergewith" href="#Base.mergewith"><code>Base.mergewith</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mergewith(combine, d::AbstractDict, others::AbstractDict...)
mergewith(combine)
merge(combine, d::AbstractDict, others::AbstractDict...)</code></pre><p>与えられたコレクションからマージされたコレクションを構築します。必要に応じて、結果のコレクションの型はマージされたコレクションの型に合わせて昇格されます。同じキーを持つ値は、コンバイナ関数を使用して結合されます。カリー化された形式 <code>mergewith(combine)</code> は、関数 <code>(args...) -&gt; mergewith(combine, args...)</code> を返します。</p><p>メソッド <code>merge(combine::Union{Function,Type}, args...)</code> は、後方互換性のために <code>mergewith(combine, args...)</code> のエイリアスとしてまだ利用可能です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>mergewith</code> は Julia 1.5 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String, Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String, Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; mergewith(+, a, b)
Dict{String, Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4753.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; ans == mergewith(+)(a, b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L362-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.merge!" href="#Base.merge!"><code>Base.merge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge!(d::AbstractDict, others::AbstractDict...)</code></pre><p>他のコレクションからのペアでコレクションを更新します。詳細は<a href="collections.html#Base.merge"><code>merge</code></a>を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(d1, d2);

julia&gt; d1
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L203-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mergewith!" href="#Base.mergewith!"><code>Base.mergewith!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mergewith!(combine, d::AbstractDict, others::AbstractDict...) -&gt; d
mergewith!(combine)
merge!(combine, d::AbstractDict, others::AbstractDict...) -&gt; d</code></pre><p>他のコレクションからのペアでコレクションを更新します。同じキーを持つ値は、コンバイナ関数を使用して結合されます。カリー化された形式 <code>mergewith!(combine)</code> は、関数 <code>(args...) -&gt; mergewith!(combine, args...)</code> を返します。</p><p>メソッド <code>merge!(combine::Union{Function,Type}, args...)</code> は、<code>mergewith!(combine, args...)</code> のエイリアスとして、後方互換性のためにまだ利用可能です。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>mergewith!</code> は Julia 1.5 以降が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; mergewith!(+, d1, d2);

julia&gt; d1
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 6

julia&gt; mergewith!(-, d1, d1);

julia&gt; d1
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 0
  3 =&gt; 0
  1 =&gt; 0

julia&gt; foldl(mergewith!(+), [d1, d2]; init=Dict{Int64, Int64}())
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 0
  1 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L236-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.sizehint!" href="#Base.sizehint!"><code>Base.sizehint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sizehint!(s, n; first::Bool=false, shrink::Bool=true) -&gt; s</code></pre><p>コレクション <code>s</code> が少なくとも <code>n</code> 要素の容量を予約することを提案します。つまり、<code>s</code> に多くの値をプッシュする必要があると予想される場合、最初に一度だけ行うことで、段階的な再割り当てのコストを回避できます。これによりパフォーマンスが向上する可能性があります。</p><p><code>first</code> が <code>true</code> の場合、追加のスペースはコレクションの開始前に予約されます。この方法により、<code>pushfirst!</code>（<code>push!</code> の代わりに）への後続の呼び出しが速くなる可能性があります。このキーワードを指定すると、コレクションが順序付けられていない場合や、<code>pushfirst!</code> がこのコレクションでサポートされていない場合にエラーが発生することがあります。</p><p><code>shrink=true</code>（デフォルト）である場合、コレクションの現在の容量が <code>n</code> より大きい場合、容量が減少する可能性があります。</p><p>詳細は <a href="collections.html#Base.resize!"><code>resize!</code></a> を参照してください。</p><p><strong>パフォーマンスモデルに関するノート</strong></p><p><code>sizehint!</code> をサポートする型について、</p><ol><li><code>push!</code> および <code>append!</code> メソッドは、一般的に（ただし必ずしも必要ではない）追加のストレージを事前に割り当てることがあります。<code>Base</code> に実装された型の場合、通常はそうであり、一般的な使用ケースに最適化されたヒューリスティックを使用します。</li><li><code>sizehint!</code> はこの事前割り当てを制御することがあります。再度言いますが、通常は <code>Base</code> の型に対してこれを行います。</li><li><code>empty!</code> は、この種の事前割り当てをサポートする型にとってほぼコストがかからず（O(1)）、非常に効率的です。</li></ol><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p><code>shrink</code> および <code>first</code> 引数は Julia 1.11 で追加されました。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1461-L1494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.keytype" href="#Base.keytype"><code>Base.keytype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keytype(T::Type{&lt;:AbstractArray})
keytype(A::AbstractArray)</code></pre><p>配列のキータイプを返します。これは、<code>keys(...)</code>の結果の<a href="collections.html#Base.eltype"><code>eltype</code></a>と等しく、主に辞書インターフェースとの互換性のために提供されています。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; keytype([1, 2, 3]) == Int
true

julia&gt; keytype([1 2; 3 4])
CartesianIndex{2}</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>配列の場合、この関数は少なくともJulia 1.2が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L168-L187">source</a></section><section><div><pre><code class="language-julia hljs">keytype(type)</code></pre><p>辞書型のキータイプを取得します。<a href="collections.html#Base.eltype"><code>eltype</code></a>と似た動作をします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; keytype(Dict(Int32(1) =&gt; &quot;foo&quot;))
Int32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L297-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.valtype" href="#Base.valtype"><code>Base.valtype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">valtype(T::Type{&lt;:AbstractArray})
valtype(A::AbstractArray)</code></pre><p>配列の値の型を返します。これは<a href="collections.html#Base.eltype"><code>eltype</code></a>と同じであり、主に辞書インターフェースとの互換性のために提供されています。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; valtype([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])
String</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>配列の場合、この関数は少なくともJulia 1.2が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractarray.jl#L197-L212">source</a></section><section><div><pre><code class="language-julia hljs">valtype(type)</code></pre><p>辞書型の値の型を取得します。<a href="collections.html#Base.eltype"><code>eltype</code></a>と似た動作をします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; valtype(Dict(Int32(1) =&gt; &quot;foo&quot;))
String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractdict.jl#L311-L321">source</a></section></article><p>完全に実装されました:</p><ul><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li></ul><p>部分的に実装されたのは：</p><ul><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.IdSet"><code>IdSet</code></a></li><li><a href="base.html#Base.EnvDict"><code>EnvDict</code></a></li><li><a href="arrays.html#Core.Array"><code>Array</code></a></li><li><a href="arrays.html#Base.BitArray"><code>BitArray</code></a></li><li><a href="collections.html#Base.ImmutableDict"><code>ImmutableDict</code></a></li><li><a href="collections.html#Base.PersistentDict"><code>PersistentDict</code></a></li><li><a href="collections.html#Base.Pairs"><code>Iterators.Pairs</code></a></li></ul><h2 id="Set-Like-Collections"><a class="docs-heading-anchor" href="#Set-Like-Collections">Set-Like Collections</a><a id="Set-Like-Collections-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Like-Collections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.AbstractSet" href="#Base.AbstractSet"><code>Base.AbstractSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSet{T}</code></pre><p>型 <code>T</code> の要素を持つ集合のような型のスーパタイプです。 <a href="collections.html#Base.Set"><code>Set</code></a>、<a href="collections.html#Base.BitSet"><code>BitSet</code></a> およびその他の型はそのサブタイプです。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Set" href="#Base.Set"><code>Base.Set</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Set{T} &lt;: AbstractSet{T}</code></pre><p><code>Set</code>は、迅速なメンバーシップテストを提供する可変コンテナです。</p><p><code>Set</code>は、<code>in</code>、<code>union</code>、<code>intersect</code>などの集合演算の効率的な実装を持っています。<code>Set</code>内の要素は、要素の<code>isequal</code>の定義によって決定されるユニークなものです。<code>Set</code>内の要素の順序は実装の詳細であり、信頼することはできません。</p><p>参照: <a href="collections.html#Base.AbstractSet"><code>AbstractSet</code></a>, <a href="collections.html#Base.BitSet"><code>BitSet</code></a>, <a href="collections.html#Base.Dict"><code>Dict</code></a>, <a href="collections.html#Base.push!"><code>push!</code></a>, <a href="collections.html#Base.empty!"><code>empty!</code></a>, <a href="collections.html#Base.union!"><code>union!</code></a>, <a href="collections.html#Base.in"><code>in</code></a>, <a href="base.html#Base.isequal"><code>isequal</code></a></p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Set(&quot;aaBca&quot;)
Set{Char} with 3 elements:
  &#39;a&#39;
  &#39;c&#39;
  &#39;B&#39;

julia&gt; push!(s, &#39;b&#39;)
Set{Char} with 4 elements:
  &#39;a&#39;
  &#39;b&#39;
  &#39;B&#39;
  &#39;c&#39;

julia&gt; s = Set([NaN, 0.0, 1.0, 2.0]);

julia&gt; -0.0 in s # isequal(0.0, -0.0) is false
false

julia&gt; NaN in s # isequal(NaN, NaN) is true
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L3-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.BitSet" href="#Base.BitSet"><code>Base.BitSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BitSet([itr])</code></pre><p>与えられたイテラブルオブジェクトによって生成された <code>Int</code> のソートされたセットを構築するか、空のセットを構築します。ビット文字列として実装されているため、密な整数セットのために設計されています。セットがスパースである場合（例えば、非常に大きな整数をいくつか保持する場合）、代わりに <a href="collections.html#Base.Set"><code>Set</code></a> を使用してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/bitset.jl#L25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.IdSet" href="#Base.IdSet"><code>Base.IdSet</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IdSet{T}([itr])
IdSet()</code></pre><p>IdSet{T}() は、型 <code>T</code> の値に対して <code>===</code> を等価性として使用してセット（<a href="collections.html#Base.Set"><code>Set</code></a> を参照）を構築します。</p><p>以下の例では、値はすべて <code>isequal</code> であるため、通常の <code>Set</code> では上書きされます。<code>IdSet</code> は <code>===</code> で比較するため、3つの異なる値を保持します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Set(Any[true, 1, 1.0])
Set{Any} with 1 element:
  1.0

julia&gt; IdSet{Any}(Any[true, 1, 1.0])
IdSet{Any} with 3 elements:
  1.0
  1
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/idset.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">union(s, itrs...)
∪(s, itrs...)</code></pre><p>すべての引数からの異なる要素を含むオブジェクトを構築します。</p><p>最初の引数は、返されるコンテナの種類を制御します。これが配列である場合、要素が最初に現れる順序を維持します。</p><p>Unicode <code>∪</code> は、Julia REPL で <code>\cup</code> と入力してタブを押すことで、また多くのエディタで入力できます。これは中置演算子であり、<code>s ∪ itr</code> のように使用できます。</p><p>関連項目としては <a href="collections.html#Base.unique"><code>unique</code></a>、<a href="collections.html#Base.intersect"><code>intersect</code></a>、<a href="collections.html#Base.isdisjoint"><code>isdisjoint</code></a>、<a href="arrays.html#Base.vcat"><code>vcat</code></a>、<a href="iterators.html#Base.Iterators.flatten"><code>Iterators.flatten</code></a> があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; union([1, 2], [3])
3-element Vector{Int64}:
 1
 2
 3

julia&gt; union([4 2 3 4 4], 1:3, 3.0)
4-element Vector{Float64}:
 4.0
 2.0
 3.0
 1.0

julia&gt; (0, 0.0) ∪ (-0.0, NaN)
3-element Vector{Real}:
   0
  -0.0
 NaN

julia&gt; union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L13-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.union!" href="#Base.union!"><code>Base.union!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">union!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>渡された集合の<a href="collections.html#Base.union"><code>union</code></a>を構築し、結果で<code>s</code>を上書きします。配列の順序を維持します。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Set([3, 4, 5]);

julia&gt; union!(a, 1:2:7);

julia&gt; a
Set{Int64} with 5 elements:
  5
  4
  7
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L62-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect(s, itrs...)
∩(s, itrs...)</code></pre><p>すべての引数に出現する要素を含む集合を構築します。</p><p>最初の引数は、返されるコンテナの種類を制御します。これが配列である場合、要素が最初に出現する順序を維持します。</p><p>Unicode <code>∩</code> は、Julia REPLで <code>\cap</code> と入力してタブを押すことで入力できます。また、多くのエディタでも同様です。これは中置演算子であり、<code>s ∩ itr</code> のように使用できます。</p><p>他にも <a href="collections.html#Base.setdiff"><code>setdiff</code></a>、<a href="collections.html#Base.isdisjoint"><code>isdisjoint</code></a>、<a href="collections.html#Base.issubset"><code>issubset</code></a>、<a href="collections.html#Base.issetequal"><code>issetequal</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>Julia 1.8以降、intersectは2つの入力の型昇格されたeltypeのeltypeを持つ結果を返します。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; intersect([1, 2, 3], [3, 4, 5])
1-element Vector{Int64}:
 3

julia&gt; intersect([1, 4, 4, 5, 6], [6, 4, 6, 7, 8])
2-element Vector{Int64}:
 4
 6

julia&gt; intersect(1:16, 7:99)
7:16

julia&gt; (0, 0.0) ∩ (-0.0, 0)
1-element Vector{Real}:
 0

julia&gt; intersect(Set([1, 2]), BitSet([2, 3]), 1.0:10.0)
Set{Float64} with 1 element:
  2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L112-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setdiff" href="#Base.setdiff"><code>Base.setdiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setdiff(s, itrs...)</code></pre><p><code>s</code>の要素のうち、<code>itrs</code>のいずれかに含まれない要素の集合を構築します。配列の順序を維持します。</p><p><a href="collections.html#Base.setdiff!"><code>setdiff!</code></a>、<a href="collections.html#Base.union"><code>union</code></a>、および<a href="collections.html#Base.intersect"><code>intersect</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setdiff([1,2,3], [3,4,5])
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L200-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setdiff!" href="#Base.setdiff!"><code>Base.setdiff!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setdiff!(s, itrs...)</code></pre><p>セット <code>s</code> から、各イテラブル <code>itrs</code> の各要素を（インプレースで）削除します。配列を使用して順序を維持します。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; setdiff!(a, 1:2:6);

julia&gt; a
Set{Int64} with 1 element:
  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L219-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.symdiff" href="#Base.symdiff"><code>Base.symdiff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symdiff(s, itrs...)</code></pre><p>渡された集合の要素の対称差を構築します。<code>s</code>が<code>AbstractSet</code>でない場合、順序は保持されます。</p><p>関連項目としては <a href="collections.html#Base.symdiff!"><code>symdiff!</code></a>、<a href="collections.html#Base.setdiff"><code>setdiff</code></a>、<a href="collections.html#Base.union"><code>union</code></a> および <a href="collections.html#Base.intersect"><code>intersect</code></a> があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; symdiff([1,2,3], [3,4,5], [4,5,6])
3-element Vector{Int64}:
 1
 2
 6

julia&gt; symdiff([1,2,1], [2, 1, 2])
Int64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L252-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.symdiff!" href="#Base.symdiff!"><code>Base.symdiff!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>渡された集合の対称差を構築し、結果で <code>s</code> を上書きします。<code>s</code> が配列の場合、順序は維持されます。この場合、要素の重複が重要です。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L275-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.intersect!" href="#Base.intersect!"><code>Base.intersect!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>渡されたすべての集合を交差させ、結果で<code>s</code>を上書きします。配列の順序を維持します。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.issubset" href="#Base.issubset"><code>Base.issubset</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issubset(a, b) -&gt; Bool
⊆(a, b) -&gt; Bool
⊇(b, a) -&gt; Bool</code></pre><p><code>a</code>のすべての要素が<code>b</code>にも含まれているかどうかを判断します。 <a href="collections.html#Base.in"><code>in</code></a>を使用してください。</p><p>他に<a href="collections.html#Base.:⊊"><code>⊊</code></a>、<a href="collections.html#Base.:⊈"><code>⊈</code></a>、<a href="collections.html#Base.intersect"><code>∩</code></a>、<a href="collections.html#Base.union"><code>∪</code></a>、<a href="strings.html#Base.contains"><code>contains</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; [1, 2, 3] ⊆ [1, 2]
false

julia&gt; [1, 2, 3] ⊇ [1, 2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L304-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.in!" href="#Base.in!"><code>Base.in!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">in!(x, s::AbstractSet) -&gt; Bool</code></pre><p><code>s</code>に<code>x</code>が含まれていれば<code>true</code>を返します。そうでなければ、<code>x</code>を<code>s</code>に追加して<code>false</code>を返します。これは<code>in(x, s) ? true : (push!(s, x); false)</code>と同等ですが、より効率的な実装が可能です。</p><p>関連情報: <a href="collections.html#Base.in"><code>in</code></a>, <a href="collections.html#Base.push!"><code>push!</code></a>, <a href="collections.html#Base.Set"><code>Set</code></a></p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p>この関数は少なくとも1.11が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Set{Any}([1, 2, 3]); in!(4, s)
false

julia&gt; length(s)
4

julia&gt; in!(0x04, s)
true

julia&gt; s
Set{Any} with 4 elements:
  4
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/set.jl#L94-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊈" href="#Base.:⊈"><code>Base.:⊈</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊈(a, b) -&gt; Bool
⊉(b, a) -&gt; Bool</code></pre><p><code>⊆</code> と <code>⊇</code> の否定、すなわち <code>a</code> が <code>b</code> の部分集合でないことを確認します。</p><p>関連情報として <a href="collections.html#Base.issubset"><code>issubset</code></a> (<code>⊆</code>)、<a href="collections.html#Base.:⊊"><code>⊊</code></a> を参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2) ⊈ (2, 3)
true

julia&gt; (1, 2) ⊈ (1, 2, 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L448-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊊" href="#Base.:⊊"><code>Base.:⊊</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊊(a, b) -&gt; Bool
⊋(b, a) -&gt; Bool</code></pre><p><code>a</code>が<code>b</code>の部分集合であるが、等しくないかどうかを判断します。</p><p>関連情報としては、<a href="collections.html#Base.issubset"><code>issubset</code></a> (<code>⊆</code>)、<a href="collections.html#Base.:⊈"><code>⊈</code></a>があります。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2) ⊊ (1, 2, 3)
true

julia&gt; (1, 2) ⊊ (1, 2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L396-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.issetequal" href="#Base.issetequal"><code>Base.issetequal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">issetequal(a, b) -&gt; Bool</code></pre><p><code>a</code> と <code>b</code> が同じ要素を持っているかどうかを判断します。<code>a ⊆ b &amp;&amp; b ⊆ a</code> と同等ですが、可能な場合はより効率的です。</p><p>関連項目: <a href="collections.html#Base.isdisjoint"><code>isdisjoint</code></a>, <a href="collections.html#Base.union"><code>union</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issetequal([1, 2], [1, 2, 3])
false

julia&gt; issetequal([1, 2], [2, 1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L498-L514">source</a></section><section><div><pre><code class="language-julia hljs">issetequal(x)</code></pre><p>引数を <code>x</code> と比較する関数を作成します。これは <a href="collections.html#Base.issetequal"><code>issetequal</code></a> を使用します。すなわち、<code>y -&gt; issetequal(y, x)</code> に相当する関数です。返される関数は <code>Base.Fix2{typeof(issetequal)}</code> 型であり、特化したメソッドを実装するために使用できます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p>この機能は少なくとも Julia 1.11 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L532-L542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isdisjoint" href="#Base.isdisjoint"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isdisjoint(a, b) -&gt; Bool</code></pre><p>コレクション <code>a</code> と <code>b</code> が互いに素であるかどうかを判断します。<code>isempty(a ∩ b)</code> と同等ですが、可能な場合はより効率的です。</p><p>関連情報: <a href="collections.html#Base.intersect"><code>intersect</code></a>, <a href="collections.html#Base.isempty"><code>isempty</code></a>, <a href="collections.html#Base.issetequal"><code>issetequal</code></a>。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>この関数は少なくとも Julia 1.5 を必要とします。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isdisjoint([1, 2], [2, 3, 4])
false

julia&gt; isdisjoint([3, 1], [2, 4])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L546-L565">source</a></section><section><div><pre><code class="language-julia hljs">isdisjoint(x)</code></pre><p>引数を <code>x</code> と比較する関数を作成します。これは <a href="collections.html#Base.isdisjoint"><code>isdisjoint</code></a> を使用し、すなわち <code>y -&gt; isdisjoint(y, x)</code> と同等の関数です。返される関数は <code>Base.Fix2{typeof(isdisjoint)}</code> 型であり、特化したメソッドを実装するために使用できます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.11</header><div class="admonition-body"><p>この機能は少なくとも Julia 1.11 が必要です。</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/abstractset.jl#L591-L601">source</a></section></article><p>完全に実装されたのは：</p><ul><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.IdSet"><code>IdSet</code></a></li></ul><p>部分的に実装されたのは：</p><ul><li><a href="arrays.html#Core.Array"><code>Array</code></a></li></ul><h2 id="Dequeues"><a class="docs-heading-anchor" href="#Dequeues">Dequeues</a><a id="Dequeues-1"></a><a class="docs-heading-anchor-permalink" href="#Dequeues" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push!(collection, items...) -&gt; collection</code></pre><p>1つ以上の<code>items</code>を<code>collection</code>に挿入します。<code>collection</code>が順序付きコンテナである場合、アイテムは最後に（指定された順序で）挿入されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!([1, 2, 3], 4, 5, 6)
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p><code>collection</code>が順序付きである場合、<a href="collections.html#Base.append!"><code>append!</code></a>を使用して別のコレクションのすべての要素を追加できます。前の例の結果は、<code>append!([1, 2, 3], [4, 5, 6])</code>と同等です。<code>AbstractSet</code>オブジェクトの場合は、<a href="collections.html#Base.union!"><code>union!</code></a>を代わりに使用できます。</p><p>パフォーマンスモデルに関する注意については、<a href="collections.html#Base.sizehint!"><code>sizehint!</code></a>を参照してください。</p><p>また、<a href="collections.html#Base.pushfirst!"><code>pushfirst!</code></a>も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1230-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pop!(collection) -&gt; item</code></pre><p><code>collection</code> からアイテムを削除し、それを返します。<code>collection</code> が順序付きコンテナの場合、最後のアイテムが返されます; 順序なしコンテナの場合は、任意の要素が返されます。</p><p>参照: <a href="collections.html#Base.popfirst!"><code>popfirst!</code></a>, <a href="collections.html#Base.popat!"><code>popat!</code></a>, <a href="collections.html#Base.delete!"><code>delete!</code></a>, <a href="collections.html#Base.deleteat!"><code>deleteat!</code></a>, <a href="collections.html#Base.splice!"><code>splice!</code></a>, および <a href="collections.html#Base.push!"><code>push!</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A=[1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; pop!(A)
3

julia&gt; A
2-element Vector{Int64}:
 1
 2

julia&gt; S = Set([1, 2])
Set{Int64} with 2 elements:
  2
  1

julia&gt; pop!(S)
2

julia&gt; S
Set{Int64} with 1 element:
  1

julia&gt; pop!(Dict(1=&gt;2))
1 =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1539-L1579">source</a></section><section><div><pre><code class="language-julia hljs">pop!(collection, key[, default])</code></pre><p><code>collection</code>に<code>key</code>が存在する場合は、そのマッピングを削除して返します。存在しない場合は<code>default</code>を返すか、<code>default</code>が指定されていない場合はエラーをスローします。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/dict.jl#L586-L607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.popat!" href="#Base.popat!"><code>Base.popat!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">popat!(a::Vector, i::Integer, [default])</code></pre><p>指定された <code>i</code> のアイテムを削除し、それを返します。以降のアイテムは、結果として生じる隙間を埋めるためにシフトされます。<code>i</code> が <code>a</code> の有効なインデックスでない場合、<code>default</code> を返すか、<code>default</code> が指定されていない場合はエラーをスローします。</p><p>関連項目: <a href="collections.html#Base.pop!"><code>pop!</code></a>, <a href="collections.html#Base.popfirst!"><code>popfirst!</code></a>, <a href="collections.html#Base.deleteat!"><code>deleteat!</code></a>, <a href="collections.html#Base.splice!"><code>splice!</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>この関数は Julia 1.5 以降で利用可能です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [4, 3, 2, 1]; popat!(a, 2)
3

julia&gt; a
3-element Vector{Int64}:
 4
 2
 1

julia&gt; popat!(a, 4, missing)
missing

julia&gt; popat!(a, 4)
ERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1589-L1620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.pushfirst!" href="#Base.pushfirst!"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pushfirst!(collection, items...) -&gt; collection</code></pre><p>コレクションの先頭に1つ以上の<code>items</code>を挿入します。</p><p>この関数は多くの他のプログラミング言語では<code>unshift</code>と呼ばれています。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pushfirst!([1, 2, 3, 4], 5, 6)
6-element Vector{Int64}:
 5
 6
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1637-L1655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.popfirst!" href="#Base.popfirst!"><code>Base.popfirst!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">popfirst!(collection) -&gt; item</code></pre><p>コレクションから最初の <code>item</code> を削除します。</p><p>この関数は多くの他のプログラミング言語では <code>shift</code> と呼ばれています。</p><p>参照: <a href="collections.html#Base.pop!"><code>pop!</code></a>, <a href="collections.html#Base.popat!"><code>popat!</code></a>, <a href="collections.html#Base.delete!"><code>delete!</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 2, 3, 4, 5, 6]
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6

julia&gt; popfirst!(A)
1

julia&gt; A
5-element Vector{Int64}:
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1680-L1711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.insert!" href="#Base.insert!"><code>Base.insert!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert!(a::Vector, index::Integer, item)</code></pre><p>指定された <code>index</code> で <code>a</code> に <code>item</code> を挿入します。<code>index</code> は結果の <code>a</code> における <code>item</code> のインデックスです。</p><p>参照: <a href="collections.html#Base.push!"><code>push!</code></a>, <a href="collections.html#Base.replace-Tuple{Any, Vararg{Pair}}"><code>replace</code></a>, <a href="collections.html#Base.popat!"><code>popat!</code></a>, <a href="collections.html#Base.splice!"><code>splice!</code></a>.</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; insert!(Any[1:6;], 3, &quot;here&quot;)
7-element Vector{Any}:
 1
 2
  &quot;here&quot;
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1721-L1741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.deleteat!" href="#Base.deleteat!"><code>Base.deleteat!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deleteat!(a::Vector, i::Integer)</code></pre><p>指定された <code>i</code> のアイテムを削除し、修正された <code>a</code> を返します。後続のアイテムは、結果として生じる隙間を埋めるためにシフトされます。</p><p>参照: <a href="collections.html#Base.keepat!"><code>keepat!</code></a>, <a href="collections.html#Base.delete!"><code>delete!</code></a>, <a href="collections.html#Base.popat!"><code>popat!</code></a>, <a href="collections.html#Base.splice!"><code>splice!</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Vector{Int64}:
 6
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1752-L1770">source</a></section><section><div><pre><code class="language-julia hljs">deleteat!(a::Vector, inds)</code></pre><p><code>inds</code> で指定されたインデックスのアイテムを削除し、修正された <code>a</code> を返します。後続のアイテムは、結果として生じた隙間を埋めるためにシフトされます。</p><p><code>inds</code> は、イテレータまたはソートされていてユニークな整数インデックスのコレクション、または <code>a</code> と同じ長さのブールベクターで、<code>true</code> が削除するエントリを示します。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Vector{Int64}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Vector{Int64}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1789-L1817">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.keepat!" href="#Base.keepat!"><code>Base.keepat!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">keepat!(a::Vector, inds)
keepat!(a::BitVector, inds)</code></pre><p><code>inds</code> で指定されていないすべてのインデックスのアイテムを削除し、修正された <code>a</code> を返します。保持されるアイテムは、結果のギャップを埋めるためにシフトされます。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><p><code>inds</code> は、ソートされていてユニークな整数インデックスのイテレータでなければなりません。詳細は <a href="collections.html#Base.deleteat!"><code>deleteat!</code></a> を参照してください。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.7</header><div class="admonition-body"><p>この関数は Julia 1.7 以降で利用可能です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; keepat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Vector{Int64}:
 6
 4
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L2961-L2985">source</a></section><section><div><pre><code class="language-julia hljs">keepat!(a::Vector, m::AbstractVector{Bool})
keepat!(a::BitVector, m::AbstractVector{Bool})</code></pre><p>論理インデックスのインプレースバージョン <code>a = a[m]</code>。つまり、同じ長さのベクトル <code>a</code> と <code>m</code> に対して <code>keepat!(a, m)</code> を実行すると、対応するインデックスで <code>m</code> が <code>false</code> の <code>a</code> のすべての要素が削除されます。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [:a, :b, :c];

julia&gt; keepat!(a, [true, false, true])
2-element Vector{Symbol}:
 :a
 :c

julia&gt; a
2-element Vector{Symbol}:
 :a
 :c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L2988-L3010">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.splice!" href="#Base.splice!"><code>Base.splice!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">splice!(a::Vector, index::Integer, [replacement]) -&gt; item</code></pre><p>指定されたインデックスのアイテムを削除し、削除されたアイテムを返します。次のアイテムは、結果として生じる隙間を埋めるために左にシフトされます。指定された場合、順序付きコレクションからの置換値が削除されたアイテムの代わりに挿入されます。</p><p>参照: <a href="collections.html#Base.replace-Tuple{Any, Vararg{Pair}}"><code>replace</code></a>, <a href="collections.html#Base.delete!"><code>delete!</code></a>, <a href="collections.html#Base.deleteat!"><code>deleteat!</code></a>, <a href="collections.html#Base.pop!"><code>pop!</code></a>, <a href="collections.html#Base.popat!"><code>popat!</code></a>。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia&gt; A
5-element Vector{Int64}:
 6
 5
 4
 3
 1

julia&gt; splice!(A, 5, -1)
1

julia&gt; A
5-element Vector{Int64}:
  6
  5
  4
  3
 -1

julia&gt; splice!(A, 1, [-1, -2, -3])
6

julia&gt; A
7-element Vector{Int64}:
 -1
 -2
 -3
  5
  4
  3
 -1</code></pre><p>アイテムを削除せずにインデックス <code>n</code> の前に <code>replacement</code> を挿入するには、<code>splice!(collection, n:n-1, replacement)</code> を使用します。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1892-L1942">source</a></section><section><div><pre><code class="language-julia hljs">splice!(a::Vector, indices, [replacement]) -&gt; items</code></pre><p>指定されたインデックスでアイテムを削除し、削除されたアイテムを含むコレクションを返します。次のアイテムは、結果として生じる隙間を埋めるために左にシフトされます。指定された場合、順序付きコレクションからの置換値が削除されたアイテムの代わりにスプライスされます。この場合、<code>indices</code> は <code>AbstractUnitRange</code> でなければなりません。</p><p>アイテムを削除せずにインデックス <code>n</code> の前に <code>replacement</code> を挿入するには、<code>splice!(collection, n:n-1, replacement)</code> を使用します。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>変更された引数が他の引数とメモリを共有している場合、動作が予期しないものになることがあります。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Julia 1.5 より前では、<code>indices</code> は常に <code>UnitRange</code> でなければなりません。</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>Julia 1.8 より前では、置換値をスプライスする場合、<code>indices</code> は <code>UnitRange</code> でなければなりません。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)
Int64[]

julia&gt; A
8-element Vector{Int64}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1961-L1997">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.resize!" href="#Base.resize!"><code>Base.resize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resize!(a::Vector, n::Integer) -&gt; Vector</code></pre><p><code>a</code>を<code>n</code>要素を含むようにサイズ変更します。<code>n</code>が現在のコレクションの長さより小さい場合、最初の<code>n</code>要素が保持されます。<code>n</code>が大きい場合、新しい要素が初期化されることは保証されません。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; resize!([6, 5, 4, 3, 2, 1], 3)
3-element Vector{Int64}:
 6
 5
 4

julia&gt; a = resize!([6, 5, 4, 3, 2, 1], 8);

julia&gt; length(a)
8

julia&gt; a[1:6]
6-element Vector{Int64}:
 6
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1417-L1446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append!(collection, collections...) -&gt; collection.</code></pre><p>順序付きコンテナ <code>collection</code> に、各 <code>collections</code> の要素をその末尾に追加します。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>複数のコレクションを追加するには、少なくとも Julia 1.6 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; append!([1], [2, 3])
3-element Vector{Int64}:
 1
 2
 3

julia&gt; append!([1, 2, 3], [4, 5], [6])
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p><a href="collections.html#Base.push!"><code>push!</code></a> を使用して、他のコレクションにすでに含まれていない個々のアイテムを <code>collection</code> に追加します。前の例の結果は <code>push!([1, 2, 3], 4, 5, 6)</code> と同等です。</p><p>パフォーマンスモデルに関する注意については、<a href="collections.html#Base.sizehint!"><code>sizehint!</code></a> を参照してください。</p><p>ベクトルについては <a href="arrays.html#Base.vcat"><code>vcat</code></a>、集合については <a href="collections.html#Base.union!"><code>union!</code></a>、逆の順序については <a href="collections.html#Base.prepend!"><code>prepend!</code></a> と <a href="collections.html#Base.pushfirst!"><code>pushfirst!</code></a> も参照してください。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1283-L1318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepend!(a::Vector, collections...) -&gt; collection</code></pre><p>各 <code>collections</code> の要素を <code>a</code> の先頭に挿入します。</p><p><code>collections</code> が複数のコレクションを指定する場合、順序は維持されます：<code>collections[1]</code> の要素が <code>a</code> の左端に表示され、その後に続きます。</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>複数のコレクションを先頭に追加するには、少なくとも Julia 1.6 が必要です。</p></div></div><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prepend!([3], [1, 2])
3-element Vector{Int64}:
 1
 2
 3

julia&gt; prepend!([6], [1, 2], [3, 4, 5])
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/array.jl#L1349-L1377">source</a></section></article><p>完全に実装されました:</p><ul><li><code>ベクター</code>（別名：1次元 <a href="arrays.html#Core.Array"><code>Array</code></a>）</li><li><code>BitVector</code>（別名 1次元 <a href="arrays.html#Base.BitArray"><code>BitArray</code></a>）</li></ul><h2 id="Utility-Collections"><a class="docs-heading-anchor" href="#Utility-Collections">Utility Collections</a><a id="Utility-Collections-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Collections" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Core.Pair" href="#Core.Pair"><code>Core.Pair</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Pair(x, y)
x =&gt; y</code></pre><p><code>Pair</code>オブジェクトを型<code>Pair{typeof(x), typeof(y)}</code>で構築します。要素はフィールド<code>first</code>と<code>second</code>に格納されます。また、反復処理を通じてアクセスすることもできます（ただし、<code>Pair</code>はブロードキャスト操作のために単一の「スカラー」として扱われます）。</p><p><a href="collections.html#Base.Dict"><code>Dict</code></a>も参照してください。</p><p><strong>例</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = &quot;foo&quot; =&gt; 7
&quot;foo&quot; =&gt; 7

julia&gt; typeof(p)
Pair{String, Int64}

julia&gt; p.first
&quot;foo&quot;

julia&gt; for x in p
           println(x)
       end
foo
7

julia&gt; replace.([&quot;xops&quot;, &quot;oxps&quot;], &quot;x&quot; =&gt; &quot;o&quot;)
2-element Vector{String}:
 &quot;oops&quot;
 &quot;oops&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/pair.jl#L5-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Pairs" href="#Base.Pairs"><code>Base.Pairs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.Pairs(values, keys) &lt;: AbstractDict{eltype(keys), eltype(values)}</code></pre><p>インデックス可能なコンテナを同じデータの辞書ビューに変換します。基になるデータのキー空間を変更すると、このオブジェクトが無効になる可能性があります。</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/760b2e5b7396f9cc0da5efce0cadd5d1974c4069/base/essentials.jl#L488-L493">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="base.html">« Essentials</a><a class="docs-footer-nextpage" href="math.html">Mathematics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 21 May 2025 10:49">Wednesday 21 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
