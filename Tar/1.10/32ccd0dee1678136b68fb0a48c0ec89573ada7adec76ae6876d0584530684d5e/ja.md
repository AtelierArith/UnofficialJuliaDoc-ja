```
tree_hash([ predicate, ] tarball;
          [ algorithm = "git-sha1", ]
          [ skip_empty = false ]) -> hash::String

    predicate  :: Header --> Bool
    tarball    :: Union{AbstractString, AbstractCmd, IO}
    algorithm  :: AbstractString
    skip_empty :: Bool
```

tarballが含むファイルツリーのツリーハッシュ値を計算します。デフォルトでは、これはgitのツリーハッシュアルゴリズムを使用し、SHA1セキュアハッシュ関数を使用します（現在のgitのバージョンのように）。これは、gitが表現できるファイルツリーを持つ任意のtarball、つまりファイル、シンボリックリンク、および非空のディレクトリのみを持つtarballに対して、この関数によって計算されたハッシュ値が、そのファイルツリーに対してgitが計算するハッシュ値と同じであることを意味します。tarballは空のディレクトリを持つファイルツリーを表現できることに注意してください。gitはそれを保存できませんが、この関数はそれらのハッシュを生成できます。デフォルトでは（この動作を変更する方法については以下の`skip_empty`を参照）、これらの空のディレクトリを省略するtarballのハッシュとは異なります。要するに、ハッシュ関数はgitが表現できるすべてのツリーに対してgitと一致しますが、gitが表現できない他のツリーに対してハッシュ可能なツリーのドメインを一貫した方法で拡張します。

`predicate`関数が渡されると、`tarball`を処理している間に遭遇する各`Header`オブジェクトに対して呼び出され、`predicate(hdr)`がtrueの場合にのみエントリがハッシュされます。これは、アーカイブの一部のみを選択的にハッシュしたり、`extract`がエラーをスローする原因となるエントリをスキップしたり、ハッシュ処理中に抽出されたものを記録するために使用できます。

`Header`オブジェクトは、predicate関数に渡される前に、tarball内の生のヘッダーから若干変更されます：`path`フィールドは、`.`エントリを削除し、連続するスラッシュを単一のスラッシュに置き換えるように正規化されます。エントリのタイプが`:hardlink`の場合、リンクターゲットパスも同様に正規化され、ターゲットエントリのパスと一致するようになります；サイズフィールドはターゲットパスのサイズに設定されます（これはすでに見たファイルでなければなりません）。

現在サポートされている`algorithm`の値は、`git-sha1`（デフォルト）と`git-sha256`です。後者は、`git-sha1`と同じ基本アルゴリズムを使用しますが、SHA1ハッシュ関数をSHA2-256に置き換えます。これは、gitが将来的に使用することになるハッシュ関数です（SHA1に対する既知の攻撃のため）。将来的に他のファイルツリーハッシングアルゴリズムのサポートが追加される可能性があります。

`skip_empty`オプションは、再帰的にファイルやシンボリックリンクを含まないディレクトリがハッシュに含まれるか無視されるかを制御します。一般的に、tarballやファイルツリーの内容をハッシュする場合、空でないディレクトリだけでなく、すべてのディレクトリに関心があるため、これらを計算されたハッシュに含めることがデフォルトです。では、なぜこの関数は空のディレクトリをスキップするオプションを提供するのでしょうか？それは、gitが空のディレクトリを保存することを拒否し、それらをリポジトリに追加しようとすると無視するからです。したがって、ファイルをgitリポジトリに追加して参照ツリーハッシュを計算し、その後gitにツリーハッシュを要求すると、得られるハッシュ値は、`skip_empty=true`の`tree_hash`によって計算されたハッシュ値と一致します。言い換えれば、このオプションは`tree_hash`が空のディレクトリを持つツリーをgitがどのようにハッシュするかをエミュレートできるようにします。ただし、空のディレクトリを含むツリー（つまり、gitリポジトリから来ていないもの）をハッシュする場合は、空のディレクトリを無視しないツール（このツールなど）を使用してハッシュすることをお勧めします。
